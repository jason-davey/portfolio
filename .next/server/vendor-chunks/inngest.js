"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/inngest";
exports.ids = ["vendor-chunks/inngest"];
exports.modules = {

/***/ "(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/ansi-regex/index.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = (options)=>{\n    options = Object.assign({\n        onlyFirst: false\n    }, options);\n    const pattern = [\n        \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n        \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"\n    ].join(\"|\");\n    return new RegExp(pattern, options.onlyFirst ? undefined : \"g\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUdDLENBQUFBO0lBQ2hCQSxVQUFVQyxPQUFPQyxNQUFNLENBQUM7UUFDdkJDLFdBQVc7SUFDWixHQUFHSDtJQUVILE1BQU1JLFVBQVU7UUFDZjtRQUNBO0tBQ0EsQ0FBQ0MsSUFBSSxDQUFDO0lBRVAsT0FBTyxJQUFJQyxPQUFPRixTQUFTSixRQUFRRyxTQUFTLEdBQUdJLFlBQVk7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3Qvbm9kZV9tb2R1bGVzL2Fuc2ktcmVnZXgvaW5kZXguanM/MWJjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gb3B0aW9ucyA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRvbmx5Rmlyc3Q6IGZhbHNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IHBhdHRlcm4gPSBbXG5cdFx0J1tcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNyknLFxuXHRcdCcoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKSdcblx0XS5qb2luKCd8Jyk7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgb3B0aW9ucy5vbmx5Rmlyc3QgPyB1bmRlZmluZWQgOiAnZycpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIm9ubHlGaXJzdCIsInBhdHRlcm4iLCJqb2luIiwiUmVnRXhwIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/strip-ansi/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ansiRegex = __webpack_require__(/*! ansi-regex */ \"(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js\");\nconst stripAnsi = (string)=>typeof string === \"string\" ? string.replace(ansiRegex(), \"\") : string;\nmodule.exports = stripAnsi;\nmodule.exports[\"default\"] = stripAnsi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDO0FBRTFCLE1BQU1DLFlBQVlDLENBQUFBLFNBQVUsT0FBT0EsV0FBVyxXQUFXQSxPQUFPQyxPQUFPLENBQUNKLGFBQWEsTUFBTUc7QUFFM0ZFLE9BQU9DLE9BQU8sR0FBR0o7QUFDakJHLHlCQUFzQixHQUFHSCIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcz8wMTI2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKTtcblxuY29uc3Qgc3RyaXBBbnNpID0gc3RyaW5nID0+IHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnID8gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4KCksICcnKSA6IHN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpcEFuc2k7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaXBBbnNpO1xuIl0sIm5hbWVzIjpbImFuc2lSZWdleCIsInJlcXVpcmUiLCJzdHJpcEFuc2kiLCJzdHJpbmciLCJyZXBsYWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js":
/*!***********************************************************!*\
  !*** ./node_modules/inngest/_virtual/rolldown_runtime.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __export: () => (/* binding */ __export),\n/* harmony export */   __require: () => (/* binding */ __require)\n/* harmony export */ });\n//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __export = (all)=>{\n    let target = {};\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n    return target;\n};\nvar __require = /* @__PURE__ */ ((x)=>typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n        get: (a, b)=>(typeof require !== \"undefined\" ? require : a)[b]\n    }) : x)(function(x) {\n    if (typeof require !== \"undefined\") return require.apply(this, arguments);\n    throw Error('Calling `require` for \"' + x + \"\\\" in an environment that doesn't expose the `require` function.\");\n});\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9fdmlydHVhbC9yb2xsZG93bl9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMEJBQTBCO0FBQzFCLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQztJQUNmLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUssSUFBSUMsUUFBUUYsSUFBS0osVUFBVUssUUFBUUMsTUFBTTtRQUM3Q0MsS0FBS0gsR0FBRyxDQUFDRSxLQUFLO1FBQ2RFLFlBQVk7SUFDYjtJQUNBLE9BQU9IO0FBQ1I7QUFDQSxJQUFJSSxZQUE0QixhQUFILEdBQUksRUFBQ0MsSUFBTSxPQUFPQyxZQUFZLGNBQWNBLFVBQVUsT0FBT0MsVUFBVSxjQUFjLElBQUlBLE1BQU1GLEdBQUc7UUFBRUgsS0FBSyxDQUFDTSxHQUFHQyxJQUFNLENBQUMsT0FBT0gsWUFBWSxjQUFjQSxVQUFVRSxDQUFBQSxDQUFFLENBQUNDLEVBQUU7SUFBQyxLQUFLSixDQUFBQSxFQUFHLFNBQVNBLENBQUM7SUFDbk4sSUFBSSxPQUFPQyxZQUFZLGFBQWEsT0FBT0EsUUFBUUksS0FBSyxDQUFDLElBQUksRUFBRUM7SUFDL0QsTUFBTUMsTUFBTSw0QkFBNkJQLElBQUk7QUFDOUM7QUFFQSxZQUFZO0FBQ21CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L192aXJ0dWFsL3JvbGxkb3duX3J1bnRpbWUuanM/OGYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gcm9sbGRvd246cnVudGltZVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9IChhbGwpID0+IHtcblx0bGV0IHRhcmdldCA9IHt9O1xuXHRmb3IgKHZhciBuYW1lIGluIGFsbCkgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwge1xuXHRcdGdldDogYWxsW25hbWVdLFxuXHRcdGVudW1lcmFibGU6IHRydWVcblx0fSk7XG5cdHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fcmVxdWlyZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHgpID0+IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBQcm94eSh4LCB7IGdldDogKGEsIGIpID0+ICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiBhKVtiXSB9KSA6IHgpKGZ1bmN0aW9uKHgpIHtcblx0aWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR0aHJvdyBFcnJvcihcIkNhbGxpbmcgYHJlcXVpcmVgIGZvciBcXFwiXCIgKyB4ICsgXCJcXFwiIGluIGFuIGVudmlyb25tZW50IHRoYXQgZG9lc24ndCBleHBvc2UgdGhlIGByZXF1aXJlYCBmdW5jdGlvbi5cIik7XG59KTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBfX2V4cG9ydCwgX19yZXF1aXJlIH07Il0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJhbGwiLCJ0YXJnZXQiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fcmVxdWlyZSIsIngiLCJyZXF1aXJlIiwiUHJveHkiLCJhIiwiYiIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/api/api.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/api/api.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InngestApi: () => (/* binding */ InngestApi)\n/* harmony export */ });\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _schema_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var _helpers_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/* harmony import */ var _helpers_devserver_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\n/* harmony import */ var _helpers_net_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n\n\n\n\n\n\n\n\n//#region src/api/api.ts\nconst realtimeSubscriptionTokenSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    jwt: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nconst sendSignalSuccessResponseSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    data: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n        run_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string().min(1)\n    })\n});\nconst checkpointNewRunResponseSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    data: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n        fn_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string().min(1),\n        app_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string().min(1),\n        run_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string().min(1),\n        token: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string().min(1).optional()\n    })\n});\nvar InngestApi = class {\n    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode }){\n        this.apiBaseUrl = baseUrl;\n        this.signingKey = signingKey;\n        this.signingKeyFallback = signingKeyFallback;\n        this.fetch = fetch;\n        this.mode = mode;\n    }\n    get hashedKey() {\n        return (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_1__.hashSigningKey)(this.signingKey);\n    }\n    get hashedFallbackKey() {\n        if (!this.signingKeyFallback) return;\n        return (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_1__.hashSigningKey)(this.signingKeyFallback);\n    }\n    setSigningKey(key) {\n        if (typeof key === \"string\" && this.signingKey === \"\") this.signingKey = key;\n    }\n    setSigningKeyFallback(key) {\n        if (typeof key === \"string\" && !this.signingKeyFallback) this.signingKeyFallback = key;\n    }\n    async getTargetUrl(path) {\n        if (this.apiBaseUrl) return new URL(path, this.apiBaseUrl);\n        let url = new URL(path, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.defaultInngestApiBaseUrl);\n        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n            if (await (0,_helpers_devserver_js__WEBPACK_IMPORTED_MODULE_3__.devServerAvailable)(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.defaultDevServerHost, this.fetch)) url = new URL(path, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.defaultDevServerHost);\n        }\n        return url;\n    }\n    async req(url, options) {\n        const finalUrl = typeof url === \"string\" ? await this.getTargetUrl(url) : url;\n        try {\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)(await (0,_helpers_net_js__WEBPACK_IMPORTED_MODULE_5__.fetchWithAuthFallback)({\n                authToken: this.hashedKey,\n                authTokenFallback: this.hashedFallbackKey,\n                fetch: this.fetch,\n                url: finalUrl,\n                options: {\n                    ...options,\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...options?.headers\n                    }\n                }\n            }));\n        } catch (error) {\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)(error);\n        }\n    }\n    async getRunSteps(runId, version) {\n        const result = await this.req(`/v0/runs/${runId}/actions`);\n        if (result.ok) {\n            const res = result.value;\n            const data = await res.json();\n            if (res.ok) return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)(_schema_js__WEBPACK_IMPORTED_MODULE_6__.stepsSchemas[version].parse(data));\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)(_schema_js__WEBPACK_IMPORTED_MODULE_6__.errorSchema.parse(data));\n        }\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n            error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(result.error, \"Unknown error retrieving step data\"),\n            status: 500\n        });\n    }\n    async getRunBatch(runId) {\n        const result = await this.req(`/v0/runs/${runId}/batch`);\n        if (result.ok) {\n            const res = result.value;\n            const data = await res.json();\n            if (res.ok) return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)(_schema_js__WEBPACK_IMPORTED_MODULE_6__.batchSchema.parse(data));\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)(_schema_js__WEBPACK_IMPORTED_MODULE_6__.errorSchema.parse(data));\n        }\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n            error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(result.error, \"Unknown error retrieving event batch\"),\n            status: 500\n        });\n    }\n    async publish(publishOptions, data) {\n        const isStream = data instanceof ReadableStream;\n        const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n        url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n        if (publishOptions.runId) url.searchParams.set(\"run_id\", publishOptions.runId);\n        for (const topic of publishOptions.topics)url.searchParams.append(\"topic\", topic);\n        const result = await this.req(url, {\n            body: isStream ? data : typeof data === \"string\" ? data : JSON.stringify(data),\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": isStream ? \"text/stream\" : \"application/json\"\n            },\n            ...isStream ? {\n                duplex: \"half\"\n            } : {}\n        });\n        if (result.ok) {\n            const res = result.value;\n            if (!res.ok) throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)(void 0);\n        }\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n            error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(result.error, \"Unknown error publishing event\"),\n            status: 500\n        });\n    }\n    async sendSignal(signalOptions, options) {\n        const url = await this.getTargetUrl(\"/v1/signals\");\n        const body = {\n            signal: signalOptions.signal,\n            data: signalOptions.data\n        };\n        return (0,_helpers_net_js__WEBPACK_IMPORTED_MODULE_5__.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...options?.headers\n                }\n            }\n        }).then(async (res)=>{\n            if (res.status === 404) return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)({\n                runId: void 0\n            });\n            const resClone = res.clone();\n            let json;\n            try {\n                json = await res.json();\n            } catch  {\n                return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status\n                });\n            }\n            if (!res.ok) try {\n                return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)(_schema_js__WEBPACK_IMPORTED_MODULE_6__.errorSchema.parse(json));\n            } catch  {\n                return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,\n                    status: res.status\n                });\n            }\n            const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n            if (!parseRes.success) return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n                error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                status: res.status\n            });\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)({\n                runId: parseRes.data.data.run_id\n            });\n        }).catch((error)=>{\n            return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)({\n                error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error, \"Unknown error sending signal\"),\n                status: 500\n            });\n        });\n    }\n    async getSubscriptionToken(channel, topics) {\n        const url = await this.getTargetUrl(\"/v1/realtime/token\");\n        const body = topics.map((topic)=>({\n                channel,\n                name: topic,\n                kind: \"run\"\n            }));\n        return (0,_helpers_net_js__WEBPACK_IMPORTED_MODULE_5__.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                }\n            }\n        }).then(async (res)=>{\n            if (!res.ok) throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);\n            return realtimeSubscriptionTokenSchema.parse(await res.json()).jwt;\n        }).catch((error)=>{\n            throw new Error((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error, \"Unknown error getting subscription token\"));\n        });\n    }\n    /**\n\t* Start a new run, optionally passing in a number of steps to initialize the\n\t* run with.\n\t*/ async checkpointNewRun(args) {\n        const body = JSON.stringify({\n            run_id: args.runId,\n            event: args.event,\n            steps: args.steps\n        });\n        const result = await this.req(\"/v1/checkpoint\", {\n            method: \"POST\",\n            body\n        });\n        if (!result.ok) throw new Error((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(result.error, \"Unknown error checkpointing new run\"));\n        const res = result.value;\n        if (res.ok) {\n            const rawData = await res.json();\n            return checkpointNewRunResponseSchema.parse(rawData);\n        }\n        throw new Error(`Failed to checkpoint new run: ${res.status} ${res.statusText} - ${await res.text()}`);\n    }\n    /**\n\t* Checkpoint steps for a given run.\n\t*/ async checkpointSteps(args) {\n        const body = JSON.stringify({\n            fn_id: args.fnId,\n            app_id: args.appId,\n            run_id: args.runId,\n            steps: args.steps\n        });\n        const result = await this.req(`/v1/checkpoint/${args.runId}/steps`, {\n            method: \"POST\",\n            body\n        });\n        if (!result.ok) throw new Error((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(result.error, \"Unknown error checkpointing steps\"));\n        const res = result.value;\n        if (!res.ok) throw new Error(`Failed to checkpoint steps: ${res.status} ${res.statusText} - ${await res.text()}`);\n    }\n};\n//#endregion\n //# sourceMappingURL=api.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFzRjtBQUNoRDtBQUMrQjtBQUNkO0FBQ0E7QUFDTTtBQUNIO0FBQy9CO0FBRTNCLHdCQUF3QjtBQUN4QixNQUFNWSxrQ0FBa0NELDBDQUFRLENBQUM7SUFBRUcsS0FBS0gsMENBQVE7QUFBRztBQUNuRSxNQUFNSyxrQ0FBa0NMLDBDQUFRLENBQUM7SUFBRU0sTUFBTU4sMENBQVEsQ0FBQztRQUFFTyxRQUFRUCwwQ0FBUSxHQUFHUSxHQUFHLENBQUM7SUFBRztBQUFHO0FBQ2pHLE1BQU1DLGlDQUFpQ1QsMENBQVEsQ0FBQztJQUFFTSxNQUFNTiwwQ0FBUSxDQUFDO1FBQ2hFVSxPQUFPViwwQ0FBUSxHQUFHUSxHQUFHLENBQUM7UUFDdEJHLFFBQVFYLDBDQUFRLEdBQUdRLEdBQUcsQ0FBQztRQUN2QkQsUUFBUVAsMENBQVEsR0FBR1EsR0FBRyxDQUFDO1FBQ3ZCSSxPQUFPWiwwQ0FBUSxHQUFHUSxHQUFHLENBQUMsR0FBR0ssUUFBUTtJQUNsQztBQUFHO0FBQ0gsSUFBSUMsYUFBYTtJQU1oQkMsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsa0JBQWtCLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFLENBQUU7UUFDckUsSUFBSSxDQUFDQyxVQUFVLEdBQUdMO1FBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGtCQUFrQixHQUFHQTtRQUMxQixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDYjtJQUNBLElBQUlFLFlBQVk7UUFDZixPQUFPekIsbUVBQWNBLENBQUMsSUFBSSxDQUFDb0IsVUFBVTtJQUN0QztJQUNBLElBQUlNLG9CQUFvQjtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDTCxrQkFBa0IsRUFBRTtRQUM5QixPQUFPckIsbUVBQWNBLENBQUMsSUFBSSxDQUFDcUIsa0JBQWtCO0lBQzlDO0lBQ0FNLGNBQWNDLEdBQUcsRUFBRTtRQUNsQixJQUFJLE9BQU9BLFFBQVEsWUFBWSxJQUFJLENBQUNSLFVBQVUsS0FBSyxJQUFJLElBQUksQ0FBQ0EsVUFBVSxHQUFHUTtJQUMxRTtJQUNBQyxzQkFBc0JELEdBQUcsRUFBRTtRQUMxQixJQUFJLE9BQU9BLFFBQVEsWUFBWSxDQUFDLElBQUksQ0FBQ1Asa0JBQWtCLEVBQUUsSUFBSSxDQUFDQSxrQkFBa0IsR0FBR087SUFDcEY7SUFDQSxNQUFNRSxhQUFhQyxJQUFJLEVBQUU7UUFDeEIsSUFBSSxJQUFJLENBQUNQLFVBQVUsRUFBRSxPQUFPLElBQUlRLElBQUlELE1BQU0sSUFBSSxDQUFDUCxVQUFVO1FBQ3pELElBQUlTLE1BQU0sSUFBSUQsSUFBSUQsTUFBTXRDLHdFQUF3QkE7UUFDaEQsSUFBSSxJQUFJLENBQUM4QixJQUFJLENBQUNXLEtBQUssSUFBSSxJQUFJLENBQUNYLElBQUksQ0FBQ1ksVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDWCxVQUFVLEVBQUU7WUFDaEUsSUFBSSxNQUFNdkIseUVBQWtCQSxDQUFDVCxvRUFBb0JBLEVBQUUsSUFBSSxDQUFDOEIsS0FBSyxHQUFHVyxNQUFNLElBQUlELElBQUlELE1BQU12QyxvRUFBb0JBO1FBQ3pHO1FBQ0EsT0FBT3lDO0lBQ1I7SUFDQSxNQUFNRyxJQUFJSCxHQUFHLEVBQUVJLE9BQU8sRUFBRTtRQUN2QixNQUFNQyxXQUFXLE9BQU9MLFFBQVEsV0FBVyxNQUFNLElBQUksQ0FBQ0gsWUFBWSxDQUFDRyxPQUFPQTtRQUMxRSxJQUFJO1lBQ0gsT0FBT3RDLDZDQUFFQSxDQUFDLE1BQU1PLHNFQUFxQkEsQ0FBQztnQkFDckNxQyxXQUFXLElBQUksQ0FBQ2QsU0FBUztnQkFDekJlLG1CQUFtQixJQUFJLENBQUNkLGlCQUFpQjtnQkFDekNKLE9BQU8sSUFBSSxDQUFDQSxLQUFLO2dCQUNqQlcsS0FBS0s7Z0JBQ0xELFNBQVM7b0JBQ1IsR0FBR0EsT0FBTztvQkFDVkksU0FBUzt3QkFDUixnQkFBZ0I7d0JBQ2hCLEdBQUdKLFNBQVNJLE9BQU87b0JBQ3BCO2dCQUNEO1lBQ0Q7UUFDRCxFQUFFLE9BQU9DLE9BQU87WUFDZixPQUFPaEQsOENBQUdBLENBQUNnRDtRQUNaO0lBQ0Q7SUFDQSxNQUFNQyxZQUFZQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNqQyxNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDVixHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUVRLE1BQU0sUUFBUSxDQUFDO1FBQ3pELElBQUlFLE9BQU9uRCxFQUFFLEVBQUU7WUFDZCxNQUFNb0QsTUFBTUQsT0FBT0UsS0FBSztZQUN4QixNQUFNdkMsT0FBTyxNQUFNc0MsSUFBSUUsSUFBSTtZQUMzQixJQUFJRixJQUFJcEQsRUFBRSxFQUFFLE9BQU9BLDZDQUFFQSxDQUFDRyxvREFBWSxDQUFDK0MsUUFBUSxDQUFDSyxLQUFLLENBQUN6QztZQUNsRCxPQUFPZiw4Q0FBR0EsQ0FBQ0csbURBQVdBLENBQUNxRCxLQUFLLENBQUN6QztRQUM5QjtRQUNBLE9BQU9mLDhDQUFHQSxDQUFDO1lBQ1ZnRCxPQUFPM0MsbUVBQWVBLENBQUMrQyxPQUFPSixLQUFLLEVBQUU7WUFDckNTLFFBQVE7UUFDVDtJQUNEO0lBQ0EsTUFBTUMsWUFBWVIsS0FBSyxFQUFFO1FBQ3hCLE1BQU1FLFNBQVMsTUFBTSxJQUFJLENBQUNWLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRVEsTUFBTSxNQUFNLENBQUM7UUFDdkQsSUFBSUUsT0FBT25ELEVBQUUsRUFBRTtZQUNkLE1BQU1vRCxNQUFNRCxPQUFPRSxLQUFLO1lBQ3hCLE1BQU12QyxPQUFPLE1BQU1zQyxJQUFJRSxJQUFJO1lBQzNCLElBQUlGLElBQUlwRCxFQUFFLEVBQUUsT0FBT0EsNkNBQUVBLENBQUNDLG1EQUFXQSxDQUFDc0QsS0FBSyxDQUFDekM7WUFDeEMsT0FBT2YsOENBQUdBLENBQUNHLG1EQUFXQSxDQUFDcUQsS0FBSyxDQUFDekM7UUFDOUI7UUFDQSxPQUFPZiw4Q0FBR0EsQ0FBQztZQUNWZ0QsT0FBTzNDLG1FQUFlQSxDQUFDK0MsT0FBT0osS0FBSyxFQUFFO1lBQ3JDUyxRQUFRO1FBQ1Q7SUFDRDtJQUNBLE1BQU1FLFFBQVFDLGNBQWMsRUFBRTdDLElBQUksRUFBRTtRQUNuQyxNQUFNOEMsV0FBVzlDLGdCQUFnQitDO1FBQ2pDLE1BQU12QixNQUFNLE1BQU0sSUFBSSxDQUFDSCxZQUFZLENBQUM7UUFDcENHLElBQUl3QixZQUFZLENBQUNDLEdBQUcsQ0FBQyxXQUFXSixlQUFlSyxPQUFPLElBQUk7UUFDMUQsSUFBSUwsZUFBZVYsS0FBSyxFQUFFWCxJQUFJd0IsWUFBWSxDQUFDQyxHQUFHLENBQUMsVUFBVUosZUFBZVYsS0FBSztRQUM3RSxLQUFLLE1BQU1nQixTQUFTTixlQUFlTyxNQUFNLENBQUU1QixJQUFJd0IsWUFBWSxDQUFDSyxNQUFNLENBQUMsU0FBU0Y7UUFDNUUsTUFBTWQsU0FBUyxNQUFNLElBQUksQ0FBQ1YsR0FBRyxDQUFDSCxLQUFLO1lBQ2xDOEIsTUFBTVIsV0FBVzlDLE9BQU8sT0FBT0EsU0FBUyxXQUFXQSxPQUFPdUQsS0FBS0MsU0FBUyxDQUFDeEQ7WUFDekV5RCxRQUFRO1lBQ1J6QixTQUFTO2dCQUFFLGdCQUFnQmMsV0FBVyxnQkFBZ0I7WUFBbUI7WUFDekUsR0FBR0EsV0FBVztnQkFBRVksUUFBUTtZQUFPLElBQUksQ0FBQyxDQUFDO1FBQ3RDO1FBQ0EsSUFBSXJCLE9BQU9uRCxFQUFFLEVBQUU7WUFDZCxNQUFNb0QsTUFBTUQsT0FBT0UsS0FBSztZQUN4QixJQUFJLENBQUNELElBQUlwRCxFQUFFLEVBQUUsTUFBTSxJQUFJeUUsTUFBTSxDQUFDLHlCQUF5QixFQUFFckIsSUFBSUksTUFBTSxDQUFDLENBQUMsRUFBRUosSUFBSXNCLFVBQVUsQ0FBQyxDQUFDO1lBQ3ZGLE9BQU8xRSw2Q0FBRUEsQ0FBQyxLQUFLO1FBQ2hCO1FBQ0EsT0FBT0QsOENBQUdBLENBQUM7WUFDVmdELE9BQU8zQyxtRUFBZUEsQ0FBQytDLE9BQU9KLEtBQUssRUFBRTtZQUNyQ1MsUUFBUTtRQUNUO0lBQ0Q7SUFDQSxNQUFNbUIsV0FBV0MsYUFBYSxFQUFFbEMsT0FBTyxFQUFFO1FBQ3hDLE1BQU1KLE1BQU0sTUFBTSxJQUFJLENBQUNILFlBQVksQ0FBQztRQUNwQyxNQUFNaUMsT0FBTztZQUNaUyxRQUFRRCxjQUFjQyxNQUFNO1lBQzVCL0QsTUFBTThELGNBQWM5RCxJQUFJO1FBQ3pCO1FBQ0EsT0FBT1Asc0VBQXFCQSxDQUFDO1lBQzVCcUMsV0FBVyxJQUFJLENBQUNkLFNBQVM7WUFDekJlLG1CQUFtQixJQUFJLENBQUNkLGlCQUFpQjtZQUN6Q0osT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJXO1lBQ0FJLFNBQVM7Z0JBQ1I2QixRQUFRO2dCQUNSSCxNQUFNQyxLQUFLQyxTQUFTLENBQUNGO2dCQUNyQnRCLFNBQVM7b0JBQ1IsZ0JBQWdCO29CQUNoQixHQUFHSixTQUFTSSxPQUFPO2dCQUNwQjtZQUNEO1FBQ0QsR0FBR2dDLElBQUksQ0FBQyxPQUFPMUI7WUFDZCxJQUFJQSxJQUFJSSxNQUFNLEtBQUssS0FBSyxPQUFPeEQsNkNBQUVBLENBQUM7Z0JBQUVpRCxPQUFPLEtBQUs7WUFBRTtZQUNsRCxNQUFNOEIsV0FBVzNCLElBQUk0QixLQUFLO1lBQzFCLElBQUkxQjtZQUNKLElBQUk7Z0JBQ0hBLE9BQU8sTUFBTUYsSUFBSUUsSUFBSTtZQUN0QixFQUFFLE9BQU07Z0JBQ1AsT0FBT3ZELDhDQUFHQSxDQUFDO29CQUNWZ0QsT0FBTyxDQUFDLHVCQUF1QixFQUFFSyxJQUFJSSxNQUFNLENBQUMsQ0FBQyxFQUFFSixJQUFJc0IsVUFBVSxDQUFDLEdBQUcsRUFBRSxNQUFNSyxTQUFTRSxJQUFJLEdBQUcsQ0FBQztvQkFDMUZ6QixRQUFRSixJQUFJSSxNQUFNO2dCQUNuQjtZQUNEO1lBQ0EsSUFBSSxDQUFDSixJQUFJcEQsRUFBRSxFQUFFLElBQUk7Z0JBQ2hCLE9BQU9ELDhDQUFHQSxDQUFDRyxtREFBV0EsQ0FBQ3FELEtBQUssQ0FBQ0Q7WUFDOUIsRUFBRSxPQUFNO2dCQUNQLE9BQU92RCw4Q0FBR0EsQ0FBQztvQkFDVmdELE9BQU8sQ0FBQyx1QkFBdUIsRUFBRUssSUFBSUksTUFBTSxDQUFDLENBQUMsRUFBRUosSUFBSXNCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTXRCLElBQUk2QixJQUFJLEdBQUcsQ0FBQztvQkFDckZ6QixRQUFRSixJQUFJSSxNQUFNO2dCQUNuQjtZQUNEO1lBQ0EsTUFBTTBCLFdBQVdyRSxnQ0FBZ0NzRSxTQUFTLENBQUM3QjtZQUMzRCxJQUFJLENBQUM0QixTQUFTRSxPQUFPLEVBQUUsT0FBT3JGLDhDQUFHQSxDQUFDO2dCQUNqQ2dELE9BQU8sQ0FBQyx1REFBdUQsRUFBRUssSUFBSUksTUFBTSxDQUFDLENBQUMsRUFBRUosSUFBSXNCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTUssU0FBU0UsSUFBSSxHQUFHLENBQUM7Z0JBQzFIekIsUUFBUUosSUFBSUksTUFBTTtZQUNuQjtZQUNBLE9BQU94RCw2Q0FBRUEsQ0FBQztnQkFBRWlELE9BQU9pQyxTQUFTcEUsSUFBSSxDQUFDQSxJQUFJLENBQUNDLE1BQU07WUFBQztRQUM5QyxHQUFHc0UsS0FBSyxDQUFDLENBQUN0QztZQUNULE9BQU9oRCw4Q0FBR0EsQ0FBQztnQkFDVmdELE9BQU8zQyxtRUFBZUEsQ0FBQzJDLE9BQU87Z0JBQzlCUyxRQUFRO1lBQ1Q7UUFDRDtJQUNEO0lBQ0EsTUFBTThCLHFCQUFxQnRCLE9BQU8sRUFBRUUsTUFBTSxFQUFFO1FBQzNDLE1BQU01QixNQUFNLE1BQU0sSUFBSSxDQUFDSCxZQUFZLENBQUM7UUFDcEMsTUFBTWlDLE9BQU9GLE9BQU9xQixHQUFHLENBQUMsQ0FBQ3RCLFFBQVc7Z0JBQ25DRDtnQkFDQXdCLE1BQU12QjtnQkFDTndCLE1BQU07WUFDUDtRQUNBLE9BQU9sRixzRUFBcUJBLENBQUM7WUFDNUJxQyxXQUFXLElBQUksQ0FBQ2QsU0FBUztZQUN6QmUsbUJBQW1CLElBQUksQ0FBQ2QsaUJBQWlCO1lBQ3pDSixPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNqQlc7WUFDQUksU0FBUztnQkFDUjZCLFFBQVE7Z0JBQ1JILE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0Y7Z0JBQ3JCdEIsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO1lBQy9DO1FBQ0QsR0FBR2dDLElBQUksQ0FBQyxPQUFPMUI7WUFDZCxJQUFJLENBQUNBLElBQUlwRCxFQUFFLEVBQUUsTUFBTSxJQUFJeUUsTUFBTSxDQUFDLGtDQUFrQyxFQUFFckIsSUFBSUksTUFBTSxDQUFDLENBQUMsRUFBRUosSUFBSXNCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTXRCLElBQUk2QixJQUFJLEdBQUcsQ0FBQztZQUN0SCxPQUFPeEUsZ0NBQWdDOEMsS0FBSyxDQUFDLE1BQU1ILElBQUlFLElBQUksSUFBSTNDLEdBQUc7UUFDbkUsR0FBRzBFLEtBQUssQ0FBQyxDQUFDdEM7WUFDVCxNQUFNLElBQUkwQixNQUFNckUsbUVBQWVBLENBQUMyQyxPQUFPO1FBQ3hDO0lBQ0Q7SUFDQTs7O0NBR0EsR0FDQSxNQUFNMkMsaUJBQWlCQyxJQUFJLEVBQUU7UUFDNUIsTUFBTXZCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztZQUMzQnZELFFBQVE0RSxLQUFLMUMsS0FBSztZQUNsQjJDLE9BQU9ELEtBQUtDLEtBQUs7WUFDakJDLE9BQU9GLEtBQUtFLEtBQUs7UUFDbEI7UUFDQSxNQUFNMUMsU0FBUyxNQUFNLElBQUksQ0FBQ1YsR0FBRyxDQUFDLGtCQUFrQjtZQUMvQzhCLFFBQVE7WUFDUkg7UUFDRDtRQUNBLElBQUksQ0FBQ2pCLE9BQU9uRCxFQUFFLEVBQUUsTUFBTSxJQUFJeUUsTUFBTXJFLG1FQUFlQSxDQUFDK0MsT0FBT0osS0FBSyxFQUFFO1FBQzlELE1BQU1LLE1BQU1ELE9BQU9FLEtBQUs7UUFDeEIsSUFBSUQsSUFBSXBELEVBQUUsRUFBRTtZQUNYLE1BQU04RixVQUFVLE1BQU0xQyxJQUFJRSxJQUFJO1lBQzlCLE9BQU9yQywrQkFBK0JzQyxLQUFLLENBQUN1QztRQUM3QztRQUNBLE1BQU0sSUFBSXJCLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRXJCLElBQUlJLE1BQU0sQ0FBQyxDQUFDLEVBQUVKLElBQUlzQixVQUFVLENBQUMsR0FBRyxFQUFFLE1BQU10QixJQUFJNkIsSUFBSSxHQUFHLENBQUM7SUFDdEc7SUFDQTs7Q0FFQSxHQUNBLE1BQU1jLGdCQUFnQkosSUFBSSxFQUFFO1FBQzNCLE1BQU12QixPQUFPQyxLQUFLQyxTQUFTLENBQUM7WUFDM0JwRCxPQUFPeUUsS0FBS0ssSUFBSTtZQUNoQjdFLFFBQVF3RSxLQUFLTSxLQUFLO1lBQ2xCbEYsUUFBUTRFLEtBQUsxQyxLQUFLO1lBQ2xCNEMsT0FBT0YsS0FBS0UsS0FBSztRQUNsQjtRQUNBLE1BQU0xQyxTQUFTLE1BQU0sSUFBSSxDQUFDVixHQUFHLENBQUMsQ0FBQyxlQUFlLEVBQUVrRCxLQUFLMUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ25Fc0IsUUFBUTtZQUNSSDtRQUNEO1FBQ0EsSUFBSSxDQUFDakIsT0FBT25ELEVBQUUsRUFBRSxNQUFNLElBQUl5RSxNQUFNckUsbUVBQWVBLENBQUMrQyxPQUFPSixLQUFLLEVBQUU7UUFDOUQsTUFBTUssTUFBTUQsT0FBT0UsS0FBSztRQUN4QixJQUFJLENBQUNELElBQUlwRCxFQUFFLEVBQUUsTUFBTSxJQUFJeUUsTUFBTSxDQUFDLDRCQUE0QixFQUFFckIsSUFBSUksTUFBTSxDQUFDLENBQUMsRUFBRUosSUFBSXNCLFVBQVUsQ0FBQyxHQUFHLEVBQUUsTUFBTXRCLElBQUk2QixJQUFJLEdBQUcsQ0FBQztJQUNqSDtBQUNEO0FBRUEsWUFBWTtBQUNVLENBQ3RCLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvYXBpLmpzPzg5MjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdERldlNlcnZlckhvc3QsIGRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiO1xuaW1wb3J0IHsgZXJyLCBvayB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgYmF0Y2hTY2hlbWEsIGVycm9yU2NoZW1hLCBzdGVwc1NjaGVtYXMgfSBmcm9tIFwiLi9zY2hlbWEuanNcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSB9IGZyb20gXCIuLi9oZWxwZXJzL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgaGFzaFNpZ25pbmdLZXkgfSBmcm9tIFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCI7XG5pbXBvcnQgeyBkZXZTZXJ2ZXJBdmFpbGFibGUgfSBmcm9tIFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIjtcbmltcG9ydCB7IGZldGNoV2l0aEF1dGhGYWxsYmFjayB9IGZyb20gXCIuLi9oZWxwZXJzL25ldC5qc1wiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjNcIjtcblxuLy8jcmVnaW9uIHNyYy9hcGkvYXBpLnRzXG5jb25zdCByZWFsdGltZVN1YnNjcmlwdGlvblRva2VuU2NoZW1hID0gei5vYmplY3QoeyBqd3Q6IHouc3RyaW5nKCkgfSk7XG5jb25zdCBzZW5kU2lnbmFsU3VjY2Vzc1Jlc3BvbnNlU2NoZW1hID0gei5vYmplY3QoeyBkYXRhOiB6Lm9iamVjdCh7IHJ1bl9pZDogei5zdHJpbmcoKS5taW4oMSkgfSkgfSk7XG5jb25zdCBjaGVja3BvaW50TmV3UnVuUmVzcG9uc2VTY2hlbWEgPSB6Lm9iamVjdCh7IGRhdGE6IHoub2JqZWN0KHtcblx0Zm5faWQ6IHouc3RyaW5nKCkubWluKDEpLFxuXHRhcHBfaWQ6IHouc3RyaW5nKCkubWluKDEpLFxuXHRydW5faWQ6IHouc3RyaW5nKCkubWluKDEpLFxuXHR0b2tlbjogei5zdHJpbmcoKS5taW4oMSkub3B0aW9uYWwoKVxufSkgfSk7XG52YXIgSW5uZ2VzdEFwaSA9IGNsYXNzIHtcblx0YXBpQmFzZVVybDtcblx0c2lnbmluZ0tleTtcblx0c2lnbmluZ0tleUZhbGxiYWNrO1xuXHRmZXRjaDtcblx0bW9kZTtcblx0Y29uc3RydWN0b3IoeyBiYXNlVXJsLCBzaWduaW5nS2V5LCBzaWduaW5nS2V5RmFsbGJhY2ssIGZldGNoLCBtb2RlIH0pIHtcblx0XHR0aGlzLmFwaUJhc2VVcmwgPSBiYXNlVXJsO1xuXHRcdHRoaXMuc2lnbmluZ0tleSA9IHNpZ25pbmdLZXk7XG5cdFx0dGhpcy5zaWduaW5nS2V5RmFsbGJhY2sgPSBzaWduaW5nS2V5RmFsbGJhY2s7XG5cdFx0dGhpcy5mZXRjaCA9IGZldGNoO1xuXHRcdHRoaXMubW9kZSA9IG1vZGU7XG5cdH1cblx0Z2V0IGhhc2hlZEtleSgpIHtcblx0XHRyZXR1cm4gaGFzaFNpZ25pbmdLZXkodGhpcy5zaWduaW5nS2V5KTtcblx0fVxuXHRnZXQgaGFzaGVkRmFsbGJhY2tLZXkoKSB7XG5cdFx0aWYgKCF0aGlzLnNpZ25pbmdLZXlGYWxsYmFjaykgcmV0dXJuO1xuXHRcdHJldHVybiBoYXNoU2lnbmluZ0tleSh0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayk7XG5cdH1cblx0c2V0U2lnbmluZ0tleShrZXkpIHtcblx0XHRpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLnNpZ25pbmdLZXkgPT09IFwiXCIpIHRoaXMuc2lnbmluZ0tleSA9IGtleTtcblx0fVxuXHRzZXRTaWduaW5nS2V5RmFsbGJhY2soa2V5KSB7XG5cdFx0aWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgIXRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKSB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IGtleTtcblx0fVxuXHRhc3luYyBnZXRUYXJnZXRVcmwocGF0aCkge1xuXHRcdGlmICh0aGlzLmFwaUJhc2VVcmwpIHJldHVybiBuZXcgVVJMKHBhdGgsIHRoaXMuYXBpQmFzZVVybCk7XG5cdFx0bGV0IHVybCA9IG5ldyBVUkwocGF0aCwgZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcblx0XHRpZiAodGhpcy5tb2RlLmlzRGV2ICYmIHRoaXMubW9kZS5pc0luZmVycmVkICYmICF0aGlzLmFwaUJhc2VVcmwpIHtcblx0XHRcdGlmIChhd2FpdCBkZXZTZXJ2ZXJBdmFpbGFibGUoZGVmYXVsdERldlNlcnZlckhvc3QsIHRoaXMuZmV0Y2gpKSB1cmwgPSBuZXcgVVJMKHBhdGgsIGRlZmF1bHREZXZTZXJ2ZXJIb3N0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHVybDtcblx0fVxuXHRhc3luYyByZXEodXJsLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgZmluYWxVcmwgPSB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiID8gYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwodXJsKSA6IHVybDtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIG9rKGF3YWl0IGZldGNoV2l0aEF1dGhGYWxsYmFjayh7XG5cdFx0XHRcdGF1dGhUb2tlbjogdGhpcy5oYXNoZWRLZXksXG5cdFx0XHRcdGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZEZhbGxiYWNrS2V5LFxuXHRcdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdFx0dXJsOiBmaW5hbFVybCxcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0XHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdFx0XHRcdFx0XHQuLi5vcHRpb25zPy5oZWFkZXJzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHJldHVybiBlcnIoZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRhc3luYyBnZXRSdW5TdGVwcyhydW5JZCwgdmVyc2lvbikge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVxKGAvdjAvcnVucy8ke3J1bklkfS9hY3Rpb25zYCk7XG5cdFx0aWYgKHJlc3VsdC5vaykge1xuXHRcdFx0Y29uc3QgcmVzID0gcmVzdWx0LnZhbHVlO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRpZiAocmVzLm9rKSByZXR1cm4gb2soc3RlcHNTY2hlbWFzW3ZlcnNpb25dLnBhcnNlKGRhdGEpKTtcblx0XHRcdHJldHVybiBlcnIoZXJyb3JTY2hlbWEucGFyc2UoZGF0YSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gZXJyKHtcblx0XHRcdGVycm9yOiBnZXRFcnJvck1lc3NhZ2UocmVzdWx0LmVycm9yLCBcIlVua25vd24gZXJyb3IgcmV0cmlldmluZyBzdGVwIGRhdGFcIiksXG5cdFx0XHRzdGF0dXM6IDUwMFxuXHRcdH0pO1xuXHR9XG5cdGFzeW5jIGdldFJ1bkJhdGNoKHJ1bklkKSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXEoYC92MC9ydW5zLyR7cnVuSWR9L2JhdGNoYCk7XG5cdFx0aWYgKHJlc3VsdC5vaykge1xuXHRcdFx0Y29uc3QgcmVzID0gcmVzdWx0LnZhbHVlO1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRpZiAocmVzLm9rKSByZXR1cm4gb2soYmF0Y2hTY2hlbWEucGFyc2UoZGF0YSkpO1xuXHRcdFx0cmV0dXJuIGVycihlcnJvclNjaGVtYS5wYXJzZShkYXRhKSk7XG5cdFx0fVxuXHRcdHJldHVybiBlcnIoe1xuXHRcdFx0ZXJyb3I6IGdldEVycm9yTWVzc2FnZShyZXN1bHQuZXJyb3IsIFwiVW5rbm93biBlcnJvciByZXRyaWV2aW5nIGV2ZW50IGJhdGNoXCIpLFxuXHRcdFx0c3RhdHVzOiA1MDBcblx0XHR9KTtcblx0fVxuXHRhc3luYyBwdWJsaXNoKHB1Ymxpc2hPcHRpb25zLCBkYXRhKSB7XG5cdFx0Y29uc3QgaXNTdHJlYW0gPSBkYXRhIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG5cdFx0Y29uc3QgdXJsID0gYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwoXCIvdjEvcmVhbHRpbWUvcHVibGlzaFwiKTtcblx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldChcImNoYW5uZWxcIiwgcHVibGlzaE9wdGlvbnMuY2hhbm5lbCB8fCBcIlwiKTtcblx0XHRpZiAocHVibGlzaE9wdGlvbnMucnVuSWQpIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicnVuX2lkXCIsIHB1Ymxpc2hPcHRpb25zLnJ1bklkKTtcblx0XHRmb3IgKGNvbnN0IHRvcGljIG9mIHB1Ymxpc2hPcHRpb25zLnRvcGljcykgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJ0b3BpY1wiLCB0b3BpYyk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXEodXJsLCB7XG5cdFx0XHRib2R5OiBpc1N0cmVhbSA/IGRhdGEgOiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSxcblx0XHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IGlzU3RyZWFtID8gXCJ0ZXh0L3N0cmVhbVwiIDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHRcdC4uLmlzU3RyZWFtID8geyBkdXBsZXg6IFwiaGFsZlwiIH0gOiB7fVxuXHRcdH0pO1xuXHRcdGlmIChyZXN1bHQub2spIHtcblx0XHRcdGNvbnN0IHJlcyA9IHJlc3VsdC52YWx1ZTtcblx0XHRcdGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50OiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9YCk7XG5cdFx0XHRyZXR1cm4gb2sodm9pZCAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVycih7XG5cdFx0XHRlcnJvcjogZ2V0RXJyb3JNZXNzYWdlKHJlc3VsdC5lcnJvciwgXCJVbmtub3duIGVycm9yIHB1Ymxpc2hpbmcgZXZlbnRcIiksXG5cdFx0XHRzdGF0dXM6IDUwMFxuXHRcdH0pO1xuXHR9XG5cdGFzeW5jIHNlbmRTaWduYWwoc2lnbmFsT3B0aW9ucywgb3B0aW9ucykge1xuXHRcdGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0VGFyZ2V0VXJsKFwiL3YxL3NpZ25hbHNcIik7XG5cdFx0Y29uc3QgYm9keSA9IHtcblx0XHRcdHNpZ25hbDogc2lnbmFsT3B0aW9ucy5zaWduYWwsXG5cdFx0XHRkYXRhOiBzaWduYWxPcHRpb25zLmRhdGFcblx0XHR9O1xuXHRcdHJldHVybiBmZXRjaFdpdGhBdXRoRmFsbGJhY2soe1xuXHRcdFx0YXV0aFRva2VuOiB0aGlzLmhhc2hlZEtleSxcblx0XHRcdGF1dGhUb2tlbkZhbGxiYWNrOiB0aGlzLmhhc2hlZEZhbGxiYWNrS2V5LFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2gsXG5cdFx0XHR1cmwsXG5cdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuXHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdFx0XHRcdFx0Li4ub3B0aW9ucz8uaGVhZGVyc1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSkudGhlbihhc3luYyAocmVzKSA9PiB7XG5cdFx0XHRpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSByZXR1cm4gb2soeyBydW5JZDogdm9pZCAwIH0pO1xuXHRcdFx0Y29uc3QgcmVzQ2xvbmUgPSByZXMuY2xvbmUoKTtcblx0XHRcdGxldCBqc29uO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0cmV0dXJuIGVycih7XG5cdFx0XHRcdFx0ZXJyb3I6IGBGYWlsZWQgdG8gc2VuZCBzaWduYWw6ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlc0Nsb25lLnRleHQoKX1gLFxuXHRcdFx0XHRcdHN0YXR1czogcmVzLnN0YXR1c1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGlmICghcmVzLm9rKSB0cnkge1xuXHRcdFx0XHRyZXR1cm4gZXJyKGVycm9yU2NoZW1hLnBhcnNlKGpzb24pKTtcblx0XHRcdH0gY2F0Y2gge1xuXHRcdFx0XHRyZXR1cm4gZXJyKHtcblx0XHRcdFx0XHRlcnJvcjogYEZhaWxlZCB0byBzZW5kIHNpZ25hbDogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtICR7YXdhaXQgcmVzLnRleHQoKX1gLFxuXHRcdFx0XHRcdHN0YXR1czogcmVzLnN0YXR1c1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHBhcnNlUmVzID0gc2VuZFNpZ25hbFN1Y2Nlc3NSZXNwb25zZVNjaGVtYS5zYWZlUGFyc2UoanNvbik7XG5cdFx0XHRpZiAoIXBhcnNlUmVzLnN1Y2Nlc3MpIHJldHVybiBlcnIoe1xuXHRcdFx0XHRlcnJvcjogYFN1Y2Nlc3NmdWxseSBzZW50IHNpZ25hbCwgYnV0IHJlc3BvbnNlIHBhcnNpbmcgZmFpbGVkOiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IC0gJHthd2FpdCByZXNDbG9uZS50ZXh0KCl9YCxcblx0XHRcdFx0c3RhdHVzOiByZXMuc3RhdHVzXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBvayh7IHJ1bklkOiBwYXJzZVJlcy5kYXRhLmRhdGEucnVuX2lkIH0pO1xuXHRcdH0pLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0cmV0dXJuIGVycih7XG5cdFx0XHRcdGVycm9yOiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IsIFwiVW5rbm93biBlcnJvciBzZW5kaW5nIHNpZ25hbFwiKSxcblx0XHRcdFx0c3RhdHVzOiA1MDBcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cdGFzeW5jIGdldFN1YnNjcmlwdGlvblRva2VuKGNoYW5uZWwsIHRvcGljcykge1xuXHRcdGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0VGFyZ2V0VXJsKFwiL3YxL3JlYWx0aW1lL3Rva2VuXCIpO1xuXHRcdGNvbnN0IGJvZHkgPSB0b3BpY3MubWFwKCh0b3BpYykgPT4gKHtcblx0XHRcdGNoYW5uZWwsXG5cdFx0XHRuYW1lOiB0b3BpYyxcblx0XHRcdGtpbmQ6IFwicnVuXCJcblx0XHR9KSk7XG5cdFx0cmV0dXJuIGZldGNoV2l0aEF1dGhGYWxsYmFjayh7XG5cdFx0XHRhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuXHRcdFx0YXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdHVybCxcblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0bWV0aG9kOiBcIlBPU1RcIixcblx0XHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG5cdFx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuXHRcdFx0fVxuXHRcdH0pLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuXHRcdFx0aWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBzdWJzY3JpcHRpb24gdG9rZW46ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlcy50ZXh0KCl9YCk7XG5cdFx0XHRyZXR1cm4gcmVhbHRpbWVTdWJzY3JpcHRpb25Ub2tlblNjaGVtYS5wYXJzZShhd2FpdCByZXMuanNvbigpKS5qd3Q7XG5cdFx0fSkuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKGVycm9yLCBcIlVua25vd24gZXJyb3IgZ2V0dGluZyBzdWJzY3JpcHRpb24gdG9rZW5cIikpO1xuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFN0YXJ0IGEgbmV3IHJ1biwgb3B0aW9uYWxseSBwYXNzaW5nIGluIGEgbnVtYmVyIG9mIHN0ZXBzIHRvIGluaXRpYWxpemUgdGhlXG5cdCogcnVuIHdpdGguXG5cdCovXG5cdGFzeW5jIGNoZWNrcG9pbnROZXdSdW4oYXJncykge1xuXHRcdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRydW5faWQ6IGFyZ3MucnVuSWQsXG5cdFx0XHRldmVudDogYXJncy5ldmVudCxcblx0XHRcdHN0ZXBzOiBhcmdzLnN0ZXBzXG5cdFx0fSk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXEoXCIvdjEvY2hlY2twb2ludFwiLCB7XG5cdFx0XHRtZXRob2Q6IFwiUE9TVFwiLFxuXHRcdFx0Ym9keVxuXHRcdH0pO1xuXHRcdGlmICghcmVzdWx0Lm9rKSB0aHJvdyBuZXcgRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKHJlc3VsdC5lcnJvciwgXCJVbmtub3duIGVycm9yIGNoZWNrcG9pbnRpbmcgbmV3IHJ1blwiKSk7XG5cdFx0Y29uc3QgcmVzID0gcmVzdWx0LnZhbHVlO1xuXHRcdGlmIChyZXMub2spIHtcblx0XHRcdGNvbnN0IHJhd0RhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuXHRcdFx0cmV0dXJuIGNoZWNrcG9pbnROZXdSdW5SZXNwb25zZVNjaGVtYS5wYXJzZShyYXdEYXRhKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY2hlY2twb2ludCBuZXcgcnVuOiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IC0gJHthd2FpdCByZXMudGV4dCgpfWApO1xuXHR9XG5cdC8qKlxuXHQqIENoZWNrcG9pbnQgc3RlcHMgZm9yIGEgZ2l2ZW4gcnVuLlxuXHQqL1xuXHRhc3luYyBjaGVja3BvaW50U3RlcHMoYXJncykge1xuXHRcdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRmbl9pZDogYXJncy5mbklkLFxuXHRcdFx0YXBwX2lkOiBhcmdzLmFwcElkLFxuXHRcdFx0cnVuX2lkOiBhcmdzLnJ1bklkLFxuXHRcdFx0c3RlcHM6IGFyZ3Muc3RlcHNcblx0XHR9KTtcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcShgL3YxL2NoZWNrcG9pbnQvJHthcmdzLnJ1bklkfS9zdGVwc2AsIHtcblx0XHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0XHRib2R5XG5cdFx0fSk7XG5cdFx0aWYgKCFyZXN1bHQub2spIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1lc3NhZ2UocmVzdWx0LmVycm9yLCBcIlVua25vd24gZXJyb3IgY2hlY2twb2ludGluZyBzdGVwc1wiKSk7XG5cdFx0Y29uc3QgcmVzID0gcmVzdWx0LnZhbHVlO1xuXHRcdGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjaGVja3BvaW50IHN0ZXBzOiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IC0gJHthd2FpdCByZXMudGV4dCgpfWApO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IElubmdlc3RBcGkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOlsiZGVmYXVsdERldlNlcnZlckhvc3QiLCJkZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwiLCJlcnIiLCJvayIsImJhdGNoU2NoZW1hIiwiZXJyb3JTY2hlbWEiLCJzdGVwc1NjaGVtYXMiLCJnZXRFcnJvck1lc3NhZ2UiLCJoYXNoU2lnbmluZ0tleSIsImRldlNlcnZlckF2YWlsYWJsZSIsImZldGNoV2l0aEF1dGhGYWxsYmFjayIsInoiLCJyZWFsdGltZVN1YnNjcmlwdGlvblRva2VuU2NoZW1hIiwib2JqZWN0Iiwiand0Iiwic3RyaW5nIiwic2VuZFNpZ25hbFN1Y2Nlc3NSZXNwb25zZVNjaGVtYSIsImRhdGEiLCJydW5faWQiLCJtaW4iLCJjaGVja3BvaW50TmV3UnVuUmVzcG9uc2VTY2hlbWEiLCJmbl9pZCIsImFwcF9pZCIsInRva2VuIiwib3B0aW9uYWwiLCJJbm5nZXN0QXBpIiwiY29uc3RydWN0b3IiLCJiYXNlVXJsIiwic2lnbmluZ0tleSIsInNpZ25pbmdLZXlGYWxsYmFjayIsImZldGNoIiwibW9kZSIsImFwaUJhc2VVcmwiLCJoYXNoZWRLZXkiLCJoYXNoZWRGYWxsYmFja0tleSIsInNldFNpZ25pbmdLZXkiLCJrZXkiLCJzZXRTaWduaW5nS2V5RmFsbGJhY2siLCJnZXRUYXJnZXRVcmwiLCJwYXRoIiwiVVJMIiwidXJsIiwiaXNEZXYiLCJpc0luZmVycmVkIiwicmVxIiwib3B0aW9ucyIsImZpbmFsVXJsIiwiYXV0aFRva2VuIiwiYXV0aFRva2VuRmFsbGJhY2siLCJoZWFkZXJzIiwiZXJyb3IiLCJnZXRSdW5TdGVwcyIsInJ1bklkIiwidmVyc2lvbiIsInJlc3VsdCIsInJlcyIsInZhbHVlIiwianNvbiIsInBhcnNlIiwic3RhdHVzIiwiZ2V0UnVuQmF0Y2giLCJwdWJsaXNoIiwicHVibGlzaE9wdGlvbnMiLCJpc1N0cmVhbSIsIlJlYWRhYmxlU3RyZWFtIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiY2hhbm5lbCIsInRvcGljIiwidG9waWNzIiwiYXBwZW5kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXRob2QiLCJkdXBsZXgiLCJFcnJvciIsInN0YXR1c1RleHQiLCJzZW5kU2lnbmFsIiwic2lnbmFsT3B0aW9ucyIsInNpZ25hbCIsInRoZW4iLCJyZXNDbG9uZSIsImNsb25lIiwidGV4dCIsInBhcnNlUmVzIiwic2FmZVBhcnNlIiwic3VjY2VzcyIsImNhdGNoIiwiZ2V0U3Vic2NyaXB0aW9uVG9rZW4iLCJtYXAiLCJuYW1lIiwia2luZCIsImNoZWNrcG9pbnROZXdSdW4iLCJhcmdzIiwiZXZlbnQiLCJzdGVwcyIsInJhd0RhdGEiLCJjaGVja3BvaW50U3RlcHMiLCJmbklkIiwiYXBwSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/api/schema.js":
/*!********************************************!*\
  !*** ./node_modules/inngest/api/schema.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchSchema: () => (/* binding */ batchSchema),\n/* harmony export */   errorSchema: () => (/* binding */ errorSchema),\n/* harmony export */   stepsSchemas: () => (/* binding */ stepsSchemas)\n/* harmony export */ });\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n\n\n\n//#region src/api/schema.ts\nconst errorSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    error: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string(),\n    status: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number()\n});\nconst v0StepSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any().refine((v)=>typeof v !== \"undefined\", {\n    message: \"Values in steps must be defined\"\n})).optional().nullable();\nconst v1StepSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    type: zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(\"data\").optional().default(\"data\"),\n    data: zod_v3__WEBPACK_IMPORTED_MODULE_0__.any().refine((v)=>typeof v !== \"undefined\", {\n        message: \"Data in steps must be defined\"\n    })\n}).strict().or(zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    type: zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(\"error\").optional().default(\"error\"),\n    error: _types_js__WEBPACK_IMPORTED_MODULE_1__.jsonErrorSchema\n}).strict()).or(zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    type: zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(\"input\").optional().default(\"input\"),\n    input: zod_v3__WEBPACK_IMPORTED_MODULE_0__.any().refine((v)=>typeof v !== \"undefined\", {\n        message: \"If input is present it must not be `undefined`\"\n    })\n}).strict()).or(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any().transform((v)=>({\n        type: \"data\",\n        data: v\n    })))).default({});\nconst v2StepSchema = v1StepSchema;\nconst stepsSchemas = {\n    [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V0]: v0StepSchema,\n    [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V1]: v1StepSchema,\n    [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V2]: v2StepSchema\n};\nconst batchSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any()).transform((v)=>v));\n//#endregion\n //# sourceMappingURL=schema.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3RDtBQUNWO0FBQ25CO0FBRTNCLDJCQUEyQjtBQUMzQixNQUFNRyxjQUFjRCwwQ0FBUSxDQUFDO0lBQzVCRyxPQUFPSCwwQ0FBUTtJQUNmSyxRQUFRTCwwQ0FBUTtBQUNqQjtBQUNBLE1BQU1PLGVBQWVQLDBDQUFRLENBQUNBLHVDQUFLLEdBQUdVLE1BQU0sQ0FBQyxDQUFDQyxJQUFNLE9BQU9BLE1BQU0sYUFBYTtJQUFFQyxTQUFTO0FBQWtDLElBQUlDLFFBQVEsR0FBR0MsUUFBUTtBQUNsSixNQUFNQyxlQUFlZiwwQ0FBUSxDQUFDQSwwQ0FBUSxDQUFDO0lBQ3RDZ0IsTUFBTWhCLDJDQUFTLENBQUMsUUFBUWEsUUFBUSxHQUFHSyxPQUFPLENBQUM7SUFDM0NDLE1BQU1uQix1Q0FBSyxHQUFHVSxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxPQUFPQSxNQUFNLGFBQWE7UUFBRUMsU0FBUztJQUFnQztBQUNsRyxHQUFHUSxNQUFNLEdBQUdDLEVBQUUsQ0FBQ3JCLDBDQUFRLENBQUM7SUFDdkJnQixNQUFNaEIsMkNBQVMsQ0FBQyxTQUFTYSxRQUFRLEdBQUdLLE9BQU8sQ0FBQztJQUM1Q2YsT0FBT0osc0RBQWVBO0FBQ3ZCLEdBQUdxQixNQUFNLElBQUlDLEVBQUUsQ0FBQ3JCLDBDQUFRLENBQUM7SUFDeEJnQixNQUFNaEIsMkNBQVMsQ0FBQyxTQUFTYSxRQUFRLEdBQUdLLE9BQU8sQ0FBQztJQUM1Q0ksT0FBT3RCLHVDQUFLLEdBQUdVLE1BQU0sQ0FBQyxDQUFDQyxJQUFNLE9BQU9BLE1BQU0sYUFBYTtRQUFFQyxTQUFTO0lBQWlEO0FBQ3BILEdBQUdRLE1BQU0sSUFBSUMsRUFBRSxDQUFDckIsdUNBQUssR0FBR3VCLFNBQVMsQ0FBQyxDQUFDWixJQUFPO1FBQ3pDSyxNQUFNO1FBQ05HLE1BQU1SO0lBQ1AsTUFBTU8sT0FBTyxDQUFDLENBQUM7QUFDZixNQUFNTSxlQUFlVDtBQUNyQixNQUFNVSxlQUFlO0lBQ3BCLENBQUMzQixnRUFBZ0JBLENBQUM0QixFQUFFLENBQUMsRUFBRW5CO0lBQ3ZCLENBQUNULGdFQUFnQkEsQ0FBQzZCLEVBQUUsQ0FBQyxFQUFFWjtJQUN2QixDQUFDakIsZ0VBQWdCQSxDQUFDOEIsRUFBRSxDQUFDLEVBQUVKO0FBQ3hCO0FBQ0EsTUFBTUssY0FBYzdCLHlDQUFPLENBQUNBLDBDQUFRLENBQUNBLHVDQUFLLElBQUl1QixTQUFTLENBQUMsQ0FBQ1osSUFBTUE7QUFFL0QsWUFBWTtBQUNzQyxDQUNsRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvYXBpL3NjaGVtYS5qcz9hNzUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4ZWN1dGlvblZlcnNpb24gfSBmcm9tIFwiLi4vaGVscGVycy9jb25zdHMuanNcIjtcbmltcG9ydCB7IGpzb25FcnJvclNjaGVtYSB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjNcIjtcblxuLy8jcmVnaW9uIHNyYy9hcGkvc2NoZW1hLnRzXG5jb25zdCBlcnJvclNjaGVtYSA9IHoub2JqZWN0KHtcblx0ZXJyb3I6IHouc3RyaW5nKCksXG5cdHN0YXR1czogei5udW1iZXIoKVxufSk7XG5jb25zdCB2MFN0ZXBTY2hlbWEgPSB6LnJlY29yZCh6LmFueSgpLnJlZmluZSgodikgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCIsIHsgbWVzc2FnZTogXCJWYWx1ZXMgaW4gc3RlcHMgbXVzdCBiZSBkZWZpbmVkXCIgfSkpLm9wdGlvbmFsKCkubnVsbGFibGUoKTtcbmNvbnN0IHYxU3RlcFNjaGVtYSA9IHoucmVjb3JkKHoub2JqZWN0KHtcblx0dHlwZTogei5saXRlcmFsKFwiZGF0YVwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJkYXRhXCIpLFxuXHRkYXRhOiB6LmFueSgpLnJlZmluZSgodikgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCIsIHsgbWVzc2FnZTogXCJEYXRhIGluIHN0ZXBzIG11c3QgYmUgZGVmaW5lZFwiIH0pXG59KS5zdHJpY3QoKS5vcih6Lm9iamVjdCh7XG5cdHR5cGU6IHoubGl0ZXJhbChcImVycm9yXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImVycm9yXCIpLFxuXHRlcnJvcjoganNvbkVycm9yU2NoZW1hXG59KS5zdHJpY3QoKSkub3Ioei5vYmplY3Qoe1xuXHR0eXBlOiB6LmxpdGVyYWwoXCJpbnB1dFwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJpbnB1dFwiKSxcblx0aW5wdXQ6IHouYW55KCkucmVmaW5lKCh2KSA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIiwgeyBtZXNzYWdlOiBcIklmIGlucHV0IGlzIHByZXNlbnQgaXQgbXVzdCBub3QgYmUgYHVuZGVmaW5lZGBcIiB9KVxufSkuc3RyaWN0KCkpLm9yKHouYW55KCkudHJhbnNmb3JtKCh2KSA9PiAoe1xuXHR0eXBlOiBcImRhdGFcIixcblx0ZGF0YTogdlxufSkpKSkuZGVmYXVsdCh7fSk7XG5jb25zdCB2MlN0ZXBTY2hlbWEgPSB2MVN0ZXBTY2hlbWE7XG5jb25zdCBzdGVwc1NjaGVtYXMgPSB7XG5cdFtFeGVjdXRpb25WZXJzaW9uLlYwXTogdjBTdGVwU2NoZW1hLFxuXHRbRXhlY3V0aW9uVmVyc2lvbi5WMV06IHYxU3RlcFNjaGVtYSxcblx0W0V4ZWN1dGlvblZlcnNpb24uVjJdOiB2MlN0ZXBTY2hlbWFcbn07XG5jb25zdCBiYXRjaFNjaGVtYSA9IHouYXJyYXkoei5yZWNvcmQoei5hbnkoKSkudHJhbnNmb3JtKCh2KSA9PiB2KSk7XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgYmF0Y2hTY2hlbWEsIGVycm9yU2NoZW1hLCBzdGVwc1NjaGVtYXMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVtYS5qcy5tYXAiXSwibmFtZXMiOlsiRXhlY3V0aW9uVmVyc2lvbiIsImpzb25FcnJvclNjaGVtYSIsInoiLCJlcnJvclNjaGVtYSIsIm9iamVjdCIsImVycm9yIiwic3RyaW5nIiwic3RhdHVzIiwibnVtYmVyIiwidjBTdGVwU2NoZW1hIiwicmVjb3JkIiwiYW55IiwicmVmaW5lIiwidiIsIm1lc3NhZ2UiLCJvcHRpb25hbCIsIm51bGxhYmxlIiwidjFTdGVwU2NoZW1hIiwidHlwZSIsImxpdGVyYWwiLCJkZWZhdWx0IiwiZGF0YSIsInN0cmljdCIsIm9yIiwiaW5wdXQiLCJ0cmFuc2Zvcm0iLCJ2MlN0ZXBTY2hlbWEiLCJzdGVwc1NjaGVtYXMiLCJWMCIsIlYxIiwiVjIiLCJiYXRjaFNjaGVtYSIsImFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/components/Fetch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n/* harmony import */ var _execution_als_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\n/* harmony import */ var _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n\n\n\n//#region src/components/Fetch.ts\nconst globalFetch = globalThis.fetch;\nconst debug$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"inngest:fetch\");\nconst createFetchShim = ()=>{\n    let stepFetch;\n    const fetch$1 = async (input, init)=>{\n        const ctx = await (0,_execution_als_js__WEBPACK_IMPORTED_MODULE_1__.getAsyncCtx)();\n        if (!ctx?.execution) {\n            if (!stepFetch.fallback) throw new Error(\"step.fetch() called outside of a function and had no fallback set\");\n            debug$1(\"step.fetch() called outside of a function; falling back to global fetch\");\n            return stepFetch.fallback(input, init);\n        }\n        if (ctx.execution.executingStep) {\n            if (!stepFetch.fallback) throw new Error(`step.fetch() called inside step \"${ctx.execution.executingStep.id}\" and had no fallback set`);\n            debug$1(`step.fetch() called inside step \"${ctx.execution.executingStep.id}\"; falling back to global fetch`);\n            return stepFetch.fallback(input, init);\n        }\n        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());\n        debug$1(\"step.fetch() shimming request to\", targetUrl.hostname);\n        const jsonRes = await ctx.execution.ctx.step[_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_2__.gatewaySymbol](`step.fetch: ${targetUrl.hostname}`, input, init);\n        return new Response(jsonRes.body, {\n            headers: jsonRes.headers,\n            status: jsonRes.status\n        });\n    };\n    const optionsRef = {\n        fallback: globalFetch\n    };\n    const extras = {\n        config: (options)=>{\n            Object.assign(optionsRef, options);\n            Object.assign(stepFetch, optionsRef);\n            return stepFetch;\n        },\n        ...optionsRef\n    };\n    stepFetch = Object.assign(fetch$1, extras);\n    return stepFetch;\n};\n/**\n* `fetch` is a Fetch API-compatible function that can be used to make any HTTP\n* code durable if it's called within an Inngest function.\n*\n* It will gracefully fall back to the global `fetch` if called outside of this\n* context, and a custom fallback can be set using the `config` method.\n*\n* @example Basic usage\n* ```ts\n* import { fetch } from \"inngest\";\n*\n* const api = new MyProductApi({ fetch });\n* ```\n*\n* @example Setting a custom fallback\n* ```ts\n* import { fetch } from \"inngest\";\n*\n* const api = new MyProductApi({\n*            fetch: fetch.config({ fallback: myCustomFetch }),\n* });\n* ```\n*\n* @example Do not allow fallback\n* ```ts\n* import { fetch } from \"inngest\";\n*\n* const api = new MyProductApi({\n*            fetch: fetch.config({ fallback: undefined }),\n* });\n* ```\n*/ const fetch = createFetchShim();\n//#endregion\n //# sourceMappingURL=Fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDSztBQUM1QjtBQUUxQixpQ0FBaUM7QUFDakMsTUFBTUcsY0FBY0MsV0FBV0MsS0FBSztBQUNwQyxNQUFNQyxVQUFVSixrQ0FBS0EsQ0FBQztBQUN0QixNQUFNSyxrQkFBa0I7SUFDdkIsSUFBSUM7SUFDSixNQUFNQyxVQUFVLE9BQU9DLE9BQU9DO1FBQzdCLE1BQU1DLE1BQU0sTUFBTVosOERBQVdBO1FBQzdCLElBQUksQ0FBQ1ksS0FBS0MsV0FBVztZQUNwQixJQUFJLENBQUNMLFVBQVVNLFFBQVEsRUFBRSxNQUFNLElBQUlDLE1BQU07WUFDekNULFFBQVE7WUFDUixPQUFPRSxVQUFVTSxRQUFRLENBQUNKLE9BQU9DO1FBQ2xDO1FBQ0EsSUFBSUMsSUFBSUMsU0FBUyxDQUFDRyxhQUFhLEVBQUU7WUFDaEMsSUFBSSxDQUFDUixVQUFVTSxRQUFRLEVBQUUsTUFBTSxJQUFJQyxNQUFNLENBQUMsaUNBQWlDLEVBQUVILElBQUlDLFNBQVMsQ0FBQ0csYUFBYSxDQUFDQyxFQUFFLENBQUMseUJBQXlCLENBQUM7WUFDdElYLFFBQVEsQ0FBQyxpQ0FBaUMsRUFBRU0sSUFBSUMsU0FBUyxDQUFDRyxhQUFhLENBQUNDLEVBQUUsQ0FBQywrQkFBK0IsQ0FBQztZQUMzRyxPQUFPVCxVQUFVTSxRQUFRLENBQUNKLE9BQU9DO1FBQ2xDO1FBQ0EsTUFBTU8sWUFBWSxJQUFJQyxJQUFJVCxpQkFBaUJVLFVBQVVWLE1BQU1XLEdBQUcsR0FBR1gsTUFBTVksUUFBUTtRQUMvRWhCLFFBQVEsb0NBQW9DWSxVQUFVSyxRQUFRO1FBQzlELE1BQU1DLFVBQVUsTUFBTVosSUFBSUMsU0FBUyxDQUFDRCxHQUFHLENBQUNhLElBQUksQ0FBQ3hCLCtEQUFhQSxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUVpQixVQUFVSyxRQUFRLENBQUMsQ0FBQyxFQUFFYixPQUFPQztRQUN4RyxPQUFPLElBQUllLFNBQVNGLFFBQVFHLElBQUksRUFBRTtZQUNqQ0MsU0FBU0osUUFBUUksT0FBTztZQUN4QkMsUUFBUUwsUUFBUUssTUFBTTtRQUN2QjtJQUNEO0lBQ0EsTUFBTUMsYUFBYTtRQUFFaEIsVUFBVVg7SUFBWTtJQUMzQyxNQUFNNEIsU0FBUztRQUNkQyxRQUFRLENBQUNDO1lBQ1JDLE9BQU9DLE1BQU0sQ0FBQ0wsWUFBWUc7WUFDMUJDLE9BQU9DLE1BQU0sQ0FBQzNCLFdBQVdzQjtZQUN6QixPQUFPdEI7UUFDUjtRQUNBLEdBQUdzQixVQUFVO0lBQ2Q7SUFDQXRCLFlBQVkwQixPQUFPQyxNQUFNLENBQUMxQixTQUFTc0I7SUFDbkMsT0FBT3ZCO0FBQ1I7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQSxHQUNBLE1BQU1ILFFBQVFFO0FBRWQsWUFBWTtBQUNLLENBQ2pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0ZldGNoLmpzPzAyYjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QXN5bmNDdHggfSBmcm9tIFwiLi9leGVjdXRpb24vYWxzLmpzXCI7XG5pbXBvcnQgeyBnYXRld2F5U3ltYm9sIH0gZnJvbSBcIi4vSW5uZ2VzdFN0ZXBUb29scy5qc1wiO1xuaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuXG4vLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvRmV0Y2gudHNcbmNvbnN0IGdsb2JhbEZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaDtcbmNvbnN0IGRlYnVnJDEgPSBkZWJ1ZyhcImlubmdlc3Q6ZmV0Y2hcIik7XG5jb25zdCBjcmVhdGVGZXRjaFNoaW0gPSAoKSA9PiB7XG5cdGxldCBzdGVwRmV0Y2g7XG5cdGNvbnN0IGZldGNoJDEgPSBhc3luYyAoaW5wdXQsIGluaXQpID0+IHtcblx0XHRjb25zdCBjdHggPSBhd2FpdCBnZXRBc3luY0N0eCgpO1xuXHRcdGlmICghY3R4Py5leGVjdXRpb24pIHtcblx0XHRcdGlmICghc3RlcEZldGNoLmZhbGxiYWNrKSB0aHJvdyBuZXcgRXJyb3IoXCJzdGVwLmZldGNoKCkgY2FsbGVkIG91dHNpZGUgb2YgYSBmdW5jdGlvbiBhbmQgaGFkIG5vIGZhbGxiYWNrIHNldFwiKTtcblx0XHRcdGRlYnVnJDEoXCJzdGVwLmZldGNoKCkgY2FsbGVkIG91dHNpZGUgb2YgYSBmdW5jdGlvbjsgZmFsbGluZyBiYWNrIHRvIGdsb2JhbCBmZXRjaFwiKTtcblx0XHRcdHJldHVybiBzdGVwRmV0Y2guZmFsbGJhY2soaW5wdXQsIGluaXQpO1xuXHRcdH1cblx0XHRpZiAoY3R4LmV4ZWN1dGlvbi5leGVjdXRpbmdTdGVwKSB7XG5cdFx0XHRpZiAoIXN0ZXBGZXRjaC5mYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKGBzdGVwLmZldGNoKCkgY2FsbGVkIGluc2lkZSBzdGVwIFwiJHtjdHguZXhlY3V0aW9uLmV4ZWN1dGluZ1N0ZXAuaWR9XCIgYW5kIGhhZCBubyBmYWxsYmFjayBzZXRgKTtcblx0XHRcdGRlYnVnJDEoYHN0ZXAuZmV0Y2goKSBjYWxsZWQgaW5zaWRlIHN0ZXAgXCIke2N0eC5leGVjdXRpb24uZXhlY3V0aW5nU3RlcC5pZH1cIjsgZmFsbGluZyBiYWNrIHRvIGdsb2JhbCBmZXRjaGApO1xuXHRcdFx0cmV0dXJuIHN0ZXBGZXRjaC5mYWxsYmFjayhpbnB1dCwgaW5pdCk7XG5cdFx0fVxuXHRcdGNvbnN0IHRhcmdldFVybCA9IG5ldyBVUkwoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXQudXJsIDogaW5wdXQudG9TdHJpbmcoKSk7XG5cdFx0ZGVidWckMShcInN0ZXAuZmV0Y2goKSBzaGltbWluZyByZXF1ZXN0IHRvXCIsIHRhcmdldFVybC5ob3N0bmFtZSk7XG5cdFx0Y29uc3QganNvblJlcyA9IGF3YWl0IGN0eC5leGVjdXRpb24uY3R4LnN0ZXBbZ2F0ZXdheVN5bWJvbF0oYHN0ZXAuZmV0Y2g6ICR7dGFyZ2V0VXJsLmhvc3RuYW1lfWAsIGlucHV0LCBpbml0KTtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGpzb25SZXMuYm9keSwge1xuXHRcdFx0aGVhZGVyczoganNvblJlcy5oZWFkZXJzLFxuXHRcdFx0c3RhdHVzOiBqc29uUmVzLnN0YXR1c1xuXHRcdH0pO1xuXHR9O1xuXHRjb25zdCBvcHRpb25zUmVmID0geyBmYWxsYmFjazogZ2xvYmFsRmV0Y2ggfTtcblx0Y29uc3QgZXh0cmFzID0ge1xuXHRcdGNvbmZpZzogKG9wdGlvbnMpID0+IHtcblx0XHRcdE9iamVjdC5hc3NpZ24ob3B0aW9uc1JlZiwgb3B0aW9ucyk7XG5cdFx0XHRPYmplY3QuYXNzaWduKHN0ZXBGZXRjaCwgb3B0aW9uc1JlZik7XG5cdFx0XHRyZXR1cm4gc3RlcEZldGNoO1xuXHRcdH0sXG5cdFx0Li4ub3B0aW9uc1JlZlxuXHR9O1xuXHRzdGVwRmV0Y2ggPSBPYmplY3QuYXNzaWduKGZldGNoJDEsIGV4dHJhcyk7XG5cdHJldHVybiBzdGVwRmV0Y2g7XG59O1xuLyoqXG4qIGBmZXRjaGAgaXMgYSBGZXRjaCBBUEktY29tcGF0aWJsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYW55IEhUVFBcbiogY29kZSBkdXJhYmxlIGlmIGl0J3MgY2FsbGVkIHdpdGhpbiBhbiBJbm5nZXN0IGZ1bmN0aW9uLlxuKlxuKiBJdCB3aWxsIGdyYWNlZnVsbHkgZmFsbCBiYWNrIHRvIHRoZSBnbG9iYWwgYGZldGNoYCBpZiBjYWxsZWQgb3V0c2lkZSBvZiB0aGlzXG4qIGNvbnRleHQsIGFuZCBhIGN1c3RvbSBmYWxsYmFjayBjYW4gYmUgc2V0IHVzaW5nIHRoZSBgY29uZmlnYCBtZXRob2QuXG4qXG4qIEBleGFtcGxlIEJhc2ljIHVzYWdlXG4qIGBgYHRzXG4qIGltcG9ydCB7IGZldGNoIH0gZnJvbSBcImlubmdlc3RcIjtcbipcbiogY29uc3QgYXBpID0gbmV3IE15UHJvZHVjdEFwaSh7IGZldGNoIH0pO1xuKiBgYGBcbipcbiogQGV4YW1wbGUgU2V0dGluZyBhIGN1c3RvbSBmYWxsYmFja1xuKiBgYGB0c1xuKiBpbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJpbm5nZXN0XCI7XG4qXG4qIGNvbnN0IGFwaSA9IG5ldyBNeVByb2R1Y3RBcGkoe1xuKiAgICAgICAgICAgIGZldGNoOiBmZXRjaC5jb25maWcoeyBmYWxsYmFjazogbXlDdXN0b21GZXRjaCB9KSxcbiogfSk7XG4qIGBgYFxuKlxuKiBAZXhhbXBsZSBEbyBub3QgYWxsb3cgZmFsbGJhY2tcbiogYGBgdHNcbiogaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwiaW5uZ2VzdFwiO1xuKlxuKiBjb25zdCBhcGkgPSBuZXcgTXlQcm9kdWN0QXBpKHtcbiogICAgICAgICAgICBmZXRjaDogZmV0Y2guY29uZmlnKHsgZmFsbGJhY2s6IHVuZGVmaW5lZCB9KSxcbiogfSk7XG4qIGBgYFxuKi9cbmNvbnN0IGZldGNoID0gY3JlYXRlRmV0Y2hTaGltKCk7XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgZmV0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBc3luY0N0eCIsImdhdGV3YXlTeW1ib2wiLCJkZWJ1ZyIsImdsb2JhbEZldGNoIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiZGVidWckMSIsImNyZWF0ZUZldGNoU2hpbSIsInN0ZXBGZXRjaCIsImZldGNoJDEiLCJpbnB1dCIsImluaXQiLCJjdHgiLCJleGVjdXRpb24iLCJmYWxsYmFjayIsIkVycm9yIiwiZXhlY3V0aW5nU3RlcCIsImlkIiwidGFyZ2V0VXJsIiwiVVJMIiwiUmVxdWVzdCIsInVybCIsInRvU3RyaW5nIiwiaG9zdG5hbWUiLCJqc29uUmVzIiwic3RlcCIsIlJlc3BvbnNlIiwiYm9keSIsImhlYWRlcnMiLCJzdGF0dXMiLCJvcHRpb25zUmVmIiwiZXh0cmFzIiwiY29uZmlnIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Inngest.js":
/*!****************************************************!*\
  !*** ./node_modules/inngest/components/Inngest.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Inngest: () => (/* binding */ Inngest)\n/* harmony export */ });\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var _InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/* harmony import */ var _helpers_strings_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/* harmony import */ var _helpers_env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/* harmony import */ var _helpers_devserver_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\n/* harmony import */ var _helpers_promises_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/* harmony import */ var _InngestFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\n/* harmony import */ var _api_api_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../api/api.js */ \"(rsc)/./node_modules/inngest/api/api.js\");\n/* harmony import */ var _helpers_crypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/crypto.js */ \"(rsc)/./node_modules/inngest/helpers/crypto.js\");\n/* harmony import */ var _middleware_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n//#region src/components/Inngest.ts\n/**\n* A client used to interact with the Inngest API by sending or reacting to\n* events.\n*\n* To provide event typing, see {@link EventSchemas}.\n*\n* ```ts\n* const inngest = new Inngest({ id: \"my-app\" });\n*\n* // or to provide event typing too\n* const inngest = new Inngest({\n*   id: \"my-app\",\n*   schemas: new EventSchemas().fromRecord<{\n*     \"app/user.created\": {\n*       data: { userId: string };\n*     };\n*   }>(),\n* });\n* ```\n*\n* @public\n*/ var Inngest = class Inngest {\n    get [Symbol.toStringTag]() {\n        return Inngest.Tag;\n    }\n    get apiBaseUrl() {\n        return this._apiBaseUrl;\n    }\n    get eventBaseUrl() {\n        return this._eventBaseUrl;\n    }\n    get env() {\n        return this.headers[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.Environment] ?? null;\n    }\n    get appVersion() {\n        return this._appVersion;\n    }\n    /**\n\t* A client used to interact with the Inngest API by sending or reacting to\n\t* events.\n\t*\n\t* To provide event typing, see {@link EventSchemas}.\n\t*\n\t* ```ts\n\t* const inngest = new Inngest({ name: \"My App\" });\n\t*\n\t* // or to provide event typing too\n\t* const inngest = new Inngest({\n\t*   name: \"My App\",\n\t*   schemas: new EventSchemas().fromRecord<{\n\t*     \"app/user.created\": {\n\t*       data: { userId: string };\n\t*     };\n\t*   }>(),\n\t* });\n\t* ```\n\t*/ constructor(options){\n        /**\n\t* Inngest event key, used to send events to Inngest Cloud.\n\t*/ this.eventKey = \"\";\n        /**\n\t* The absolute URL of the Inngest Cloud API.\n\t*/ this.sendEventUrl = new URL(`e/${this.eventKey}`, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultInngestEventBaseUrl);\n        this.localFns = [];\n        this.createFunction = (rawOptions, rawTrigger, handler)=>{\n            const fn = this._createFunction(rawOptions, rawTrigger, handler);\n            this.localFns.push(fn);\n            return fn;\n        };\n        this._createFunction = (rawOptions, rawTrigger, handler)=>{\n            const options = this.sanitizeOptions(rawOptions);\n            const triggers = this.sanitizeTriggers(rawTrigger);\n            return new _InngestFunction_js__WEBPACK_IMPORTED_MODULE_1__.InngestFunction(this, {\n                ...options,\n                triggers\n            }, handler);\n        };\n        this.options = options;\n        const { id, fetch, logger = new _middleware_logger_js__WEBPACK_IMPORTED_MODULE_2__.DefaultLogger(), middleware, isDev, schemas, appVersion } = this.options;\n        if (!id) throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n        this.id = id;\n        this._mode = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.getMode)({\n            explicitMode: typeof isDev === \"boolean\" ? isDev ? \"dev\" : \"cloud\" : void 0\n        });\n        this.fetch = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.getFetch)(fetch);\n        this.inngestApi = new _api_api_js__WEBPACK_IMPORTED_MODULE_4__.InngestApi({\n            baseUrl: this.apiBaseUrl,\n            signingKey: (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.processEnv)(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestSigningKey) || \"\",\n            signingKeyFallback: (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.processEnv)(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestSigningKeyFallback),\n            fetch: this.fetch,\n            mode: this.mode\n        });\n        this.schemas = schemas;\n        this.loadModeEnvVars();\n        this.logger = logger;\n        this.middleware = this.initializeMiddleware([\n            ...builtInMiddleware,\n            ...middleware || []\n        ]);\n        this._appVersion = appVersion;\n    }\n    /**\n\t* Returns a `Promise` that resolves when the app is ready and all middleware\n\t* has been initialized.\n\t*/ get ready() {\n        return this.middleware.then(()=>{});\n    }\n    /**\n\t* Set the environment variables for this client. This is useful if you are\n\t* passed environment variables at runtime instead of as globals and need to\n\t* update the client with those values as requests come in.\n\t*/ setEnvVars(env = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.allProcessEnv)()) {\n        this.mode = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.getMode)({\n            env,\n            client: this\n        });\n        return this;\n    }\n    loadModeEnvVars() {\n        this._apiBaseUrl = this.options.baseUrl || this.mode[\"env\"][_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestApiBaseUrl] || this.mode[\"env\"][_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestBaseUrl] || this.mode.getExplicitUrl(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultInngestApiBaseUrl);\n        this._eventBaseUrl = this.options.baseUrl || this.mode[\"env\"][_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestEventApiBaseUrl] || this.mode[\"env\"][_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestBaseUrl] || this.mode.getExplicitUrl(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultInngestEventBaseUrl);\n        this.setEventKey(this.options.eventKey || this.mode[\"env\"][_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestEventKey] || \"\");\n        this.headers = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.inngestHeaders)({\n            inngestEnv: this.options.env,\n            env: this.mode[\"env\"]\n        });\n        this.inngestApi[\"mode\"] = this.mode;\n        this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n    }\n    /**\n\t* Initialize all passed middleware, running the `register` function on each\n\t* in sequence and returning the requested hook registrations.\n\t*/ async initializeMiddleware(middleware = [], opts) {\n        /**\n\t\t* Wait for the prefix stack to run first; do not trigger ours before this\n\t\t* is complete.\n\t\t*/ const prefix = await (opts?.prefixStack ?? []);\n        const stack = middleware.reduce(async (acc, m)=>{\n            const prev = await acc;\n            const next = await m.init({\n                client: this,\n                ...opts?.registerInput\n            });\n            return [\n                ...prev,\n                next\n            ];\n        }, Promise.resolve([]));\n        return [\n            ...prefix,\n            ...await stack\n        ];\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        this.loadModeEnvVars();\n    }\n    /**\n\t* Given a response from Inngest, relay the error to the caller.\n\t*/ async getResponseError(response, rawBody, foundErr = \"Unknown error\") {\n        let errorMessage = foundErr;\n        if (errorMessage === \"Unknown error\") switch(response.status){\n            case 401:\n                errorMessage = \"Event key Not Found\";\n                break;\n            case 400:\n                errorMessage = \"Cannot process event payload\";\n                break;\n            case 403:\n                errorMessage = \"Forbidden\";\n                break;\n            case 404:\n                errorMessage = \"Event key not found\";\n                break;\n            case 406:\n                errorMessage = `${JSON.stringify(await rawBody)}`;\n                break;\n            case 409:\n            case 412:\n                errorMessage = \"Event transformation failed\";\n                break;\n            case 413:\n                errorMessage = \"Event payload too large\";\n                break;\n            case 500:\n                errorMessage = \"Internal server error\";\n                break;\n            default:\n                try {\n                    errorMessage = await response.text();\n                } catch (_err) {\n                    errorMessage = `${JSON.stringify(await rawBody)}`;\n                }\n                break;\n        }\n        return /* @__PURE__ */ new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n    }\n    /**\n\t* Set the event key for this instance of Inngest. This is useful if for some\n\t* reason the key is not available at time of instantiation or present in the\n\t* `INNGEST_EVENT_KEY` environment variable.\n\t*/ setEventKey(eventKey) {\n        this.eventKey = eventKey || _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.dummyEventKey;\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultInngestEventBaseUrl);\n    }\n    eventKeySet() {\n        return Boolean(this.eventKey) && this.eventKey !== _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.dummyEventKey;\n    }\n    /**\n\t* EXPERIMENTAL: This API is not yet stable and may change in the future\n\t* without a major version bump.\n\t*\n\t* Send a Signal to Inngest.\n\t*/ async sendSignal({ signal, data, env }) {\n        const headers = {\n            ...env ? {\n                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.Environment]: env\n            } : {}\n        };\n        return this._sendSignal({\n            signal,\n            data,\n            headers\n        });\n    }\n    async _sendSignal({ signal, data, headers }) {\n        const res = await this.inngestApi.sendSignal({\n            signal,\n            data\n        }, {\n            ...this.headers,\n            ...headers\n        });\n        if (res.ok) return res.value;\n        throw new Error(`Failed to send signal: ${res.error?.error || \"Unknown error\"}`);\n    }\n    /**\n\t* Send one or many events to Inngest. Takes an entire payload (including\n\t* name) as each input.\n\t*\n\t* ```ts\n\t* await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n\t* ```\n\t*\n\t* Returns a promise that will resolve if the event(s) were sent successfully,\n\t* else throws with an error explaining what went wrong.\n\t*\n\t* If you wish to send an event with custom types (i.e. one that hasn't been\n\t* generated), make sure to add it when creating your Inngest instance, like\n\t* so:\n\t*\n\t* ```ts\n\t* const inngest = new Inngest({\n\t*   name: \"My App\",\n\t*   schemas: new EventSchemas().fromRecord<{\n\t*     \"my/event\": {\n\t*       name: \"my/event\";\n\t*       data: { bar: string };\n\t*     };\n\t*   }>(),\n\t* });\n\t* ```\n\t*/ async send(payload, options) {\n        const headers = {\n            ...options?.env ? {\n                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.Environment]: options.env\n            } : {}\n        };\n        return this._send({\n            payload,\n            headers\n        });\n    }\n    /**\n\t* Internal method for sending an event, used to allow Inngest internals to\n\t* further customize the request sent to an Inngest Server.\n\t*/ async _send({ payload, headers }) {\n        const nowMillis = /* @__PURE__ */ new Date().getTime();\n        let maxAttempts = 5;\n        try {\n            const entropy = (0,_helpers_crypto_js__WEBPACK_IMPORTED_MODULE_5__.createEntropy)(10);\n            const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n            headers = {\n                ...headers,\n                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}`\n            };\n        } catch (err) {\n            let message = \"Event-sending retries disabled\";\n            if (err instanceof Error) message += `: ${err.message}`;\n            console.debug(message);\n            maxAttempts = 1;\n        }\n        const hooks = await (0,_InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_6__.getHookStack)(this.middleware, \"onSendEvent\", void 0, {\n            transformInput: (prev, output)=>{\n                return {\n                    ...prev,\n                    ...output\n                };\n            },\n            transformOutput (prev, output) {\n                return {\n                    result: {\n                        ...prev.result,\n                        ...output?.result\n                    }\n                };\n            }\n        });\n        let payloads = Array.isArray(payload) ? payload : payload ? [\n            payload\n        ] : [];\n        const inputChanges = await hooks.transformInput?.({\n            payloads: [\n                ...payloads\n            ]\n        });\n        if (inputChanges?.payloads) payloads = [\n            ...inputChanges.payloads\n        ];\n        payloads = payloads.map((p)=>{\n            return {\n                ...p,\n                id: p.id,\n                ts: p.ts || nowMillis,\n                data: p.data || {}\n            };\n        });\n        const applyHookToOutput = async (arg)=>{\n            const hookOutput = await hooks.transformOutput?.(arg);\n            return {\n                ...arg.result,\n                ...hookOutput?.result\n            };\n        };\n        /**\n\t\t* It can be valid for a user to send an empty list of events; if this\n\t\t* happens, show a warning that this may not be intended, but don't throw.\n\t\t*/ if (!payloads.length) {\n            console.warn((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.prettyError)({\n                type: \"warn\",\n                whatHappened: \"`inngest.send()` called with no events\",\n                reassurance: \"This is not an error, but you may not have intended to do this.\",\n                consequences: \"The returned promise will resolve, but no events have been sent to Inngest.\",\n                stack: true\n            }));\n            return await applyHookToOutput({\n                result: {\n                    ids: []\n                }\n            });\n        }\n        let url = this.sendEventUrl.href;\n        /**\n\t\t* If in prod mode and key is not present, fail now.\n\t\t*/ if (this.mode.isCloud && !this.eventKeySet()) throw new Error((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.prettyError)({\n            whatHappened: \"Failed to send event\",\n            consequences: \"Your event or events were not sent to Inngest.\",\n            why: \"We couldn't find an event key to use to send events to Inngest.\",\n            toFixNow: _helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.fixEventKeyMissingSteps\n        }));\n        /**\n\t\t* If dev mode has been inferred, try to hit the dev server first to see if\n\t\t* it exists. If it does, use it, otherwise fall back to whatever server we\n\t\t* have configured.\n\t\t*\n\t\t* `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n\t\t* user has set this it means they have already chosen a URL to hit.\n\t\t*/ if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n            if (await (0,_helpers_devserver_js__WEBPACK_IMPORTED_MODULE_8__.devServerAvailable)(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultDevServerHost, this.fetch)) url = (0,_helpers_devserver_js__WEBPACK_IMPORTED_MODULE_8__.devServerUrl)(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultDevServerHost, `e/${this.eventKey}`).href;\n        }\n        return await applyHookToOutput({\n            result: {\n                ids: (await (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_9__.retryWithBackoff)(async ()=>{\n                    let rawBody;\n                    let body;\n                    const response = await this.fetch(url, {\n                        method: \"POST\",\n                        body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_10__.stringify)(payloads),\n                        headers: {\n                            ...this.headers,\n                            ...headers\n                        }\n                    });\n                    try {\n                        rawBody = await response.json();\n                        body = await _types_js__WEBPACK_IMPORTED_MODULE_11__.sendEventResponseSchema.parseAsync(rawBody);\n                    } catch (_err) {\n                        throw await this.getResponseError(response, rawBody);\n                    }\n                    if (body.status !== 200 || body.error) throw await this.getResponseError(response, rawBody, body.error);\n                    return body;\n                }, {\n                    maxAttempts,\n                    baseDelay: 100\n                })).ids\n            }\n        });\n    }\n    get funcs() {\n        return this.localFns;\n    }\n    /**\n\t* Runtime-only validation.\n\t*/ sanitizeOptions(options) {\n        if (Object.hasOwn(options, \"fns\")) console.warn(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`);\n        if (typeof options === \"string\") {\n            console.warn(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return {\n                id: options\n            };\n        }\n        return options;\n    }\n    /**\n\t* Runtime-only validation.\n\t*/ sanitizeTriggers(triggers) {\n        if (typeof triggers === \"string\") {\n            console.warn(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return [\n                {\n                    event: triggers\n                }\n            ];\n        }\n        if (!Array.isArray(triggers)) return [\n            triggers\n        ];\n        return triggers;\n    }\n};\n/**\n* Default middleware that is included in every client, placed after the user's\n* middleware on the client but before function-level middleware.\n*\n* It is defined here to ensure that comments are included in the generated TS\n* definitions. Without this, we infer the stack of built-in middleware without\n* comments, losing a lot of value.\n*\n* If this is moved, please ensure that using this package in another project\n* can correctly access comments on mutated input and output.\n*\n* This return pattern mimics the output of a `satisfies` suffix; it's used as\n* we support versions of TypeScript prior to the introduction of `satisfies`.\n*/ const builtInMiddleware = ((m)=>m)([\n    new _InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_6__.InngestMiddleware({\n        name: \"Inngest: Logger\",\n        init ({ client }) {\n            return {\n                onFunctionRun (arg) {\n                    const { ctx } = arg;\n                    const metadata = {\n                        runID: ctx.runId,\n                        eventName: ctx.event.name,\n                        functionName: arg.fn.name\n                    };\n                    let providedLogger = client[\"logger\"];\n                    try {\n                        if (\"child\" in providedLogger) providedLogger = providedLogger.child(metadata);\n                    } catch (err) {\n                        console.error('failed to create \"childLogger\" with error: ', err);\n                    }\n                    const logger = new _middleware_logger_js__WEBPACK_IMPORTED_MODULE_2__.ProxyLogger(providedLogger);\n                    return {\n                        transformInput () {\n                            return {\n                                ctx: {\n                                    logger\n                                }\n                            };\n                        },\n                        beforeExecution () {\n                            logger.enable();\n                        },\n                        transformOutput ({ result: { error } }) {\n                            if (error) logger.error(error);\n                        },\n                        async beforeResponse () {\n                            await logger.flush();\n                        }\n                    };\n                }\n            };\n        }\n    })\n]);\n(function(_Inngest) {\n    _Inngest.Tag = \"Inngest.App\";\n})(Inngest || (Inngest = {}));\n//#endregion\n //# sourceMappingURL=Inngest.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFpSztBQUMzRztBQUNzQjtBQUNIO0FBQ3ZCO0FBQytDO0FBQ3RCO0FBQ2pCO0FBQ0g7QUFDWjtBQUNVO0FBQ2dCO0FBRXJFLG1DQUFtQztBQUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBLEdBQ0EsSUFBSTBCLFVBQVUsTUFBTUE7SUFDbkIsSUFBSSxDQUFDQyxPQUFPQyxXQUFXLENBQUMsR0FBRztRQUMxQixPQUFPRixRQUFRRyxHQUFHO0lBQ25CO0lBZ0RBLElBQUlDLGFBQWE7UUFDaEIsT0FBTyxJQUFJLENBQUNDLFdBQVc7SUFDeEI7SUFDQSxJQUFJQyxlQUFlO1FBQ2xCLE9BQU8sSUFBSSxDQUFDQyxhQUFhO0lBQzFCO0lBQ0EsSUFBSUMsTUFBTTtRQUNULE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUM5QiwwREFBVUEsQ0FBQytCLFdBQVcsQ0FBQyxJQUFJO0lBQ2hEO0lBQ0EsSUFBSUMsYUFBYTtRQUNoQixPQUFPLElBQUksQ0FBQ0MsV0FBVztJQUN4QjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJBLEdBQ0FDLFlBQVlDLE9BQU8sQ0FBRTtRQWpFckI7O0NBRUEsUUFDQUMsV0FBVztRQUlYOztDQUVBLFFBQ0FDLGVBQWUsSUFBSUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNGLFFBQVEsQ0FBQyxDQUFDLEVBQUV2QywwRUFBMEJBO2FBSXZFMEMsV0FBVyxFQUFFO2FBK1ZiQyxpQkFBaUIsQ0FBQ0MsWUFBWUMsWUFBWUM7WUFDekMsTUFBTUMsS0FBSyxJQUFJLENBQUNDLGVBQWUsQ0FBQ0osWUFBWUMsWUFBWUM7WUFDeEQsSUFBSSxDQUFDSixRQUFRLENBQUNPLElBQUksQ0FBQ0Y7WUFDbkIsT0FBT0E7UUFDUjthQUlBQyxrQkFBa0IsQ0FBQ0osWUFBWUMsWUFBWUM7WUFDMUMsTUFBTVIs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QixLQUFLLEVBQUUsRUFBRTs0QkFDcEMsSUFBSUEsT0FBTzNELE9BQU8yRCxLQUFLLENBQUNBO3dCQUN6Qjt3QkFDQSxNQUFNbUU7NEJBQ0wsTUFBTTlILE9BQU8rSCxLQUFLO3dCQUNuQjtvQkFDRDtnQkFDRDtZQUFFO1FBQ0g7SUFDRDtDQUFHO0FBQ0YsVUFBU0MsUUFBUTtJQUNqQkEsU0FBUzVKLEdBQUcsR0FBRztBQUNoQixHQUFHSCxXQUFZQSxDQUFBQSxVQUFVLENBQUM7QUFFMUIsWUFBWTtBQUNPLENBQ25CLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3QuanM/YzY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZhdWx0RGV2U2VydmVySG9zdCwgZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsLCBkZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCwgZHVtbXlFdmVudEtleSwgZW52S2V5cywgaGVhZGVyS2V5cywgbG9nUHJlZml4IH0gZnJvbSBcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBzZW5kRXZlbnRSZXNwb25zZVNjaGVtYSB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMsIHByZXR0eUVycm9yIH0gZnJvbSBcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBJbm5nZXN0TWlkZGxld2FyZSwgZ2V0SG9va1N0YWNrIH0gZnJvbSBcIi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIjtcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gXCIuLi9oZWxwZXJzL3N0cmluZ3MuanNcIjtcbmltcG9ydCB7IGFsbFByb2Nlc3NFbnYsIGdldEZldGNoLCBnZXRNb2RlLCBpbm5nZXN0SGVhZGVycywgcHJvY2Vzc0VudiB9IGZyb20gXCIuLi9oZWxwZXJzL2Vudi5qc1wiO1xuaW1wb3J0IHsgZGV2U2VydmVyQXZhaWxhYmxlLCBkZXZTZXJ2ZXJVcmwgfSBmcm9tIFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIjtcbmltcG9ydCB7IHJldHJ5V2l0aEJhY2tvZmYgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlcy5qc1wiO1xuaW1wb3J0IHsgSW5uZ2VzdEZ1bmN0aW9uIH0gZnJvbSBcIi4vSW5uZ2VzdEZ1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBJbm5nZXN0QXBpIH0gZnJvbSBcIi4uL2FwaS9hcGkuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUVudHJvcHkgfSBmcm9tIFwiLi4vaGVscGVycy9jcnlwdG8uanNcIjtcbmltcG9ydCB7IERlZmF1bHRMb2dnZXIsIFByb3h5TG9nZ2VyIH0gZnJvbSBcIi4uL21pZGRsZXdhcmUvbG9nZ2VyLmpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvY29tcG9uZW50cy9Jbm5nZXN0LnRzXG4vKipcbiogQSBjbGllbnQgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBJbm5nZXN0IEFQSSBieSBzZW5kaW5nIG9yIHJlYWN0aW5nIHRvXG4qIGV2ZW50cy5cbipcbiogVG8gcHJvdmlkZSBldmVudCB0eXBpbmcsIHNlZSB7QGxpbmsgRXZlbnRTY2hlbWFzfS5cbipcbiogYGBgdHNcbiogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHsgaWQ6IFwibXktYXBwXCIgfSk7XG4qXG4qIC8vIG9yIHRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nIHRvb1xuKiBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuKiAgIGlkOiBcIm15LWFwcFwiLFxuKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tUmVjb3JkPHtcbiogICAgIFwiYXBwL3VzZXIuY3JlYXRlZFwiOiB7XG4qICAgICAgIGRhdGE6IHsgdXNlcklkOiBzdHJpbmcgfTtcbiogICAgIH07XG4qICAgfT4oKSxcbiogfSk7XG4qIGBgYFxuKlxuKiBAcHVibGljXG4qL1xudmFyIElubmdlc3QgPSBjbGFzcyBJbm5nZXN0IHtcblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiBJbm5nZXN0LlRhZztcblx0fVxuXHQvKipcblx0KiBUaGUgSUQgb2YgdGhpcyBpbnN0YW5jZSwgbW9zdCBjb21tb25seSBhIHJlZmVyZW5jZSB0byB0aGUgYXBwbGljYXRpb24gaXRcblx0KiByZXNpZGVzIGluLlxuXHQqXG5cdCogVGhlIElEIG9mIHlvdXIgY2xpZW50IHNob3VsZCByZW1haW4gdGhlIHNhbWUgZm9yIGl0cyBsaWZldGltZTsgaWYgeW91J2Rcblx0KiBsaWtlIHRvIGNoYW5nZSB0aGUgbmFtZSBvZiB5b3VyIGNsaWVudCBhcyBpdCBhcHBlYXJzIGluIHRoZSBJbm5nZXN0IFVJLFxuXHQqIGNoYW5nZSB0aGUgYG5hbWVgIHByb3BlcnR5IGluc3RlYWQuXG5cdCovXG5cdGlkO1xuXHQvKipcblx0KiBTdG9yZXMgdGhlIG9wdGlvbnMgc28gd2UgY2FuIHJlbWVtYmVyIGV4cGxpY2l0IHNldHRpbmdzIHRoZSB1c2VyIGhhc1xuXHQqIHByb3ZpZGVkLlxuXHQqL1xuXHRvcHRpb25zO1xuXHQvKipcblx0KiBJbm5nZXN0IGV2ZW50IGtleSwgdXNlZCB0byBzZW5kIGV2ZW50cyB0byBJbm5nZXN0IENsb3VkLlxuXHQqL1xuXHRldmVudEtleSA9IFwiXCI7XG5cdF9hcGlCYXNlVXJsO1xuXHRfZXZlbnRCYXNlVXJsO1xuXHRpbm5nZXN0QXBpO1xuXHQvKipcblx0KiBUaGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBJbm5nZXN0IENsb3VkIEFQSS5cblx0Ki9cblx0c2VuZEV2ZW50VXJsID0gbmV3IFVSTChgZS8ke3RoaXMuZXZlbnRLZXl9YCwgZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwpO1xuXHRoZWFkZXJzO1xuXHRmZXRjaDtcblx0bG9nZ2VyO1xuXHRsb2NhbEZucyA9IFtdO1xuXHQvKipcblx0KiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtaWRkbGV3YXJlIHN0YWNrIGhhcyBiZWVuIGluaXRpYWxpemVkIGFuZFxuXHQqIHRoZSBjbGllbnQgaXMgcmVhZHkgdG8gYmUgdXNlZC5cblx0Ki9cblx0bWlkZGxld2FyZTtcblx0LyoqXG5cdCogV2hldGhlciB0aGUgY2xpZW50IGlzIHJ1bm5pbmcgaW4gYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LiBUaGlzIGNhblxuXHQqIHNvbWV0aW1lcyBiZSBgdW5kZWZpbmVkYCBpZiB0aGUgY2xpZW50IGhhcyBleHByZXNzZWQgbm8gcHJlZmVyZW5jZSBvclxuXHQqIHBlcmhhcHMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBvbmx5IGF2YWlsYWJsZSBhdCBhIGxhdGVyIHN0YWdlIGluIHRoZVxuXHQqIHJ1bnRpbWUsIGZvciBleGFtcGxlIHdoZW4gcmVjZWl2aW5nIGEgcmVxdWVzdC5cblx0KlxuXHQqIEFuIHtAbGluayBJbm5nZXN0Q29tbUhhbmRsZXJ9IHNob3VsZCBwcmlvcml0aXplIHRoaXMgdmFsdWUgb3ZlciBhbGwgb3RoZXJcblx0KiBzZXR0aW5ncywgYnV0IHNob3VsZCBzdGlsbCBjaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIGFuIGVudmlyb25tZW50XG5cdCogdmFyaWFibGUgaWYgaXQgaXMgbm90IHNldC5cblx0Ki9cblx0X21vZGU7XG5cdHNjaGVtYXM7XG5cdF9hcHBWZXJzaW9uO1xuXHRnZXQgYXBpQmFzZVVybCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBpQmFzZVVybDtcblx0fVxuXHRnZXQgZXZlbnRCYXNlVXJsKCkge1xuXHRcdHJldHVybiB0aGlzLl9ldmVudEJhc2VVcmw7XG5cdH1cblx0Z2V0IGVudigpIHtcblx0XHRyZXR1cm4gdGhpcy5oZWFkZXJzW2hlYWRlcktleXMuRW52aXJvbm1lbnRdID8/IG51bGw7XG5cdH1cblx0Z2V0IGFwcFZlcnNpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcFZlcnNpb247XG5cdH1cblx0LyoqXG5cdCogQSBjbGllbnQgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBJbm5nZXN0IEFQSSBieSBzZW5kaW5nIG9yIHJlYWN0aW5nIHRvXG5cdCogZXZlbnRzLlxuXHQqXG5cdCogVG8gcHJvdmlkZSBldmVudCB0eXBpbmcsIHNlZSB7QGxpbmsgRXZlbnRTY2hlbWFzfS5cblx0KlxuXHQqIGBgYHRzXG5cdCogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHsgbmFtZTogXCJNeSBBcHBcIiB9KTtcblx0KlxuXHQqIC8vIG9yIHRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nIHRvb1xuXHQqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG5cdCogICBuYW1lOiBcIk15IEFwcFwiLFxuXHQqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21SZWNvcmQ8e1xuXHQqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuXHQqICAgICAgIGRhdGE6IHsgdXNlcklkOiBzdHJpbmcgfTtcblx0KiAgICAgfTtcblx0KiAgIH0+KCksXG5cdCogfSk7XG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdGNvbnN0IHsgaWQsIGZldGNoLCBsb2dnZXIgPSBuZXcgRGVmYXVsdExvZ2dlcigpLCBtaWRkbGV3YXJlLCBpc0Rldiwgc2NoZW1hcywgYXBwVmVyc2lvbiB9ID0gdGhpcy5vcHRpb25zO1xuXHRcdGlmICghaWQpIHRocm93IG5ldyBFcnJvcihcIkFuIGBpZGAgbXVzdCBiZSBwYXNzZWQgdG8gY3JlYXRlIGFuIElubmdlc3QgaW5zdGFuY2UuXCIpO1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLl9tb2RlID0gZ2V0TW9kZSh7IGV4cGxpY2l0TW9kZTogdHlwZW9mIGlzRGV2ID09PSBcImJvb2xlYW5cIiA/IGlzRGV2ID8gXCJkZXZcIiA6IFwiY2xvdWRcIiA6IHZvaWQgMCB9KTtcblx0XHR0aGlzLmZldGNoID0gZ2V0RmV0Y2goZmV0Y2gpO1xuXHRcdHRoaXMuaW5uZ2VzdEFwaSA9IG5ldyBJbm5nZXN0QXBpKHtcblx0XHRcdGJhc2VVcmw6IHRoaXMuYXBpQmFzZVVybCxcblx0XHRcdHNpZ25pbmdLZXk6IHByb2Nlc3NFbnYoZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleSkgfHwgXCJcIixcblx0XHRcdHNpZ25pbmdLZXlGYWxsYmFjazogcHJvY2Vzc0VudihlbnZLZXlzLklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2spLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2gsXG5cdFx0XHRtb2RlOiB0aGlzLm1vZGVcblx0XHR9KTtcblx0XHR0aGlzLnNjaGVtYXMgPSBzY2hlbWFzO1xuXHRcdHRoaXMubG9hZE1vZGVFbnZWYXJzKCk7XG5cdFx0dGhpcy5sb2dnZXIgPSBsb2dnZXI7XG5cdFx0dGhpcy5taWRkbGV3YXJlID0gdGhpcy5pbml0aWFsaXplTWlkZGxld2FyZShbLi4uYnVpbHRJbk1pZGRsZXdhcmUsIC4uLm1pZGRsZXdhcmUgfHwgW11dKTtcblx0XHR0aGlzLl9hcHBWZXJzaW9uID0gYXBwVmVyc2lvbjtcblx0fVxuXHQvKipcblx0KiBSZXR1cm5zIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgYXBwIGlzIHJlYWR5IGFuZCBhbGwgbWlkZGxld2FyZVxuXHQqIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuXHQqL1xuXHRnZXQgcmVhZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWlkZGxld2FyZS50aGVuKCgpID0+IHt9KTtcblx0fVxuXHQvKipcblx0KiBTZXQgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgdGhpcyBjbGllbnQuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhcmVcblx0KiBwYXNzZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzIGF0IHJ1bnRpbWUgaW5zdGVhZCBvZiBhcyBnbG9iYWxzIGFuZCBuZWVkIHRvXG5cdCogdXBkYXRlIHRoZSBjbGllbnQgd2l0aCB0aG9zZSB2YWx1ZXMgYXMgcmVxdWVzdHMgY29tZSBpbi5cblx0Ki9cblx0c2V0RW52VmFycyhlbnYgPSBhbGxQcm9jZXNzRW52KCkpIHtcblx0XHR0aGlzLm1vZGUgPSBnZXRNb2RlKHtcblx0XHRcdGVudixcblx0XHRcdGNsaWVudDogdGhpc1xuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGxvYWRNb2RlRW52VmFycygpIHtcblx0XHR0aGlzLl9hcGlCYXNlVXJsID0gdGhpcy5vcHRpb25zLmJhc2VVcmwgfHwgdGhpcy5tb2RlW1wiZW52XCJdW2VudktleXMuSW5uZ2VzdEFwaUJhc2VVcmxdIHx8IHRoaXMubW9kZVtcImVudlwiXVtlbnZLZXlzLklubmdlc3RCYXNlVXJsXSB8fCB0aGlzLm1vZGUuZ2V0RXhwbGljaXRVcmwoZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcblx0XHR0aGlzLl9ldmVudEJhc2VVcmwgPSB0aGlzLm9wdGlvbnMuYmFzZVVybCB8fCB0aGlzLm1vZGVbXCJlbnZcIl1bZW52S2V5cy5Jbm5nZXN0RXZlbnRBcGlCYXNlVXJsXSB8fCB0aGlzLm1vZGVbXCJlbnZcIl1bZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHwgdGhpcy5tb2RlLmdldEV4cGxpY2l0VXJsKGRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsKTtcblx0XHR0aGlzLnNldEV2ZW50S2V5KHRoaXMub3B0aW9ucy5ldmVudEtleSB8fCB0aGlzLm1vZGVbXCJlbnZcIl1bZW52S2V5cy5Jbm5nZXN0RXZlbnRLZXldIHx8IFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IGlubmdlc3RIZWFkZXJzKHtcblx0XHRcdGlubmdlc3RFbnY6IHRoaXMub3B0aW9ucy5lbnYsXG5cdFx0XHRlbnY6IHRoaXMubW9kZVtcImVudlwiXVxuXHRcdH0pO1xuXHRcdHRoaXMuaW5uZ2VzdEFwaVtcIm1vZGVcIl0gPSB0aGlzLm1vZGU7XG5cdFx0dGhpcy5pbm5nZXN0QXBpW1wiYXBpQmFzZVVybFwiXSA9IHRoaXMuX2FwaUJhc2VVcmw7XG5cdH1cblx0LyoqXG5cdCogSW5pdGlhbGl6ZSBhbGwgcGFzc2VkIG1pZGRsZXdhcmUsIHJ1bm5pbmcgdGhlIGByZWdpc3RlcmAgZnVuY3Rpb24gb24gZWFjaFxuXHQqIGluIHNlcXVlbmNlIGFuZCByZXR1cm5pbmcgdGhlIHJlcXVlc3RlZCBob29rIHJlZ2lzdHJhdGlvbnMuXG5cdCovXG5cdGFzeW5jIGluaXRpYWxpemVNaWRkbGV3YXJlKG1pZGRsZXdhcmUgPSBbXSwgb3B0cykge1xuXHRcdC8qKlxuXHRcdCogV2FpdCBmb3IgdGhlIHByZWZpeCBzdGFjayB0byBydW4gZmlyc3Q7IGRvIG5vdCB0cmlnZ2VyIG91cnMgYmVmb3JlIHRoaXNcblx0XHQqIGlzIGNvbXBsZXRlLlxuXHRcdCovXG5cdFx0Y29uc3QgcHJlZml4ID0gYXdhaXQgKG9wdHM/LnByZWZpeFN0YWNrID8/IFtdKTtcblx0XHRjb25zdCBzdGFjayA9IG1pZGRsZXdhcmUucmVkdWNlKGFzeW5jIChhY2MsIG0pID0+IHtcblx0XHRcdGNvbnN0IHByZXYgPSBhd2FpdCBhY2M7XG5cdFx0XHRjb25zdCBuZXh0ID0gYXdhaXQgbS5pbml0KHtcblx0XHRcdFx0Y2xpZW50OiB0aGlzLFxuXHRcdFx0XHQuLi5vcHRzPy5yZWdpc3RlcklucHV0XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBbLi4ucHJldiwgbmV4dF07XG5cdFx0fSwgUHJvbWlzZS5yZXNvbHZlKFtdKSk7XG5cdFx0cmV0dXJuIFsuLi5wcmVmaXgsIC4uLmF3YWl0IHN0YWNrXTtcblx0fVxuXHRnZXQgbW9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW9kZTtcblx0fVxuXHRzZXQgbW9kZShtKSB7XG5cdFx0dGhpcy5fbW9kZSA9IG07XG5cdFx0dGhpcy5sb2FkTW9kZUVudlZhcnMoKTtcblx0fVxuXHQvKipcblx0KiBHaXZlbiBhIHJlc3BvbnNlIGZyb20gSW5uZ2VzdCwgcmVsYXkgdGhlIGVycm9yIHRvIHRoZSBjYWxsZXIuXG5cdCovXG5cdGFzeW5jIGdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UsIHJhd0JvZHksIGZvdW5kRXJyID0gXCJVbmtub3duIGVycm9yXCIpIHtcblx0XHRsZXQgZXJyb3JNZXNzYWdlID0gZm91bmRFcnI7XG5cdFx0aWYgKGVycm9yTWVzc2FnZSA9PT0gXCJVbmtub3duIGVycm9yXCIpIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG5cdFx0XHRjYXNlIDQwMTpcblx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gXCJFdmVudCBrZXkgTm90IEZvdW5kXCI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA0MDA6XG5cdFx0XHRcdGVycm9yTWVzc2FnZSA9IFwiQ2Fubm90IHByb2Nlc3MgZXZlbnQgcGF5bG9hZFwiO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgNDAzOlxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIkZvcmJpZGRlblwiO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgNDA0OlxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIkV2ZW50IGtleSBub3QgZm91bmRcIjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDQwNjpcblx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gYCR7SlNPTi5zdHJpbmdpZnkoYXdhaXQgcmF3Qm9keSl9YDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDQwOTpcblx0XHRcdGNhc2UgNDEyOlxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIkV2ZW50IHRyYW5zZm9ybWF0aW9uIGZhaWxlZFwiO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgNDEzOlxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIkV2ZW50IHBheWxvYWQgdG9vIGxhcmdlXCI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSA1MDA6XG5cdFx0XHRcdGVycm9yTWVzc2FnZSA9IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCI7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cdFx0XHRcdH0gY2F0Y2ggKF9lcnIpIHtcblx0XHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBgJHtKU09OLnN0cmluZ2lmeShhd2FpdCByYXdCb2R5KX1gO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcihgSW5uZ2VzdCBBUEkgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke2Vycm9yTWVzc2FnZX1gKTtcblx0fVxuXHQvKipcblx0KiBTZXQgdGhlIGV2ZW50IGtleSBmb3IgdGhpcyBpbnN0YW5jZSBvZiBJbm5nZXN0LiBUaGlzIGlzIHVzZWZ1bCBpZiBmb3Igc29tZVxuXHQqIHJlYXNvbiB0aGUga2V5IGlzIG5vdCBhdmFpbGFibGUgYXQgdGltZSBvZiBpbnN0YW50aWF0aW9uIG9yIHByZXNlbnQgaW4gdGhlXG5cdCogYElOTkdFU1RfRVZFTlRfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cblx0Ki9cblx0c2V0RXZlbnRLZXkoZXZlbnRLZXkpIHtcblx0XHR0aGlzLmV2ZW50S2V5ID0gZXZlbnRLZXkgfHwgZHVtbXlFdmVudEtleTtcblx0XHR0aGlzLnNlbmRFdmVudFVybCA9IG5ldyBVUkwoYGUvJHt0aGlzLmV2ZW50S2V5fWAsIHRoaXMuZXZlbnRCYXNlVXJsIHx8IGRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsKTtcblx0fVxuXHRldmVudEtleVNldCgpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0aGlzLmV2ZW50S2V5KSAmJiB0aGlzLmV2ZW50S2V5ICE9PSBkdW1teUV2ZW50S2V5O1xuXHR9XG5cdC8qKlxuXHQqIEVYUEVSSU1FTlRBTDogVGhpcyBBUEkgaXMgbm90IHlldCBzdGFibGUgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZVxuXHQqIHdpdGhvdXQgYSBtYWpvciB2ZXJzaW9uIGJ1bXAuXG5cdCpcblx0KiBTZW5kIGEgU2lnbmFsIHRvIElubmdlc3QuXG5cdCovXG5cdGFzeW5jIHNlbmRTaWduYWwoeyBzaWduYWwsIGRhdGEsIGVudiB9KSB7XG5cdFx0Y29uc3QgaGVhZGVycyA9IHsgLi4uZW52ID8geyBbaGVhZGVyS2V5cy5FbnZpcm9ubWVudF06IGVudiB9IDoge30gfTtcblx0XHRyZXR1cm4gdGhpcy5fc2VuZFNpZ25hbCh7XG5cdFx0XHRzaWduYWwsXG5cdFx0XHRkYXRhLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHR9XG5cdGFzeW5jIF9zZW5kU2lnbmFsKHsgc2lnbmFsLCBkYXRhLCBoZWFkZXJzIH0pIHtcblx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLmlubmdlc3RBcGkuc2VuZFNpZ25hbCh7XG5cdFx0XHRzaWduYWwsXG5cdFx0XHRkYXRhXG5cdFx0fSwge1xuXHRcdFx0Li4udGhpcy5oZWFkZXJzLFxuXHRcdFx0Li4uaGVhZGVyc1xuXHRcdH0pO1xuXHRcdGlmIChyZXMub2spIHJldHVybiByZXMudmFsdWU7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2VuZCBzaWduYWw6ICR7cmVzLmVycm9yPy5lcnJvciB8fCBcIlVua25vd24gZXJyb3JcIn1gKTtcblx0fVxuXHQvKipcblx0KiBTZW5kIG9uZSBvciBtYW55IGV2ZW50cyB0byBJbm5nZXN0LiBUYWtlcyBhbiBlbnRpcmUgcGF5bG9hZCAoaW5jbHVkaW5nXG5cdCogbmFtZSkgYXMgZWFjaCBpbnB1dC5cblx0KlxuXHQqIGBgYHRzXG5cdCogYXdhaXQgaW5uZ2VzdC5zZW5kKHsgbmFtZTogXCJhcHAvdXNlci5jcmVhdGVkXCIsIGRhdGE6IHsgaWQ6IDEyMyB9IH0pO1xuXHQqIGBgYFxuXHQqXG5cdCogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgaWYgdGhlIGV2ZW50KHMpIHdlcmUgc2VudCBzdWNjZXNzZnVsbHksXG5cdCogZWxzZSB0aHJvd3Mgd2l0aCBhbiBlcnJvciBleHBsYWluaW5nIHdoYXQgd2VudCB3cm9uZy5cblx0KlxuXHQqIElmIHlvdSB3aXNoIHRvIHNlbmQgYW4gZXZlbnQgd2l0aCBjdXN0b20gdHlwZXMgKGkuZS4gb25lIHRoYXQgaGFzbid0IGJlZW5cblx0KiBnZW5lcmF0ZWQpLCBtYWtlIHN1cmUgdG8gYWRkIGl0IHdoZW4gY3JlYXRpbmcgeW91ciBJbm5nZXN0IGluc3RhbmNlLCBsaWtlXG5cdCogc286XG5cdCpcblx0KiBgYGB0c1xuXHQqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG5cdCogICBuYW1lOiBcIk15IEFwcFwiLFxuXHQqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21SZWNvcmQ8e1xuXHQqICAgICBcIm15L2V2ZW50XCI6IHtcblx0KiAgICAgICBuYW1lOiBcIm15L2V2ZW50XCI7XG5cdCogICAgICAgZGF0YTogeyBiYXI6IHN0cmluZyB9O1xuXHQqICAgICB9O1xuXHQqICAgfT4oKSxcblx0KiB9KTtcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgc2VuZChwYXlsb2FkLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgaGVhZGVycyA9IHsgLi4ub3B0aW9ucz8uZW52ID8geyBbaGVhZGVyS2V5cy5FbnZpcm9ubWVudF06IG9wdGlvbnMuZW52IH0gOiB7fSB9O1xuXHRcdHJldHVybiB0aGlzLl9zZW5kKHtcblx0XHRcdHBheWxvYWQsXG5cdFx0XHRoZWFkZXJzXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogSW50ZXJuYWwgbWV0aG9kIGZvciBzZW5kaW5nIGFuIGV2ZW50LCB1c2VkIHRvIGFsbG93IElubmdlc3QgaW50ZXJuYWxzIHRvXG5cdCogZnVydGhlciBjdXN0b21pemUgdGhlIHJlcXVlc3Qgc2VudCB0byBhbiBJbm5nZXN0IFNlcnZlci5cblx0Ki9cblx0YXN5bmMgX3NlbmQoeyBwYXlsb2FkLCBoZWFkZXJzIH0pIHtcblx0XHRjb25zdCBub3dNaWxsaXMgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHRsZXQgbWF4QXR0ZW1wdHMgPSA1O1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBlbnRyb3B5ID0gY3JlYXRlRW50cm9weSgxMCk7XG5cdFx0XHRjb25zdCBlbnRyb3B5QmFzZTY0ID0gQnVmZmVyLmZyb20oZW50cm9weSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cdFx0XHRoZWFkZXJzID0ge1xuXHRcdFx0XHQuLi5oZWFkZXJzLFxuXHRcdFx0XHRbaGVhZGVyS2V5cy5FdmVudElkU2VlZF06IGAke25vd01pbGxpc30sJHtlbnRyb3B5QmFzZTY0fWBcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRsZXQgbWVzc2FnZSA9IFwiRXZlbnQtc2VuZGluZyByZXRyaWVzIGRpc2FibGVkXCI7XG5cdFx0XHRpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIG1lc3NhZ2UgKz0gYDogJHtlcnIubWVzc2FnZX1gO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZyhtZXNzYWdlKTtcblx0XHRcdG1heEF0dGVtcHRzID0gMTtcblx0XHR9XG5cdFx0Y29uc3QgaG9va3MgPSBhd2FpdCBnZXRIb29rU3RhY2sodGhpcy5taWRkbGV3YXJlLCBcIm9uU2VuZEV2ZW50XCIsIHZvaWQgMCwge1xuXHRcdFx0dHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHQuLi5wcmV2LFxuXHRcdFx0XHRcdC4uLm91dHB1dFxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHRyYW5zZm9ybU91dHB1dChwcmV2LCBvdXRwdXQpIHtcblx0XHRcdFx0cmV0dXJuIHsgcmVzdWx0OiB7XG5cdFx0XHRcdFx0Li4ucHJldi5yZXN1bHQsXG5cdFx0XHRcdFx0Li4ub3V0cHV0Py5yZXN1bHRcblx0XHRcdFx0fSB9O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGxldCBwYXlsb2FkcyA9IEFycmF5LmlzQXJyYXkocGF5bG9hZCkgPyBwYXlsb2FkIDogcGF5bG9hZCA/IFtwYXlsb2FkXSA6IFtdO1xuXHRcdGNvbnN0IGlucHV0Q2hhbmdlcyA9IGF3YWl0IGhvb2tzLnRyYW5zZm9ybUlucHV0Py4oeyBwYXlsb2FkczogWy4uLnBheWxvYWRzXSB9KTtcblx0XHRpZiAoaW5wdXRDaGFuZ2VzPy5wYXlsb2FkcykgcGF5bG9hZHMgPSBbLi4uaW5wdXRDaGFuZ2VzLnBheWxvYWRzXTtcblx0XHRwYXlsb2FkcyA9IHBheWxvYWRzLm1hcCgocCkgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4ucCxcblx0XHRcdFx0aWQ6IHAuaWQsXG5cdFx0XHRcdHRzOiBwLnRzIHx8IG5vd01pbGxpcyxcblx0XHRcdFx0ZGF0YTogcC5kYXRhIHx8IHt9XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdGNvbnN0IGFwcGx5SG9va1RvT3V0cHV0ID0gYXN5bmMgKGFyZykgPT4ge1xuXHRcdFx0Y29uc3QgaG9va091dHB1dCA9IGF3YWl0IGhvb2tzLnRyYW5zZm9ybU91dHB1dD8uKGFyZyk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQuLi5hcmcucmVzdWx0LFxuXHRcdFx0XHQuLi5ob29rT3V0cHV0Py5yZXN1bHRcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvKipcblx0XHQqIEl0IGNhbiBiZSB2YWxpZCBmb3IgYSB1c2VyIHRvIHNlbmQgYW4gZW1wdHkgbGlzdCBvZiBldmVudHM7IGlmIHRoaXNcblx0XHQqIGhhcHBlbnMsIHNob3cgYSB3YXJuaW5nIHRoYXQgdGhpcyBtYXkgbm90IGJlIGludGVuZGVkLCBidXQgZG9uJ3QgdGhyb3cuXG5cdFx0Ki9cblx0XHRpZiAoIXBheWxvYWRzLmxlbmd0aCkge1xuXHRcdFx0Y29uc29sZS53YXJuKHByZXR0eUVycm9yKHtcblx0XHRcdFx0dHlwZTogXCJ3YXJuXCIsXG5cdFx0XHRcdHdoYXRIYXBwZW5lZDogXCJgaW5uZ2VzdC5zZW5kKClgIGNhbGxlZCB3aXRoIG5vIGV2ZW50c1wiLFxuXHRcdFx0XHRyZWFzc3VyYW5jZTogXCJUaGlzIGlzIG5vdCBhbiBlcnJvciwgYnV0IHlvdSBtYXkgbm90IGhhdmUgaW50ZW5kZWQgdG8gZG8gdGhpcy5cIixcblx0XHRcdFx0Y29uc2VxdWVuY2VzOiBcIlRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSwgYnV0IG5vIGV2ZW50cyBoYXZlIGJlZW4gc2VudCB0byBJbm5nZXN0LlwiLFxuXHRcdFx0XHRzdGFjazogdHJ1ZVxuXHRcdFx0fSkpO1xuXHRcdFx0cmV0dXJuIGF3YWl0IGFwcGx5SG9va1RvT3V0cHV0KHsgcmVzdWx0OiB7IGlkczogW10gfSB9KTtcblx0XHR9XG5cdFx0bGV0IHVybCA9IHRoaXMuc2VuZEV2ZW50VXJsLmhyZWY7XG5cdFx0LyoqXG5cdFx0KiBJZiBpbiBwcm9kIG1vZGUgYW5kIGtleSBpcyBub3QgcHJlc2VudCwgZmFpbCBub3cuXG5cdFx0Ki9cblx0XHRpZiAodGhpcy5tb2RlLmlzQ2xvdWQgJiYgIXRoaXMuZXZlbnRLZXlTZXQoKSkgdGhyb3cgbmV3IEVycm9yKHByZXR0eUVycm9yKHtcblx0XHRcdHdoYXRIYXBwZW5lZDogXCJGYWlsZWQgdG8gc2VuZCBldmVudFwiLFxuXHRcdFx0Y29uc2VxdWVuY2VzOiBcIllvdXIgZXZlbnQgb3IgZXZlbnRzIHdlcmUgbm90IHNlbnQgdG8gSW5uZ2VzdC5cIixcblx0XHRcdHdoeTogXCJXZSBjb3VsZG4ndCBmaW5kIGFuIGV2ZW50IGtleSB0byB1c2UgdG8gc2VuZCBldmVudHMgdG8gSW5uZ2VzdC5cIixcblx0XHRcdHRvRml4Tm93OiBmaXhFdmVudEtleU1pc3NpbmdTdGVwc1xuXHRcdH0pKTtcblx0XHQvKipcblx0XHQqIElmIGRldiBtb2RlIGhhcyBiZWVuIGluZmVycmVkLCB0cnkgdG8gaGl0IHRoZSBkZXYgc2VydmVyIGZpcnN0IHRvIHNlZSBpZlxuXHRcdCogaXQgZXhpc3RzLiBJZiBpdCBkb2VzLCB1c2UgaXQsIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gd2hhdGV2ZXIgc2VydmVyIHdlXG5cdFx0KiBoYXZlIGNvbmZpZ3VyZWQuXG5cdFx0KlxuXHRcdCogYElOTkdFU1RfQkFTRV9VUkxgIGlzIHVzZWQgdG8gc2V0IGJvdGggZGV2IHNlcnZlciBhbmQgcHJvZCBVUkxzLCBzbyBpZiBhXG5cdFx0KiB1c2VyIGhhcyBzZXQgdGhpcyBpdCBtZWFucyB0aGV5IGhhdmUgYWxyZWFkeSBjaG9zZW4gYSBVUkwgdG8gaGl0LlxuXHRcdCovXG5cdFx0aWYgKHRoaXMubW9kZS5pc0RldiAmJiB0aGlzLm1vZGUuaXNJbmZlcnJlZCAmJiAhdGhpcy5ldmVudEJhc2VVcmwpIHtcblx0XHRcdGlmIChhd2FpdCBkZXZTZXJ2ZXJBdmFpbGFibGUoZGVmYXVsdERldlNlcnZlckhvc3QsIHRoaXMuZmV0Y2gpKSB1cmwgPSBkZXZTZXJ2ZXJVcmwoZGVmYXVsdERldlNlcnZlckhvc3QsIGBlLyR7dGhpcy5ldmVudEtleX1gKS5ocmVmO1xuXHRcdH1cblx0XHRyZXR1cm4gYXdhaXQgYXBwbHlIb29rVG9PdXRwdXQoeyByZXN1bHQ6IHsgaWRzOiAoYXdhaXQgcmV0cnlXaXRoQmFja29mZihhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQgcmF3Qm9keTtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHVybCwge1xuXHRcdFx0XHRtZXRob2Q6IFwiUE9TVFwiLFxuXHRcdFx0XHRib2R5OiBzdHJpbmdpZnkocGF5bG9hZHMpLFxuXHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0Li4udGhpcy5oZWFkZXJzLFxuXHRcdFx0XHRcdC4uLmhlYWRlcnNcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyYXdCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0XHRib2R5ID0gYXdhaXQgc2VuZEV2ZW50UmVzcG9uc2VTY2hlbWEucGFyc2VBc3luYyhyYXdCb2R5KTtcblx0XHRcdH0gY2F0Y2ggKF9lcnIpIHtcblx0XHRcdFx0dGhyb3cgYXdhaXQgdGhpcy5nZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCByYXdCb2R5KTtcblx0XHRcdH1cblx0XHRcdGlmIChib2R5LnN0YXR1cyAhPT0gMjAwIHx8IGJvZHkuZXJyb3IpIHRocm93IGF3YWl0IHRoaXMuZ2V0UmVzcG9uc2VFcnJvcihyZXNwb25zZSwgcmF3Qm9keSwgYm9keS5lcnJvcik7XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9LCB7XG5cdFx0XHRtYXhBdHRlbXB0cyxcblx0XHRcdGJhc2VEZWxheTogMTAwXG5cdFx0fSkpLmlkcyB9IH0pO1xuXHR9XG5cdGNyZWF0ZUZ1bmN0aW9uID0gKHJhd09wdGlvbnMsIHJhd1RyaWdnZXIsIGhhbmRsZXIpID0+IHtcblx0XHRjb25zdCBmbiA9IHRoaXMuX2NyZWF0ZUZ1bmN0aW9uKHJhd09wdGlvbnMsIHJhd1RyaWdnZXIsIGhhbmRsZXIpO1xuXHRcdHRoaXMubG9jYWxGbnMucHVzaChmbik7XG5cdFx0cmV0dXJuIGZuO1xuXHR9O1xuXHRnZXQgZnVuY3MoKSB7XG5cdFx0cmV0dXJuIHRoaXMubG9jYWxGbnM7XG5cdH1cblx0X2NyZWF0ZUZ1bmN0aW9uID0gKHJhd09wdGlvbnMsIHJhd1RyaWdnZXIsIGhhbmRsZXIpID0+IHtcblx0XHRjb25zdCBvcHRpb25zID0gdGhpcy5zYW5pdGl6ZU9wdGlvbnMocmF3T3B0aW9ucyk7XG5cdFx0Y29uc3QgdHJpZ2dlcnMgPSB0aGlzLnNhbml0aXplVHJpZ2dlcnMocmF3VHJpZ2dlcik7XG5cdFx0cmV0dXJuIG5ldyBJbm5nZXN0RnVuY3Rpb24odGhpcywge1xuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdHRyaWdnZXJzXG5cdFx0fSwgaGFuZGxlcik7XG5cdH07XG5cdC8qKlxuXHQqIFJ1bnRpbWUtb25seSB2YWxpZGF0aW9uLlxuXHQqL1xuXHRzYW5pdGl6ZU9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmIChPYmplY3QuaGFzT3duKG9wdGlvbnMsIFwiZm5zXCIpKSBjb25zb2xlLndhcm4oYCR7bG9nUHJlZml4fSBJbm5nZXN0RnVuY3Rpb246IFxcYGZuc1xcYCBvcHRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiB2MzsgdXNlIFxcYG1pZGRsZXdhcmVcXGAgaW5zdGVhZC4gU2VlIGh0dHBzOi8vd3d3Lmlubmdlc3QuY29tL2RvY3Mvc2RrL21pZ3JhdGlvbmApO1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKGAke2xvZ1ByZWZpeH0gSW5uZ2VzdEZ1bmN0aW9uOiBDcmVhdGluZyBhIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBhc3MgYW4gb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcblx0XHRcdHJldHVybiB7IGlkOiBvcHRpb25zIH07XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cdC8qKlxuXHQqIFJ1bnRpbWUtb25seSB2YWxpZGF0aW9uLlxuXHQqL1xuXHRzYW5pdGl6ZVRyaWdnZXJzKHRyaWdnZXJzKSB7XG5cdFx0aWYgKHR5cGVvZiB0cmlnZ2VycyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKGAke2xvZ1ByZWZpeH0gSW5uZ2VzdEZ1bmN0aW9uOiBDcmVhdGluZyBhIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBoYXMgYmVlbiBkZXByZWNhdGVkIGluIHYzOyBwYXNzIGFuIG9iamVjdCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG5cdFx0XHRyZXR1cm4gW3sgZXZlbnQ6IHRyaWdnZXJzIH1dO1xuXHRcdH1cblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSByZXR1cm4gW3RyaWdnZXJzXTtcblx0XHRyZXR1cm4gdHJpZ2dlcnM7XG5cdH1cbn07XG4vKipcbiogRGVmYXVsdCBtaWRkbGV3YXJlIHRoYXQgaXMgaW5jbHVkZWQgaW4gZXZlcnkgY2xpZW50LCBwbGFjZWQgYWZ0ZXIgdGhlIHVzZXInc1xuKiBtaWRkbGV3YXJlIG9uIHRoZSBjbGllbnQgYnV0IGJlZm9yZSBmdW5jdGlvbi1sZXZlbCBtaWRkbGV3YXJlLlxuKlxuKiBJdCBpcyBkZWZpbmVkIGhlcmUgdG8gZW5zdXJlIHRoYXQgY29tbWVudHMgYXJlIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgVFNcbiogZGVmaW5pdGlvbnMuIFdpdGhvdXQgdGhpcywgd2UgaW5mZXIgdGhlIHN0YWNrIG9mIGJ1aWx0LWluIG1pZGRsZXdhcmUgd2l0aG91dFxuKiBjb21tZW50cywgbG9zaW5nIGEgbG90IG9mIHZhbHVlLlxuKlxuKiBJZiB0aGlzIGlzIG1vdmVkLCBwbGVhc2UgZW5zdXJlIHRoYXQgdXNpbmcgdGhpcyBwYWNrYWdlIGluIGFub3RoZXIgcHJvamVjdFxuKiBjYW4gY29ycmVjdGx5IGFjY2VzcyBjb21tZW50cyBvbiBtdXRhdGVkIGlucHV0IGFuZCBvdXRwdXQuXG4qXG4qIFRoaXMgcmV0dXJuIHBhdHRlcm4gbWltaWNzIHRoZSBvdXRwdXQgb2YgYSBgc2F0aXNmaWVzYCBzdWZmaXg7IGl0J3MgdXNlZCBhc1xuKiB3ZSBzdXBwb3J0IHZlcnNpb25zIG9mIFR5cGVTY3JpcHQgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZiBgc2F0aXNmaWVzYC5cbiovXG5jb25zdCBidWlsdEluTWlkZGxld2FyZSA9ICgobSkgPT4gbSkoW25ldyBJbm5nZXN0TWlkZGxld2FyZSh7XG5cdG5hbWU6IFwiSW5uZ2VzdDogTG9nZ2VyXCIsXG5cdGluaXQoeyBjbGllbnQgfSkge1xuXHRcdHJldHVybiB7IG9uRnVuY3Rpb25SdW4oYXJnKSB7XG5cdFx0XHRjb25zdCB7IGN0eCB9ID0gYXJnO1xuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSB7XG5cdFx0XHRcdHJ1bklEOiBjdHgucnVuSWQsXG5cdFx0XHRcdGV2ZW50TmFtZTogY3R4LmV2ZW50Lm5hbWUsXG5cdFx0XHRcdGZ1bmN0aW9uTmFtZTogYXJnLmZuLm5hbWVcblx0XHRcdH07XG5cdFx0XHRsZXQgcHJvdmlkZWRMb2dnZXIgPSBjbGllbnRbXCJsb2dnZXJcIl07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoXCJjaGlsZFwiIGluIHByb3ZpZGVkTG9nZ2VyKSBwcm92aWRlZExvZ2dlciA9IHByb3ZpZGVkTG9nZ2VyLmNoaWxkKG1ldGFkYXRhKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGNyZWF0ZSBcXFwiY2hpbGRMb2dnZXJcXFwiIHdpdGggZXJyb3I6IFwiLCBlcnIpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbG9nZ2VyID0gbmV3IFByb3h5TG9nZ2VyKHByb3ZpZGVkTG9nZ2VyKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRyYW5zZm9ybUlucHV0KCkge1xuXHRcdFx0XHRcdHJldHVybiB7IGN0eDogeyBsb2dnZXIgfSB9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRiZWZvcmVFeGVjdXRpb24oKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmVuYWJsZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0cmFuc2Zvcm1PdXRwdXQoeyByZXN1bHQ6IHsgZXJyb3IgfSB9KSB7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhc3luYyBiZWZvcmVSZXNwb25zZSgpIHtcblx0XHRcdFx0XHRhd2FpdCBsb2dnZXIuZmx1c2goKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IH07XG5cdH1cbn0pXSk7XG4oZnVuY3Rpb24oX0lubmdlc3QpIHtcblx0X0lubmdlc3QuVGFnID0gXCJJbm5nZXN0LkFwcFwiO1xufSkoSW5uZ2VzdCB8fCAoSW5uZ2VzdCA9IHt9KSk7XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgSW5uZ2VzdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdC5qcy5tYXAiXSwibmFtZXMiOlsiZGVmYXVsdERldlNlcnZlckhvc3QiLCJkZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwiLCJkZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCIsImR1bW15RXZlbnRLZXkiLCJlbnZLZXlzIiwiaGVhZGVyS2V5cyIsImxvZ1ByZWZpeCIsInNlbmRFdmVudFJlc3BvbnNlU2NoZW1hIiwiZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMiLCJwcmV0dHlFcnJvciIsIklubmdlc3RNaWRkbGV3YXJlIiwiZ2V0SG9va1N0YWNrIiwic3RyaW5naWZ5IiwiYWxsUHJvY2Vzc0VudiIsImdldEZldGNoIiwiZ2V0TW9kZSIsImlubmdlc3RIZWFkZXJzIiwicHJvY2Vzc0VudiIsImRldlNlcnZlckF2YWlsYWJsZSIsImRldlNlcnZlclVybCIsInJldHJ5V2l0aEJhY2tvZmYiLCJJbm5nZXN0RnVuY3Rpb24iLCJJbm5nZXN0QXBpIiwiY3JlYXRlRW50cm9weSIsIkRlZmF1bHRMb2dnZXIiLCJQcm94eUxvZ2dlciIsIklubmdlc3QiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIlRhZyIsImFwaUJhc2VVcmwiLCJfYXBpQmFzZVVybCIsImV2ZW50QmFzZVVybCIsIl9ldmVudEJhc2VVcmwiLCJlbnYiLCJoZWFkZXJzIiwiRW52aXJvbm1lbnQiLCJhcHBWZXJzaW9uIiwiX2FwcFZlcnNpb24iLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJldmVudEtleSIsInNlbmRFdmVudFVybCIsIlVSTCIsImxvY2FsRm5zIiwiY3JlYXRlRnVuY3Rpb24iLCJyYXdPcHRpb25zIiwicmF3VHJpZ2dlciIsImhhbmRsZXIiLCJmbiIsIl9jcmVhdGVGdW5jdGlvbiIsInB1c2giLCJzYW5pdGl6ZU9wdGlvbnMiLCJ0cmlnZ2VycyIsInNhbml0aXplVHJpZ2dlcnMiLCJpZCIsImZldGNoIiwibG9nZ2VyIiwibWlkZGxld2FyZSIsImlzRGV2Iiwic2NoZW1hcyIsIkVycm9yIiwiX21vZGUiLCJleHBsaWNpdE1vZGUiLCJpbm5nZXN0QXBpIiwiYmFzZVVybCIsInNpZ25pbmdLZXkiLCJJbm5nZXN0U2lnbmluZ0tleSIsInNpZ25pbmdLZXlGYWxsYmFjayIsIklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2siLCJtb2RlIiwibG9hZE1vZGVFbnZWYXJzIiwiaW5pdGlhbGl6ZU1pZGRsZXdhcmUiLCJidWlsdEluTWlkZGxld2FyZSIsInJlYWR5IiwidGhlbiIsInNldEVudlZhcnMiLCJjbGllbnQiLCJJbm5nZXN0QXBpQmFzZVVybCIsIklubmdlc3RCYXNlVXJsIiwiZ2V0RXhwbGljaXRVcmwiLCJJbm5nZXN0RXZlbnRBcGlCYXNlVXJsIiwic2V0RXZlbnRLZXkiLCJJbm5nZXN0RXZlbnRLZXkiLCJpbm5nZXN0RW52Iiwib3B0cyIsInByZWZpeCIsInByZWZpeFN0YWNrIiwic3RhY2siLCJyZWR1Y2UiLCJhY2MiLCJtIiwicHJldiIsIm5leHQiLCJpbml0IiwicmVnaXN0ZXJJbnB1dCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0UmVzcG9uc2VFcnJvciIsInJlc3BvbnNlIiwicmF3Qm9keSIsImZvdW5kRXJyIiwiZXJyb3JNZXNzYWdlIiwic3RhdHVzIiwiSlNPTiIsInRleHQiLCJfZXJyIiwiZXZlbnRLZXlTZXQiLCJCb29sZWFuIiwic2VuZFNpZ25hbCIsInNpZ25hbCIsImRhdGEiLCJfc2VuZFNpZ25hbCIsInJlcyIsIm9rIiwidmFsdWUiLCJlcnJvciIsInNlbmQiLCJwYXlsb2FkIiwiX3NlbmQiLCJub3dNaWxsaXMiLCJEYXRlIiwiZ2V0VGltZSIsIm1heEF0dGVtcHRzIiwiZW50cm9weSIsImVudHJvcHlCYXNlNjQiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJFdmVudElkU2VlZCIsImVyciIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiZGVidWciLCJob29rcyIsInRyYW5zZm9ybUlucHV0Iiwib3V0cHV0IiwidHJhbnNmb3JtT3V0cHV0IiwicmVzdWx0IiwicGF5bG9hZHMiLCJBcnJheSIsImlzQXJyYXkiLCJpbnB1dENoYW5nZXMiLCJtYXAiLCJwIiwidHMiLCJhcHBseUhvb2tUb091dHB1dCIsImFyZyIsImhvb2tPdXRwdXQiLCJsZW5ndGgiLCJ3YXJuIiwidHlwZSIsIndoYXRIYXBwZW5lZCIsInJlYXNzdXJhbmNlIiwiY29uc2VxdWVuY2VzIiwiaWRzIiwidXJsIiwiaHJlZiIsImlzQ2xvdWQiLCJ3aHkiLCJ0b0ZpeE5vdyIsImlzSW5mZXJyZWQiLCJib2R5IiwibWV0aG9kIiwianNvbiIsInBhcnNlQXN5bmMiLCJiYXNlRGVsYXkiLCJmdW5jcyIsIk9iamVjdCIsImhhc093biIsImV2ZW50IiwibmFtZSIsIm9uRnVuY3Rpb25SdW4iLCJjdHgiLCJtZXRhZGF0YSIsInJ1bklEIiwicnVuSWQiLCJldmVudE5hbWUiLCJmdW5jdGlvbk5hbWUiLCJwcm92aWRlZExvZ2dlciIsImNoaWxkIiwiYmVmb3JlRXhlY3V0aW9uIiwiZW5hYmxlIiwiYmVmb3JlUmVzcG9uc2UiLCJmbHVzaCIsIl9Jbm5nZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Inngest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestCommHandler.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/components/InngestCommHandler.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InngestCommHandler: () => (/* binding */ InngestCommHandler)\n/* harmony export */ });\n/* harmony import */ var _execution_als_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var _helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/* harmony import */ var _helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/* harmony import */ var _helpers_env_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/* harmony import */ var _helpers_devserver_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\n/* harmony import */ var _helpers_enum_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../helpers/enum.js */ \"(rsc)/./node_modules/inngest/helpers/enum.js\");\n/* harmony import */ var _helpers_net_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\n/* harmony import */ var _helpers_promises_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/* harmony import */ var _helpers_ServerTiming_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/ServerTiming.js */ \"(rsc)/./node_modules/inngest/helpers/ServerTiming.js\");\n/* harmony import */ var _helpers_stream_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../helpers/stream.js */ \"(rsc)/./node_modules/inngest/helpers/stream.js\");\n/* harmony import */ var _InngestFunction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\n/* harmony import */ var _execution_v1_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./execution/v1.js */ \"(rsc)/./node_modules/inngest/components/execution/v1.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var ulid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ulid */ \"(rsc)/./node_modules/ulid/dist/index.esm.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//#region src/components/InngestCommHandler.ts\n/**\n* A schema for the response from Inngest when registering.\n*/ const registerResSchema = zod_v3__WEBPACK_IMPORTED_MODULE_2__.object({\n    status: zod_v3__WEBPACK_IMPORTED_MODULE_2__.number().default(200),\n    skipped: zod_v3__WEBPACK_IMPORTED_MODULE_2__.boolean().optional().default(false),\n    modified: zod_v3__WEBPACK_IMPORTED_MODULE_2__.boolean().optional().default(false),\n    error: zod_v3__WEBPACK_IMPORTED_MODULE_2__.string().default(\"Successfully registered\")\n});\n/**\n* `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n* Inngest's tooling such as the dev server or CLI) and taking appropriate\n* action for any served functions.\n*\n* All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n* this class; the exposed `serve` function will - most commonly - create an\n* instance of `InngestCommHandler` and then return `instance.createHandler()`.\n*\n* See individual parameter details for more information, or see the\n* source code for an existing handler, e.g.\n* {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n*\n* @example\n* ```\n* // my-custom-handler.ts\n* import {\n*   InngestCommHandler,\n*   type ServeHandlerOptions,\n* } from \"./components/InngestCommHandler\";\n*\n* export const serve = (options: ServeHandlerOptions) => {\n*   const handler = new InngestCommHandler({\n*     frameworkName: \"my-custom-handler\",\n*     ...options,\n*     handler: (req: Request) => {\n*       return {\n*         body: () => req.json(),\n*         headers: (key) => req.headers.get(key),\n*         method: () => req.method,\n*         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n*         transformResponse: ({ body, status, headers }) => {\n*           return new Response(body, { status, headers });\n*         },\n*       };\n*     },\n*   });\n*\n*   return handler.createHandler();\n* };\n* ```\n*\n* @public\n*/ var InngestCommHandler = class {\n    constructor(options){\n        /**\n\t* A private collection of functions that are being served. This map is used\n\t* to find and register functions when interacting with Inngest Cloud.\n\t*/ this.fns = {};\n        this.env = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.allProcessEnv)();\n        this._options = options;\n        /**\n\t\t* v2 -> v3 migration error.\n\t\t*\n\t\t* If a serve handler is passed a client as the first argument, it'll be\n\t\t* spread in to these options. We should be able to detect this by picking\n\t\t* up a unique property on the object.\n\t\t*/ if (Object.hasOwn(options, \"eventKey\")) throw new Error(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);\n        this.frameworkName = options.frameworkName;\n        this.client = options.client;\n        if (options.id) console.warn(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`);\n        this.id = options.id || this.client.id;\n        this.handler = options.handler;\n        /**\n\t\t* Provide a hidden option to allow expired signatures to be accepted during\n\t\t* testing.\n\t\t*/ this.allowExpiredSignatures = Boolean(arguments[\"0\"]?.__testingAllowExpiredSignatures);\n        this.rawFns = options.functions?.filter(Boolean) ?? [];\n        if (this.rawFns.length !== (options.functions ?? []).length) console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);\n        this.fns = this.rawFns.reduce((acc, fn)=>{\n            const configs = fn[\"getConfig\"]({\n                baseUrl: new URL(\"https://example.com\"),\n                appPrefix: this.id\n            });\n            const fns = configs.reduce((acc$1, { id }, index)=>{\n                return {\n                    ...acc$1,\n                    [id]: {\n                        fn,\n                        onFailure: Boolean(index)\n                    }\n                };\n            }, {});\n            configs.forEach(({ id })=>{\n                if (acc[id]) throw new Error(`Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`);\n            });\n            return {\n                ...acc,\n                ...fns\n            };\n        }, {});\n        this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n        this.signingKey = options.signingKey;\n        this.signingKeyFallback = options.signingKeyFallback;\n        this._serveHost = options.serveHost || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestServeHost];\n        this._servePath = options.servePath || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestServePath];\n        this.skipSignatureValidation = options.skipSignatureValidation || false;\n        const defaultLogLevel = \"info\";\n        this.logLevel = zod_v3__WEBPACK_IMPORTED_MODULE_2__[\"enum\"](_types_js__WEBPACK_IMPORTED_MODULE_5__.logLevels).default(defaultLogLevel).catch((ctx)=>{\n            this.log(\"warn\", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);\n            return defaultLogLevel;\n        }).parse(options.logLevel || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestLogLevel]);\n        if (this.logLevel === \"debug\") {\n            /**\n\t\t\t* `debug` is an old library; sometimes its runtime detection doesn't work\n\t\t\t* for newer pairings of framework/runtime.\n\t\t\t*\n\t\t\t* One silly symptom of this is that `Debug()` returns an anonymous\n\t\t\t* function with no extra properties instead of a `Debugger` instance if\n\t\t\t* the wrong code is consumed following a bad detection. This results in\n\t\t\t* the following `.enable()` call failing, so we just try carefully to\n\t\t\t* enable it here.\n\t\t\t*/ if (debug__WEBPACK_IMPORTED_MODULE_0__.enable && typeof debug__WEBPACK_IMPORTED_MODULE_0__.enable === \"function\") debug__WEBPACK_IMPORTED_MODULE_0__.enable(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.debugPrefix}:*`);\n        }\n        const defaultStreamingOption = false;\n        this.streaming = zod_v3__WEBPACK_IMPORTED_MODULE_2__.union([\n            zod_v3__WEBPACK_IMPORTED_MODULE_2__[\"enum\"]([\n                \"allow\",\n                \"force\"\n            ]),\n            zod_v3__WEBPACK_IMPORTED_MODULE_2__.literal(false)\n        ]).default(defaultStreamingOption).catch((ctx)=>{\n            this.log(\"warn\", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);\n            return defaultStreamingOption;\n        }).parse(options.streaming || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestStreaming]);\n        this.fetch = options.fetch ? (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.getFetch)(options.fetch) : this.client[\"fetch\"];\n    }\n    /**\n\t* Get the API base URL for the Inngest API.\n\t*\n\t* This is a getter to encourage checking the environment for the API base URL\n\t* each time it's accessed, as it may change during execution.\n\t*/ get apiBaseUrl() {\n        return this._options.baseUrl || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestApiBaseUrl] || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestBaseUrl] || this.client.apiBaseUrl || _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.defaultInngestApiBaseUrl;\n    }\n    /**\n\t* Get the event API base URL for the Inngest API.\n\t*\n\t* This is a getter to encourage checking the environment for the event API\n\t* base URL each time it's accessed, as it may change during execution.\n\t*/ get eventApiBaseUrl() {\n        return this._options.baseUrl || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestEventApiBaseUrl] || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestBaseUrl] || this.client.eventBaseUrl || _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.defaultInngestEventBaseUrl;\n    }\n    /**\n\t* The host used to access the Inngest serve endpoint, e.g.:\n\t*\n\t*     \"https://myapp.com\"\n\t*\n\t* By default, the library will try to infer this using request details such\n\t* as the \"Host\" header and request path, but sometimes this isn't possible\n\t* (e.g. when running in a more controlled environments such as AWS Lambda or\n\t* when dealing with proxies/redirects).\n\t*\n\t* Provide the custom hostname here to ensure that the path is reported\n\t* correctly when registering functions with Inngest.\n\t*\n\t* To also provide a custom path, use `servePath`.\n\t*/ get serveHost() {\n        return this._serveHost || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestServeHost];\n    }\n    /**\n\t* The path to the Inngest serve endpoint. e.g.:\n\t*\n\t*     \"/some/long/path/to/inngest/endpoint\"\n\t*\n\t* By default, the library will try to infer this using request details such\n\t* as the \"Host\" header and request path, but sometimes this isn't possible\n\t* (e.g. when running in a more controlled environments such as AWS Lambda or\n\t* when dealing with proxies/redirects).\n\t*\n\t* Provide the custom path (excluding the hostname) here to ensure that the\n\t* path is reported correctly when registering functions with Inngest.\n\t*\n\t* To also provide a custom hostname, use `serveHost`.\n\t*\n\t* This is a getter to encourage checking the environment for the serve path\n\t* each time it's accessed, as it may change during execution.\n\t*/ get servePath() {\n        return this._servePath || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestServePath];\n    }\n    get hashedEventKey() {\n        if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.dummyEventKey) return;\n        return (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.hashEventKey)(this.client[\"eventKey\"]);\n    }\n    get hashedSigningKey() {\n        if (!this.signingKey) return;\n        return (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.hashSigningKey)(this.signingKey);\n    }\n    get hashedSigningKeyFallback() {\n        if (!this.signingKeyFallback) return;\n        return (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.hashSigningKey)(this.signingKeyFallback);\n    }\n    /**\n\t* Returns a `boolean` representing whether this handler will stream responses\n\t* or not. Takes into account the user's preference and the platform's\n\t* capabilities.\n\t*/ async shouldStream(actions) {\n        if (await actions.queryStringWithDefaults(\"testing for probe\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.queryKeys.Probe) !== void 0) return false;\n        if (!actions.transformStreamingResponse) return false;\n        if (this.streaming === \"force\") return true;\n        return this.streaming === \"allow\" && (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.platformSupportsStreaming)(this.frameworkName, this.env);\n    }\n    async isInngestReq(actions) {\n        const reqMessage = `checking if this is an Inngest request`;\n        const [runId, signature] = await Promise.all([\n            actions.headers(reqMessage, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestRunId),\n            actions.headers(reqMessage, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Signature)\n        ]);\n        return Boolean(runId && typeof signature === \"string\");\n    }\n    /**\n\t* Start handling a request, setting up environments, modes, and returning\n\t* some helpers.\n\t*/ async initRequest(...args) {\n        const timer = new _helpers_ServerTiming_js__WEBPACK_IMPORTED_MODULE_7__.ServerTiming();\n        const actions = await this.getActions(timer, ...args);\n        const [env, expectedServerKind] = await Promise.all([\n            actions.env?.(\"starting to handle request\"),\n            actions.headers(\"checking expected server kind\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestServerKind)\n        ]);\n        this.env = {\n            ...(0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.allProcessEnv)(),\n            ...env\n        };\n        const headerPromises = _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.forwardedHeaders.map(async (header)=>{\n            return {\n                header,\n                value: await actions.headers(`fetching ${header} for forwarding`, header)\n            };\n        });\n        const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders)=>{\n            return fetchedHeaders.reduce((acc, { header, value })=>{\n                if (value) acc[header] = value;\n                return acc;\n            }, {});\n        });\n        const getHeaders = async ()=>({\n                ...(0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.inngestHeaders)({\n                    env: this.env,\n                    framework: this.frameworkName,\n                    client: this.client,\n                    expectedServerKind: expectedServerKind || void 0,\n                    extras: {\n                        \"Server-Timing\": timer.getHeader()\n                    }\n                }),\n                ...await headersToForwardP\n            });\n        const assumedMode = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.getMode)({\n            env: this.env,\n            client: this.client\n        });\n        if (assumedMode.isExplicit) this._mode = assumedMode;\n        else {\n            const serveIsProd = await actions.isProduction?.(\"starting to handle request\");\n            if (typeof serveIsProd === \"boolean\") this._mode = new _helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.Mode({\n                type: serveIsProd ? \"cloud\" : \"dev\",\n                isExplicit: false\n            });\n            else this._mode = assumedMode;\n        }\n        this.upsertKeysFromEnv();\n        return {\n            timer,\n            actions,\n            getHeaders\n        };\n    }\n    /**\n\t* `createSyncHandler` should be used to return a type-equivalent version of\n\t* the `handler` specified during instantiation.\n\t*/ createSyncHandler() {\n        return (handler)=>{\n            return this.wrapHandler(async (...args)=>{\n                const reqInit = await this.initRequest(...args);\n                const fn = new _InngestFunction_js__WEBPACK_IMPORTED_MODULE_8__.InngestFunction(this.client, {\n                    id: this._options.syncOptions?.functionId ?? \"\",\n                    retries: this._options.syncOptions?.retries ?? _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.defaultMaxRetries\n                }, ()=>handler(...args));\n                if (await this.isInngestReq(reqInit.actions)) return this.handleAsyncRequest({\n                    ...reqInit,\n                    forceExecution: true,\n                    args,\n                    fns: [\n                        fn\n                    ]\n                });\n                return this.handleSyncRequest({\n                    ...reqInit,\n                    args,\n                    asyncMode: this._options.syncOptions?.asyncResponse ?? _types_js__WEBPACK_IMPORTED_MODULE_5__.AsyncResponseType.Redirect,\n                    fn\n                });\n            });\n        };\n    }\n    /**\n\t* `createHandler` should be used to return a type-equivalent version of the\n\t* `handler` specified during instantiation.\n\t*\n\t* @example\n\t* ```\n\t* // my-custom-handler.ts\n\t* import {\n\t*   InngestCommHandler,\n\t*   type ServeHandlerOptions,\n\t* } from \"./components/InngestCommHandler\";\n\t*\n\t* export const serve = (options: ServeHandlerOptions) => {\n\t*   const handler = new InngestCommHandler({\n\t*     frameworkName: \"my-custom-handler\",\n\t*     ...options,\n\t*     handler: (req: Request) => {\n\t*       return {\n\t*         body: () => req.json(),\n\t*         headers: (key) => req.headers.get(key),\n\t*         method: () => req.method,\n\t*         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n\t*         transformResponse: ({ body, status, headers }) => {\n\t*           return new Response(body, { status, headers });\n\t*         },\n\t*       };\n\t*     },\n\t*   });\n\t*\n\t*   return handler.createHandler();\n\t* };\n\t* ```\n\t*/ createHandler() {\n        return this.wrapHandler(async (...args)=>{\n            return this.handleAsyncRequest({\n                ...await this.initRequest(...args),\n                args\n            });\n        });\n    }\n    /**\n\t* Given a set of actions that let us access the incoming request, create a\n\t* `http/run.started` event that repesents a run starting from an HTTP\n\t* request.\n\t*/ async createHttpEvent(actions, fn) {\n        const reason = \"creating sync event\";\n        const contentTypePromise = actions.headers(reason, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.ContentType).then((v)=>v ?? \"\");\n        const ipPromise = actions.headers(reason, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.ForwardedFor).then((v)=>{\n            if (v) return v;\n            return actions.headers(reason, _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.RealIp).then((v$1)=>v$1 ?? \"\");\n        });\n        const methodPromise = actions.method(reason);\n        const urlPromise = actions.url(reason).then((v)=>this.reqUrl(v));\n        const domainPromise = urlPromise.then((url)=>`${url.protocol}//${url.host}`);\n        const pathPromise = urlPromise.then((url)=>url.pathname);\n        const queryParamsPromise = urlPromise.then((url)=>url.searchParams.toString());\n        const bodyPromise = actions.textBody(reason).then((body$1)=>{\n            return typeof body$1 === \"string\" ? body$1 : (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(body$1);\n        });\n        const [contentType, domain, ip, method, path, queryParams, body] = await Promise.all([\n            contentTypePromise,\n            domainPromise,\n            ipPromise,\n            methodPromise,\n            pathPromise,\n            queryParamsPromise,\n            bodyPromise\n        ]);\n        return {\n            name: \"http/run.started\",\n            data: {\n                content_type: contentType,\n                domain,\n                ip,\n                method,\n                path,\n                query_params: queryParams,\n                body,\n                fn: fn.id()\n            }\n        };\n    }\n    async handleSyncRequest({ timer, actions, fn, asyncMode, args }) {\n        if (!actions.experimentalTransformSyncResponse) throw new Error(\"This platform does not support synchronous Inngest function executions.\");\n        if (await (0,_execution_als_js__WEBPACK_IMPORTED_MODULE_9__.getAsyncCtx)()) throw new Error(\"We already seem to be in the context of an Inngest execution, but didn't expect to be. Did you already wrap this handler?\");\n        const runId = (0,ulid__WEBPACK_IMPORTED_MODULE_1__.ulid)();\n        const event = await this.createHttpEvent(actions, fn);\n        const exeVersion = _execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_10__.PREFERRED_EXECUTION_VERSION;\n        const result = await fn[\"createExecution\"]({\n            version: exeVersion,\n            partialOptions: {\n                client: this.client,\n                data: {\n                    runId,\n                    event,\n                    attempt: 0,\n                    events: [\n                        event\n                    ],\n                    maxAttempts: fn.opts.retries ?? _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.defaultMaxRetries\n                },\n                runId,\n                headers: {},\n                reqArgs: args,\n                stepCompletionOrder: [],\n                stepState: {},\n                disableImmediateExecution: false,\n                isFailureHandler: false,\n                timer,\n                createResponse: (data)=>actions.experimentalTransformSyncResponse(\"creating sync execution\", data).then((res)=>({\n                            ...res,\n                            version: exeVersion\n                        })),\n                stepMode: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Sync\n            }\n        }).start();\n        const resultHandler = {\n            \"step-not-found\": ()=>{\n                throw new Error(\"We should not get the result 'step-not-found' when checkpointing. This is a bug in the `inngest` SDK\");\n            },\n            \"steps-found\": ()=>{\n                throw new Error(\"We should not get the result 'steps-found' when checkpointing. This is a bug in the `inngest` SDK\");\n            },\n            \"step-ran\": ()=>{\n                throw new Error(\"We should not get the result 'step-ran' when checkpointing. This is a bug in the `inngest` SDK\");\n            },\n            \"function-rejected\": ()=>{\n                throw new Error(\"We should not get the result 'function-rejected' when checkpointing. This is a bug in the `inngest` SDK\");\n            },\n            \"function-resolved\": ({ data })=>{\n                return data;\n            },\n            \"change-mode\": async ({ token })=>{\n                switch(asyncMode){\n                    case _types_js__WEBPACK_IMPORTED_MODULE_5__.AsyncResponseType.Redirect:\n                        return actions.transformResponse(\"creating sync->async redirect response\", {\n                            status: 302,\n                            headers: {\n                                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Location]: await this.client[\"inngestApi\"][\"getTargetUrl\"](`/v1/http/runs/${runId}/output?token=${token}`).then((url)=>url.toString())\n                            },\n                            version: exeVersion,\n                            body: \"\"\n                        });\n                    case _types_js__WEBPACK_IMPORTED_MODULE_5__.AsyncResponseType.Token:\n                        return actions.transformResponse(\"creating sync->async token response\", {\n                            status: 200,\n                            headers: {},\n                            version: exeVersion,\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                                run_id: runId,\n                                token\n                            })\n                        });\n                    default:\n                        break;\n                }\n                throw new Error(\"Not implemented: change-mode\");\n            }\n        }[result.type];\n        if (!resultHandler) throw new Error(`No handler for execution result type: ${result.type}. This is a bug in the \\`inngest\\` SDK`);\n        return resultHandler(result);\n    }\n    async handleAsyncRequest({ timer, actions, args, getHeaders, forceExecution, fns }) {\n        if (forceExecution && !actions.experimentalTransformSyncResponse) throw new Error(\"This platform does not support async executions in Inngest for APIs.\");\n        const methodP = actions.method(\"starting to handle request\");\n        const contentLength = await actions.headers(\"checking signature for request\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.ContentLength).then((value)=>{\n            if (!value) return;\n            return Number.parseInt(value, 10);\n        });\n        const [signature, method, body] = await Promise.all([\n            actions.headers(\"checking signature for request\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Signature).then((headerSignature)=>{\n                return headerSignature ?? void 0;\n            }),\n            methodP,\n            methodP.then((method$1)=>{\n                if (method$1 === \"POST\" || method$1 === \"PUT\") {\n                    if (!contentLength) return \"\";\n                    return actions.body(`checking body for request signing as method is ${method$1}`);\n                }\n                return \"\";\n            })\n        ]);\n        const signatureValidation = this.validateSignature(signature, body);\n        const actionRes = timer.wrap(\"action\", ()=>this.handleAction({\n                actions,\n                timer,\n                getHeaders,\n                reqArgs: args,\n                signatureValidation,\n                body,\n                method,\n                forceExecution: Boolean(forceExecution),\n                fns\n            }));\n        /**\n\t\t* Prepares an action response by merging returned data to provide\n\t\t* trailing information such as `Server-Timing` headers.\n\t\t*\n\t\t* It should always prioritize the headers returned by the action, as they\n\t\t* may contain important information such as `Content-Type`.\n\t\t*/ const prepareActionRes = async (res)=>{\n            const headers = {\n                ...await getHeaders(),\n                ...res.headers,\n                ...res.version === null ? {} : {\n                    [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.RequestVersion]: (res.version ?? _execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_10__.PREFERRED_EXECUTION_VERSION).toString()\n                }\n            };\n            let signature$1;\n            try {\n                signature$1 = await signatureValidation.then((result)=>{\n                    if (!result.success || !result.keyUsed) return;\n                    return this.getResponseSignature(result.keyUsed, res.body);\n                });\n            } catch (err) {\n                return {\n                    ...res,\n                    headers,\n                    body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.serializeError)(err)),\n                    status: 500\n                };\n            }\n            if (signature$1) headers[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Signature] = signature$1;\n            return {\n                ...res,\n                headers\n            };\n        };\n        if (await this.shouldStream(actions)) {\n            if (await actions.method(\"starting streaming response\") === \"POST\") {\n                const { stream, finalize } = await (0,_helpers_stream_js__WEBPACK_IMPORTED_MODULE_12__.createStream)();\n                /**\n\t\t\t\t* Errors are handled by `handleAction` here to ensure that an\n\t\t\t\t* appropriate response is always given.\n\t\t\t\t*/ actionRes.then((res)=>{\n                    return finalize(prepareActionRes(res));\n                });\n                return timer.wrap(\"res\", async ()=>{\n                    return actions.transformStreamingResponse?.(\"starting streaming response\", {\n                        status: 201,\n                        headers: await getHeaders(),\n                        body: stream,\n                        version: null\n                    });\n                });\n            }\n        }\n        return timer.wrap(\"res\", async ()=>{\n            return actionRes.then(prepareActionRes).then((actionRes$1)=>{\n                return actions.transformResponse(\"sending back response\", actionRes$1);\n            });\n        });\n    }\n    async getActions(timer, ...args) {\n        /**\n\t\t* Used for testing, allow setting action overrides externally when\n\t\t* calling the handler. Always search the final argument.\n\t\t*/ const lastArg = args[args.length - 1];\n        const actionOverrides = typeof lastArg === \"object\" && lastArg !== null && \"actionOverrides\" in lastArg && typeof lastArg[\"actionOverrides\"] === \"object\" && lastArg[\"actionOverrides\"] !== null ? lastArg[\"actionOverrides\"] : {};\n        /**\n\t\t* We purposefully `await` the handler, as it could be either sync or\n\t\t* async.\n\t\t*/ const rawActions = {\n            ...await timer.wrap(\"handler\", ()=>this.handler(...args)).catch((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.rethrowError)(\"Serve handler failed to run\")),\n            ...actionOverrides\n        };\n        /**\n\t\t* Mapped promisified handlers from userland `serve()` function mixed in\n\t\t* with some helpers.\n\t\t*/ const actions = {\n            ...Object.entries(rawActions).reduce((acc, [key, value])=>{\n                if (typeof value !== \"function\") return acc;\n                return {\n                    ...acc,\n                    [key]: (reason, ...args$1)=>{\n                        const errMessage = [\n                            `Failed calling \\`${key}\\` from serve handler`,\n                            reason\n                        ].filter(Boolean).join(\" when \");\n                        const fn = ()=>value(...args$1);\n                        return (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_13__.runAsPromise)(fn).catch((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.rethrowError)(errMessage)).catch((err)=>{\n                            this.log(\"error\", err);\n                            throw err;\n                        });\n                    }\n                };\n            }, {}),\n            queryStringWithDefaults: async (reason, key)=>{\n                const url = await actions.url(reason);\n                return await actions.queryString?.(reason, key, url) || url.searchParams.get(key) || void 0;\n            },\n            ...actionOverrides\n        };\n        return actions;\n    }\n    wrapHandler(handler) {\n        /**\n\t\t* Some platforms check (at runtime) the length of the function being used\n\t\t* to handle an endpoint. If this is a variadic function, it will fail that\n\t\t* check.\n\t\t*\n\t\t* Therefore, we expect the arguments accepted to be the same length as the\n\t\t* `handler` function passed internally.\n\t\t*\n\t\t* We also set a name to avoid a common useless name in tracing such as\n\t\t* `\"anonymous\"` or `\"bound function\"`.\n\t\t*\n\t\t* https://github.com/getsentry/sentry-javascript/issues/3284\n\t\t*/ Object.defineProperties(handler, {\n            name: {\n                value: \"InngestHandler\"\n            },\n            length: {\n                value: this.handler.length\n            }\n        });\n        return handler;\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        if (m) this.client[\"mode\"] = m;\n    }\n    /**\n\t* Given a set of functions to check if an action is available from the\n\t* instance's handler, enact any action that is found.\n\t*\n\t* This method can fetch varying payloads of data, but ultimately is the place\n\t* where _decisions_ are made regarding functionality.\n\t*\n\t* For example, if we find that we should be viewing the UI, this function\n\t* will decide whether the UI should be visible based on the payload it has\n\t* found (e.g. env vars, options, etc).\n\t*/ async handleAction({ actions, timer, getHeaders, reqArgs, signatureValidation, body: rawBody, method, forceExecution, fns }) {\n        const isMissingBody = rawBody === void 0;\n        let body = rawBody;\n        try {\n            let url = await actions.url(\"starting to handle request\");\n            if (method === \"POST\" || forceExecution) {\n                if (!forceExecution && isMissingBody) {\n                    this.log(\"error\", \"Missing body when executing, possibly due to missing request body middleware\");\n                    return {\n                        status: 500,\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.serializeError)(/* @__PURE__ */ new Error(\"Missing request body when executing, possibly due to missing request body middleware\"))),\n                        version: void 0\n                    };\n                }\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) return {\n                    status: 401,\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.serializeError)(validationResult.err)),\n                    version: void 0\n                };\n                let fn;\n                let fnId;\n                let stepId;\n                if (forceExecution) {\n                    fn = fns?.length && fns[0] ? {\n                        fn: fns[0],\n                        onFailure: false\n                    } : Object.values(this.fns)[0];\n                    fnId = fn?.fn.id();\n                    stepId = \"step\";\n                    body = {\n                        event: {},\n                        events: [],\n                        steps: {},\n                        version: _execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_10__.PREFERRED_EXECUTION_VERSION,\n                        ctx: {\n                            attempt: 0,\n                            disable_immediate_execution: false,\n                            use_api: true,\n                            max_attempts: 3,\n                            run_id: await actions.headers(\"getting run ID for forced execution\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestRunId),\n                            stack: {\n                                stack: [],\n                                current: 0\n                            }\n                        }\n                    };\n                } else {\n                    const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.queryKeys.Probe);\n                    if (rawProbe) {\n                        const probe$1 = (0,_helpers_enum_js__WEBPACK_IMPORTED_MODULE_14__.enumFromValue)(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.probe, rawProbe);\n                        if (!probe$1) return {\n                            status: 400,\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.serializeError)(/* @__PURE__ */ new Error(`Unknown probe \"${rawProbe}\"`))),\n                            version: void 0\n                        };\n                        return ({\n                            [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.probe.Trust]: ()=>({\n                                    status: 200,\n                                    headers: {\n                                        \"Content-Type\": \"application/json\"\n                                    },\n                                    body: \"\",\n                                    version: void 0\n                                })\n                        })[probe$1]();\n                    }\n                    fnId = await actions.queryStringWithDefaults(\"processing run request\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.queryKeys.FnId);\n                    if (!fnId) throw new Error(\"No function ID found in async request\");\n                    fn = this.fns[fnId];\n                    stepId = await actions.queryStringWithDefaults(\"processing run request\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.queryKeys.StepId) || null;\n                }\n                if (typeof fnId === \"undefined\" || !fn) throw new Error(\"No function ID found in request\");\n                const { version: version$1, result } = this.runStep({\n                    functionId: fnId,\n                    data: body,\n                    stepId,\n                    timer,\n                    reqArgs,\n                    headers: await getHeaders(),\n                    fn,\n                    forceExecution,\n                    actions\n                });\n                const stepOutput = await result;\n                /**\n\t\t\t\t* Functions can return `undefined`, but we'll always convert this to\n\t\t\t\t* `null`, as this is appropriately serializable by JSON.\n\t\t\t\t*/ const opDataUndefinedToNull = (op)=>{\n                    op.data = (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__.undefinedToNull)(op.data);\n                    return op;\n                };\n                const handler = {\n                    \"function-rejected\": (result$1)=>{\n                        return {\n                            status: result$1.retriable ? 500 : 400,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.NoRetry]: result$1.retriable ? \"false\" : \"true\",\n                                ...typeof result$1.retriable === \"string\" ? {\n                                    [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.RetryAfter]: result$1.retriable\n                                } : {}\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__.undefinedToNull)(result$1.error)),\n                            version: version$1\n                        };\n                    },\n                    \"function-resolved\": (result$1)=>{\n                        if (forceExecution) {\n                            const runCompleteOp = {\n                                id: _execution_v1_js__WEBPACK_IMPORTED_MODULE_16__._internals.hashId(\"complete\"),\n                                op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.RunComplete,\n                                data: (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__.undefinedToNull)(result$1.data)\n                            };\n                            return {\n                                status: 206,\n                                headers: {\n                                    \"Content-Type\": \"application/json\"\n                                },\n                                body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(runCompleteOp),\n                                version: version$1\n                            };\n                        }\n                        return {\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__.undefinedToNull)(result$1.data)),\n                            version: version$1\n                        };\n                    },\n                    \"step-not-found\": (result$1)=>{\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.NoRetry]: \"false\"\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                                error: `Could not find step \"${result$1.step.displayName || result$1.step.id}\" to run; timed out`\n                            }),\n                            version: version$1\n                        };\n                    },\n                    \"step-ran\": (result$1)=>{\n                        const step = opDataUndefinedToNull(result$1.step);\n                        return {\n                            status: 206,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                ...typeof result$1.retriable !== \"undefined\" ? {\n                                    [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.NoRetry]: result$1.retriable ? \"false\" : \"true\",\n                                    ...typeof result$1.retriable === \"string\" ? {\n                                        [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.RetryAfter]: result$1.retriable\n                                    } : {}\n                                } : {}\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)([\n                                step\n                            ]),\n                            version: version$1\n                        };\n                    },\n                    \"steps-found\": (result$1)=>{\n                        const steps = result$1.steps.map(opDataUndefinedToNull);\n                        return {\n                            status: 206,\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(steps),\n                            version: version$1\n                        };\n                    },\n                    \"change-mode\": (result$1)=>{\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.NoRetry]: \"true\"\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                                error: `We wanted to change mode to \"${result$1.to}\", but this is not supported within the InngestCommHandler. This is a bug in the Inngest SDK.`\n                            }),\n                            version: version$1\n                        };\n                    }\n                }[stepOutput.type];\n                try {\n                    return await handler(stepOutput);\n                } catch (err) {\n                    this.log(\"error\", \"Error handling execution result\", err);\n                    throw err;\n                }\n            }\n            const env = (await getHeaders())[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Environment] ?? null;\n            if (method === \"GET\") return {\n                status: 200,\n                body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(await this.introspectionBody({\n                    actions,\n                    env,\n                    signatureValidation,\n                    url\n                })),\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                version: void 0\n            };\n            if (method === \"PUT\") {\n                const [deployId, inBandSyncRequested] = await Promise.all([\n                    actions.queryStringWithDefaults(\"processing deployment request\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.queryKeys.DeployId).then((deployId$1)=>{\n                        return deployId$1 === \"undefined\" ? void 0 : deployId$1;\n                    }),\n                    Promise.resolve((0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.parseAsBoolean)(this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestAllowInBandSync])).then((allowInBandSync)=>{\n                        if (allowInBandSync !== void 0 && !allowInBandSync) return _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.syncKind.OutOfBand;\n                        return actions.headers(\"processing deployment request\", _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestSyncKind);\n                    }).then((kind)=>{\n                        return kind === _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.syncKind.InBand;\n                    })\n                ]);\n                if (inBandSyncRequested) {\n                    if (isMissingBody) {\n                        this.log(\"error\", \"Missing body when syncing, possibly due to missing request body middleware\");\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\"\n                            },\n                            body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.serializeError)(/* @__PURE__ */ new Error(\"Missing request body when syncing, possibly due to missing request body middleware\"))),\n                            version: void 0\n                        };\n                    }\n                    if (!(await signatureValidation).success) return {\n                        status: 401,\n                        body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                            code: \"sig_verification_failed\"\n                        }),\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        version: void 0\n                    };\n                    const res = _types_js__WEBPACK_IMPORTED_MODULE_5__.inBandSyncRequestBodySchema.safeParse(body);\n                    if (!res.success) return {\n                        status: 400,\n                        body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                            code: \"invalid_request\",\n                            message: res.error.message\n                        }),\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        version: void 0\n                    };\n                    url = this.reqUrl(new URL(res.data.url));\n                    return {\n                        status: 200,\n                        body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(await this.inBandRegisterBody({\n                            actions,\n                            deployId,\n                            env,\n                            signatureValidation,\n                            url\n                        })),\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestSyncKind]: _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.syncKind.InBand\n                        },\n                        version: void 0\n                    };\n                }\n                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getHeaders);\n                return {\n                    status,\n                    body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                        message,\n                        modified\n                    }),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestSyncKind]: _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.syncKind.OutOfBand\n                    },\n                    version: void 0\n                };\n            }\n        } catch (err) {\n            return {\n                status: 500,\n                body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)({\n                    type: \"internal\",\n                    ...(0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_11__.serializeError)(err)\n                }),\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                version: void 0\n            };\n        }\n        return {\n            status: 405,\n            body: JSON.stringify({\n                message: \"No action found; request was likely not POST, PUT, or GET\",\n                mode: this._mode\n            }),\n            headers: {},\n            version: void 0\n        };\n    }\n    runStep({ actions, functionId, stepId, data, timer, reqArgs, headers, fn, forceExecution }) {\n        if (!fn) throw new Error(`Could not find function with ID \"${functionId}\"`);\n        const immediateFnData = (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__.parseFnData)(data);\n        let { version: version$1 } = immediateFnData;\n        if (version$1 === _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V1 && fn.fn[\"shouldOptimizeParallelism\"]?.()) version$1 = _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V2;\n        const result = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_13__.runAsPromise)(async ()=>{\n            const anyFnData = await (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_15__.fetchAllFnData)({\n                data: immediateFnData,\n                api: this.client[\"inngestApi\"],\n                version: version$1\n            });\n            if (!anyFnData.ok) throw new Error(anyFnData.error);\n            const createResponse = forceExecution && actions.experimentalTransformSyncResponse ? (data$1)=>actions.experimentalTransformSyncResponse(\"created sync->async response\", data$1).then((res)=>({\n                        ...res,\n                        version: version$1\n                    })) : void 0;\n            const executionOptions = await ((s)=>s)({\n                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V0]: ({ event, events, steps, ctx, version: version$2 })=>{\n                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, data$1])=>{\n                        return {\n                            ...acc,\n                            [id]: {\n                                id,\n                                data: data$1\n                            }\n                        };\n                    }, {});\n                    return {\n                        version: version$2,\n                        partialOptions: {\n                            client: this.client,\n                            runId: ctx?.run_id || \"\",\n                            stepMode: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Async,\n                            data: {\n                                event,\n                                events,\n                                runId: ctx?.run_id || \"\",\n                                attempt: ctx?.attempt ?? 0\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? void 0 : stepId || void 0,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            stepCompletionOrder: ctx?.stack?.stack ?? [],\n                            reqArgs,\n                            headers,\n                            createResponse\n                        }\n                    };\n                },\n                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V1]: ({ event, events, steps, ctx, version: version$2 })=>{\n                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1])=>{\n                        return {\n                            ...acc,\n                            [id]: result$1.type === \"data\" ? {\n                                id,\n                                data: result$1.data\n                            } : result$1.type === \"input\" ? {\n                                id,\n                                input: result$1.input\n                            } : {\n                                id,\n                                error: result$1.error\n                            }\n                        };\n                    }, {});\n                    return {\n                        version: version$2,\n                        partialOptions: {\n                            client: this.client,\n                            runId: ctx?.run_id || \"\",\n                            stepMode: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Async,\n                            data: {\n                                event,\n                                events,\n                                runId: ctx?.run_id || \"\",\n                                attempt: ctx?.attempt ?? 0,\n                                maxAttempts: ctx?.max_attempts\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? void 0 : stepId || void 0,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx?.disable_immediate_execution,\n                            stepCompletionOrder: ctx?.stack?.stack ?? [],\n                            reqArgs,\n                            headers,\n                            createResponse\n                        }\n                    };\n                },\n                [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V2]: ({ event, events, steps, ctx, version: version$2 })=>{\n                    const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1])=>{\n                        return {\n                            ...acc,\n                            [id]: result$1.type === \"data\" ? {\n                                id,\n                                data: result$1.data\n                            } : result$1.type === \"input\" ? {\n                                id,\n                                input: result$1.input\n                            } : {\n                                id,\n                                error: result$1.error\n                            }\n                        };\n                    }, {});\n                    return {\n                        version: version$2,\n                        partialOptions: {\n                            client: this.client,\n                            runId: ctx?.run_id || \"\",\n                            stepMode: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Async,\n                            data: {\n                                event,\n                                events,\n                                runId: ctx?.run_id || \"\",\n                                attempt: ctx?.attempt ?? 0,\n                                maxAttempts: ctx?.max_attempts\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? void 0 : stepId || void 0,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx?.disable_immediate_execution,\n                            stepCompletionOrder: ctx?.stack?.stack ?? [],\n                            reqArgs,\n                            headers,\n                            createResponse\n                        }\n                    };\n                }\n            })[version$1](anyFnData.value);\n            return fn.fn[\"createExecution\"](executionOptions).start();\n        });\n        return {\n            version: version$1,\n            result\n        };\n    }\n    configs(url) {\n        const configs = Object.values(this.rawFns).reduce((acc, fn)=>[\n                ...acc,\n                ...fn[\"getConfig\"]({\n                    baseUrl: url,\n                    appPrefix: this.id\n                })\n            ], []);\n        for (const config of configs){\n            const check = _types_js__WEBPACK_IMPORTED_MODULE_5__.functionConfigSchema.safeParse(config);\n            if (!check.success) {\n                const errors = check.error.errors.map((err)=>err.message).join(\"; \");\n                this.log(\"warn\", `Config invalid for function \"${config.id}\" : ${errors}`);\n            }\n        }\n        return configs;\n    }\n    /**\n\t* Return an Inngest serve endpoint URL given a potential `path` and `host`.\n\t*\n\t* Will automatically use the `serveHost` and `servePath` if they have been\n\t* set when registering.\n\t*/ reqUrl(url) {\n        let ret = new URL(url);\n        const serveHost = this.serveHost || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestServeHost];\n        const servePath = this.servePath || this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestServePath];\n        if (servePath) ret.pathname = servePath;\n        if (serveHost) ret = new URL(ret.pathname + ret.search, serveHost);\n        return ret;\n    }\n    registerBody({ url, deployId }) {\n        return {\n            url: url.href,\n            deployType: \"ping\",\n            framework: this.frameworkName,\n            appName: this.id,\n            functions: this.configs(url),\n            sdk: `js:v${_version_js__WEBPACK_IMPORTED_MODULE_17__.version}`,\n            v: \"0.1\",\n            deployId: deployId || void 0,\n            capabilities: {\n                trust_probe: \"v1\",\n                connect: \"v1\"\n            },\n            appVersion: this.client.appVersion\n        };\n    }\n    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url }) {\n        const registerBody = this.registerBody({\n            deployId,\n            url\n        });\n        const introspectionBody = await this.introspectionBody({\n            actions,\n            env,\n            signatureValidation,\n            url\n        });\n        const body = {\n            app_id: this.id,\n            appVersion: this.client.appVersion,\n            capabilities: registerBody.capabilities,\n            env,\n            framework: registerBody.framework,\n            functions: registerBody.functions,\n            inspection: introspectionBody,\n            platform: (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.getPlatformName)({\n                ...(0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.allProcessEnv)(),\n                ...this.env\n            }),\n            sdk_author: \"inngest\",\n            sdk_language: \"\",\n            sdk_version: \"\",\n            sdk: registerBody.sdk,\n            url: registerBody.url\n        };\n        if (introspectionBody.authentication_succeeded) {\n            body.sdk_language = introspectionBody.sdk_language;\n            body.sdk_version = introspectionBody.sdk_version;\n        }\n        return body;\n    }\n    async introspectionBody({ actions, env, signatureValidation, url }) {\n        const registerBody = this.registerBody({\n            url: this.reqUrl(url),\n            deployId: null\n        });\n        if (!this._mode) throw new Error(\"No mode set; cannot introspect without mode\");\n        let introspection = {\n            authentication_succeeded: null,\n            extra: {\n                is_mode_explicit: this._mode.isExplicit\n            },\n            has_event_key: this.client[\"eventKeySet\"](),\n            has_signing_key: Boolean(this.signingKey),\n            function_count: registerBody.functions.length,\n            mode: this._mode.type,\n            schema_version: \"2024-05-24\"\n        };\n        if (this._mode.type === \"cloud\") try {\n            if (!(await signatureValidation).success) throw new Error(\"Signature validation failed\");\n            introspection = {\n                ...introspection,\n                authentication_succeeded: true,\n                api_origin: this.apiBaseUrl,\n                app_id: this.id,\n                capabilities: {\n                    trust_probe: \"v1\",\n                    connect: \"v1\"\n                },\n                env,\n                event_api_origin: this.eventApiBaseUrl,\n                event_key_hash: this.hashedEventKey ?? null,\n                extra: {\n                    ...introspection.extra,\n                    is_streaming: await this.shouldStream(actions)\n                },\n                framework: this.frameworkName,\n                sdk_language: \"js\",\n                sdk_version: _version_js__WEBPACK_IMPORTED_MODULE_17__.version,\n                serve_origin: this.serveHost ?? null,\n                serve_path: this.servePath ?? null,\n                signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,\n                signing_key_hash: this.hashedSigningKey ?? null\n            };\n        } catch  {\n            introspection = {\n                ...introspection,\n                authentication_succeeded: false\n            };\n        }\n        return introspection;\n    }\n    async register(url, deployId, getHeaders) {\n        const body = this.registerBody({\n            url,\n            deployId\n        });\n        let res;\n        let registerURL = new URL(this.inngestRegisterUrl.href);\n        if (this._mode && this._mode.isInferred && this._mode.isDev) {\n            const host = (0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_3__.devServerHost)(this.env);\n            if (await (0,_helpers_devserver_js__WEBPACK_IMPORTED_MODULE_18__.devServerAvailable)(host, this.fetch)) registerURL = (0,_helpers_devserver_js__WEBPACK_IMPORTED_MODULE_18__.devServerUrl)(host, \"/fn/register\");\n        } else if (this._mode?.explicitDevUrl) registerURL = (0,_helpers_devserver_js__WEBPACK_IMPORTED_MODULE_18__.devServerUrl)(this._mode.explicitDevUrl.href, \"/fn/register\");\n        if (deployId) registerURL.searchParams.set(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.queryKeys.DeployId, deployId);\n        try {\n            res = await (0,_helpers_net_js__WEBPACK_IMPORTED_MODULE_19__.fetchWithAuthFallback)({\n                authToken: this.hashedSigningKey,\n                authTokenFallback: this.hashedSigningKeyFallback,\n                fetch: this.fetch,\n                url: registerURL.href,\n                options: {\n                    method: \"POST\",\n                    body: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_6__.stringify)(body),\n                    headers: {\n                        ...await getHeaders(),\n                        [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.InngestSyncKind]: _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.syncKind.OutOfBand\n                    },\n                    redirect: \"follow\"\n                }\n            });\n        } catch (err) {\n            this.log(\"error\", err);\n            return {\n                status: 500,\n                message: `Failed to register${err instanceof Error ? `; ${err.message}` : \"\"}`,\n                modified: false\n            };\n        }\n        const raw = await res.text();\n        let data = {};\n        try {\n            data = JSON.parse(raw);\n        } catch (err) {\n            this.log(\"warn\", \"Couldn't unpack register response:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) message += `; ${err.message}`;\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false\n            };\n        }\n        let status;\n        let error;\n        let skipped;\n        let modified;\n        try {\n            ({ status, error, skipped, modified } = registerResSchema.parse(data));\n        } catch (err) {\n            this.log(\"warn\", \"Invalid register response schema:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) message += `; ${err.message}`;\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false\n            };\n        }\n        if (!skipped) this.log(\"debug\", \"registered inngest functions:\", res.status, res.statusText, data);\n        return {\n            status,\n            message: error,\n            modified\n        };\n    }\n    /**\n\t* Given an environment, upsert any missing keys. This is useful in\n\t* situations where environment variables are passed directly to handlers or\n\t* are otherwise difficult to access during initialization.\n\t*/ upsertKeysFromEnv() {\n        if (this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestSigningKey]) {\n            if (!this.signingKey) this.signingKey = String(this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestSigningKey]);\n            this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n        }\n        if (this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestSigningKeyFallback]) {\n            if (!this.signingKeyFallback) this.signingKeyFallback = String(this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestSigningKeyFallback]);\n            this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n        }\n        if (!this.client[\"eventKeySet\"]() && this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestEventKey]) this.client.setEventKey(String(this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestEventKey]));\n        if (this.env[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestDevServerUrl]) this.log(\"warn\", `Use of ${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);\n    }\n    /**\n\t* Validate the signature of a request and return the signing key used to\n\t* validate it.\n\t*/ async validateSignature(sig, body) {\n        try {\n            if (this.skipSignatureValidation) return {\n                success: true,\n                keyUsed: \"\"\n            };\n            if (this._mode && !this._mode.isCloud) return {\n                success: true,\n                keyUsed: \"\"\n            };\n            if (!this.signingKey) throw new Error(`No signing key found in client options or ${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);\n            if (!sig) throw new Error(`No ${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Signature} provided`);\n            return {\n                success: true,\n                keyUsed: new RequestSignature(sig).verifySignature({\n                    body,\n                    allowExpiredSignatures: this.allowExpiredSignatures,\n                    signingKey: this.signingKey,\n                    signingKeyFallback: this.signingKeyFallback\n                })\n            };\n        } catch (err) {\n            return {\n                success: false,\n                err\n            };\n        }\n    }\n    getResponseSignature(key, body) {\n        const now = Date.now();\n        return `t=${now}&s=${(0,_helpers_net_js__WEBPACK_IMPORTED_MODULE_19__.signDataWithKey)(body, key, now.toString())}`;\n    }\n    /**\n\t* Log to stdout/stderr if the log level is set to include the given level.\n\t* The default log level is `\"info\"`.\n\t*\n\t* This is an abstraction over `console.log` and will try to use the correct\n\t* method for the given log level.  For example, `log(\"error\", \"foo\")` will\n\t* call `console.error(\"foo\")`.\n\t*/ log(level, ...args) {\n        const logLevels$1 = [\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\",\n            \"fatal\",\n            \"silent\"\n        ];\n        const logLevelSetting = logLevels$1.indexOf(this.logLevel);\n        if (logLevels$1.indexOf(level) >= logLevelSetting) {\n            let logger = console.log;\n            if (Object.hasOwn(console, level)) logger = console[level];\n            logger(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.logPrefix} ${level} -`, ...args);\n        }\n    }\n};\nvar RequestSignature = class {\n    constructor(sig){\n        const params = new URLSearchParams(sig);\n        this.timestamp = params.get(\"t\") || \"\";\n        this.signature = params.get(\"s\") || \"\";\n        if (!this.timestamp || !this.signature) throw new Error(`Invalid ${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.Signature} provided`);\n    }\n    hasExpired(allowExpiredSignatures) {\n        if (allowExpiredSignatures) return false;\n        return Date.now() - /* @__PURE__ */ new Date(Number.parseInt(this.timestamp) * 1e3).valueOf() > 1e3 * 60 * 5;\n    }\n    #verifySignature({ body, signingKey, allowExpiredSignatures }) {\n        if (this.hasExpired(allowExpiredSignatures)) throw new Error(\"Signature has expired\");\n        if ((0,_helpers_net_js__WEBPACK_IMPORTED_MODULE_19__.signDataWithKey)(body, signingKey, this.timestamp) !== this.signature) throw new Error(\"Invalid signature\");\n    }\n    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures }) {\n        try {\n            this.#verifySignature({\n                body,\n                signingKey,\n                allowExpiredSignatures\n            });\n            return signingKey;\n        } catch (err) {\n            if (!signingKeyFallback) throw err;\n            this.#verifySignature({\n                body,\n                signingKey: signingKeyFallback,\n                allowExpiredSignatures\n            });\n            return signingKeyFallback;\n        }\n    }\n};\n//#endregion\n //# sourceMappingURL=InngestCommHandler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDVDtBQUNtTTtBQUN2RztBQUN0RDtBQUNWO0FBQ21CO0FBQ1A7QUFDc0Y7QUFDM0Y7QUFDeEI7QUFDd0I7QUFDckI7QUFDSTtBQUNOO0FBQ0c7QUFDUjtBQUNyQjtBQUNFO0FBQ0Q7QUFFM0IsOENBQThDO0FBQzlDOztBQUVBLEdBQ0EsTUFBTW9ELG9CQUFvQkQsMENBQVEsQ0FBQztJQUNsQ0csUUFBUUgsMENBQVEsR0FBR0ssT0FBTyxDQUFDO0lBQzNCQyxTQUFTTiwyQ0FBUyxHQUFHUSxRQUFRLEdBQUdILE9BQU8sQ0FBQztJQUN4Q0ksVUFBVVQsMkNBQVMsR0FBR1EsUUFBUSxHQUFHSCxPQUFPLENBQUM7SUFDekNLLE9BQU9WLDBDQUFRLEdBQUdLLE9BQU8sQ0FBQztBQUMzQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBLEdBQ0EsSUFBSU8scUJBQXFCO0lBOEZ4QkMsWUFBWUMsT0FBTyxDQUFFO1FBVHJCOzs7Q0FHQSxRQUNBQyxNQUFNLENBQUM7YUFDUEMsTUFBTXBDLDhEQUFhQTtRQUtsQixJQUFJLENBQUNxQyxRQUFRLEdBQUdIO1FBQ2hCOzs7Ozs7RUFNQSxHQUNBLElBQUlJLE9BQU9DLE1BQU0sQ0FBQ0wsU0FBUyxhQUFhLE1BQU0sSUFBSU0sTUFBTSxDQUFDLEVBQUU1RCx5REFBU0EsQ0FBQyx1UEFBdVAsQ0FBQztRQUM3VCxJQUFJLENBQUM2RCxhQUFhLEdBQUdQLFFBQVFPLGFBQWE7UUFDMUMsSUFBSSxDQUFDQyxNQUFNLEdBQUdSLFFBQVFRLE1BQU07UUFDNUIsSUFBSVIsUUFBUVMsRUFBRSxFQUFFQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxFQUFFakUseURBQVNBLENBQUMsZ0VBQWdFLENBQUM7UUFDM0cs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QUFDbEssb0JBQW9CLE1BQU1rSztZQUMvQixJQUFJLENBQUMsQ0FBQzBJLGVBQWUsQ0FBQztnQkFDckIxTDtnQkFDQW5ILFlBQVlDO2dCQUNadEI7WUFDRDtZQUNBLE9BQU9zQjtRQUNSO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDa0IsQ0FDOUIsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyLmpzPzZjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QXN5bmNDdHggfSBmcm9tIFwiLi9leGVjdXRpb24vYWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IEV4ZWN1dGlvblZlcnNpb24sIGRlYnVnUHJlZml4LCBkZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwsIGRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsLCBkZWZhdWx0TWF4UmV0cmllcywgZHVtbXlFdmVudEtleSwgZW52S2V5cywgZm9yd2FyZGVkSGVhZGVycywgaGVhZGVyS2V5cywgbG9nUHJlZml4LCBwcm9iZSwgcXVlcnlLZXlzLCBzeW5jS2luZCB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiO1xuaW1wb3J0IHsgQXN5bmNSZXNwb25zZVR5cGUsIFN0ZXBNb2RlLCBTdGVwT3BDb2RlLCBmdW5jdGlvbkNvbmZpZ1NjaGVtYSwgaW5CYW5kU3luY1JlcXVlc3RCb2R5U2NoZW1hLCBsb2dMZXZlbHMgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IFBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTiB9IGZyb20gXCIuL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCI7XG5pbXBvcnQgeyByZXRocm93RXJyb3IsIHNlcmlhbGl6ZUVycm9yIH0gZnJvbSBcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBmZXRjaEFsbEZuRGF0YSwgcGFyc2VGbkRhdGEsIHVuZGVmaW5lZFRvTnVsbCB9IGZyb20gXCIuLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgaGFzaEV2ZW50S2V5LCBoYXNoU2lnbmluZ0tleSwgc3RyaW5naWZ5IH0gZnJvbSBcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiO1xuaW1wb3J0IHsgTW9kZSwgYWxsUHJvY2Vzc0VudiwgZGV2U2VydmVySG9zdCwgZ2V0RmV0Y2gsIGdldE1vZGUsIGdldFBsYXRmb3JtTmFtZSwgaW5uZ2VzdEhlYWRlcnMsIHBhcnNlQXNCb29sZWFuLCBwbGF0Zm9ybVN1cHBvcnRzU3RyZWFtaW5nIH0gZnJvbSBcIi4uL2hlbHBlcnMvZW52LmpzXCI7XG5pbXBvcnQgeyBkZXZTZXJ2ZXJBdmFpbGFibGUsIGRldlNlcnZlclVybCB9IGZyb20gXCIuLi9oZWxwZXJzL2RldnNlcnZlci5qc1wiO1xuaW1wb3J0IHsgZW51bUZyb21WYWx1ZSB9IGZyb20gXCIuLi9oZWxwZXJzL2VudW0uanNcIjtcbmltcG9ydCB7IGZldGNoV2l0aEF1dGhGYWxsYmFjaywgc2lnbkRhdGFXaXRoS2V5IH0gZnJvbSBcIi4uL2hlbHBlcnMvbmV0LmpzXCI7XG5pbXBvcnQgeyBydW5Bc1Byb21pc2UgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlcy5qc1wiO1xuaW1wb3J0IHsgU2VydmVyVGltaW5nIH0gZnJvbSBcIi4uL2hlbHBlcnMvU2VydmVyVGltaW5nLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdHJlYW0gfSBmcm9tIFwiLi4vaGVscGVycy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IElubmdlc3RGdW5jdGlvbiB9IGZyb20gXCIuL0lubmdlc3RGdW5jdGlvbi5qc1wiO1xuaW1wb3J0IHsgX2ludGVybmFscyB9IGZyb20gXCIuL2V4ZWN1dGlvbi92MS5qc1wiO1xuaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgdWxpZCB9IGZyb20gXCJ1bGlkXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZC92M1wiO1xuXG4vLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyLnRzXG4vKipcbiogQSBzY2hlbWEgZm9yIHRoZSByZXNwb25zZSBmcm9tIElubmdlc3Qgd2hlbiByZWdpc3RlcmluZy5cbiovXG5jb25zdCByZWdpc3RlclJlc1NjaGVtYSA9IHoub2JqZWN0KHtcblx0c3RhdHVzOiB6Lm51bWJlcigpLmRlZmF1bHQoMjAwKSxcblx0c2tpcHBlZDogei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZWZhdWx0KGZhbHNlKSxcblx0bW9kaWZpZWQ6IHouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVmYXVsdChmYWxzZSksXG5cdGVycm9yOiB6LnN0cmluZygpLmRlZmF1bHQoXCJTdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZFwiKVxufSk7XG4vKipcbiogYElubmdlc3RDb21tSGFuZGxlcmAgaXMgYSBjbGFzcyBmb3IgaGFuZGxpbmcgaW5jb21pbmcgcmVxdWVzdHMgZnJvbSBJbm5nZXN0IChvclxuKiBJbm5nZXN0J3MgdG9vbGluZyBzdWNoIGFzIHRoZSBkZXYgc2VydmVyIG9yIENMSSkgYW5kIHRha2luZyBhcHByb3ByaWF0ZVxuKiBhY3Rpb24gZm9yIGFueSBzZXJ2ZWQgZnVuY3Rpb25zLlxuKlxuKiBBbGwgaGFuZGxlcnMgKE5leHQuanMsIFJlZHdvb2RKUywgUmVtaXgsIERlbm8gRnJlc2gsIGV0Yy4pIGFyZSBjcmVhdGVkIHVzaW5nXG4qIHRoaXMgY2xhc3M7IHRoZSBleHBvc2VkIGBzZXJ2ZWAgZnVuY3Rpb24gd2lsbCAtIG1vc3QgY29tbW9ubHkgLSBjcmVhdGUgYW5cbiogaW5zdGFuY2Ugb2YgYElubmdlc3RDb21tSGFuZGxlcmAgYW5kIHRoZW4gcmV0dXJuIGBpbnN0YW5jZS5jcmVhdGVIYW5kbGVyKClgLlxuKlxuKiBTZWUgaW5kaXZpZHVhbCBwYXJhbWV0ZXIgZGV0YWlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbiwgb3Igc2VlIHRoZVxuKiBzb3VyY2UgY29kZSBmb3IgYW4gZXhpc3RpbmcgaGFuZGxlciwgZS5nLlxuKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2lubmdlc3QvaW5uZ2VzdC1qcy9ibG9iL21haW4vc3JjL25leHQudHN9XG4qXG4qIEBleGFtcGxlXG4qIGBgYFxuKiAvLyBteS1jdXN0b20taGFuZGxlci50c1xuKiBpbXBvcnQge1xuKiAgIElubmdlc3RDb21tSGFuZGxlcixcbiogICB0eXBlIFNlcnZlSGFuZGxlck9wdGlvbnMsXG4qIH0gZnJvbSBcIi4vY29tcG9uZW50cy9Jbm5nZXN0Q29tbUhhbmRsZXJcIjtcbipcbiogZXhwb3J0IGNvbnN0IHNlcnZlID0gKG9wdGlvbnM6IFNlcnZlSGFuZGxlck9wdGlvbnMpID0+IHtcbiogICBjb25zdCBoYW5kbGVyID0gbmV3IElubmdlc3RDb21tSGFuZGxlcih7XG4qICAgICBmcmFtZXdvcmtOYW1lOiBcIm15LWN1c3RvbS1oYW5kbGVyXCIsXG4qICAgICAuLi5vcHRpb25zLFxuKiAgICAgaGFuZGxlcjogKHJlcTogUmVxdWVzdCkgPT4ge1xuKiAgICAgICByZXR1cm4ge1xuKiAgICAgICAgIGJvZHk6ICgpID0+IHJlcS5qc29uKCksXG4qICAgICAgICAgaGVhZGVyczogKGtleSkgPT4gcmVxLmhlYWRlcnMuZ2V0KGtleSksXG4qICAgICAgICAgbWV0aG9kOiAoKSA9PiByZXEubWV0aG9kLFxuKiAgICAgICAgIHVybDogKCkgPT4gbmV3IFVSTChyZXEudXJsLCBgaHR0cHM6Ly8ke3JlcS5oZWFkZXJzLmdldChcImhvc3RcIikgfHwgXCJcIn1gKSxcbiogICAgICAgICB0cmFuc2Zvcm1SZXNwb25zZTogKHsgYm9keSwgc3RhdHVzLCBoZWFkZXJzIH0pID0+IHtcbiogICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG4qICAgICAgICAgfSxcbiogICAgICAgfTtcbiogICAgIH0sXG4qICAgfSk7XG4qXG4qICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuKiB9O1xuKiBgYGBcbipcbiogQHB1YmxpY1xuKi9cbnZhciBJbm5nZXN0Q29tbUhhbmRsZXIgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIFRoZSBJRCBvZiB0aGlzIHNlcnZlIGhhbmRsZXIsIGUuZy4gYFwibXktYXBwXCJgLiBJdCdzIHJlY29tbWVuZGVkIHRoYXQgdGhpc1xuXHQqIHZhbHVlIHJlcHJlc2VudHMgdGhlIG92ZXJhcmNoaW5nIGFwcC9zZXJ2aWNlIHRoYXQgdGhpcyBzZXQgb2YgZnVuY3Rpb25zIGlzXG5cdCogYmVpbmcgc2VydmVkIGZyb20uXG5cdCovXG5cdGlkO1xuXHQvKipcblx0KiBUaGUgaGFuZGxlciBzcGVjaWZpZWQgZHVyaW5nIGluc3RhbnRpYXRpb24gb2YgdGhlIGNsYXNzLlxuXHQqL1xuXHRoYW5kbGVyO1xuXHQvKipcblx0KiBUaGUgVVJMIG9mIHRoZSBJbm5nZXN0IGZ1bmN0aW9uIHJlZ2lzdHJhdGlvbiBlbmRwb2ludC5cblx0Ki9cblx0aW5uZ2VzdFJlZ2lzdGVyVXJsO1xuXHQvKipcblx0KiBUaGUgbmFtZSBvZiB0aGUgZnJhbWV3b3JrIHRoaXMgaGFuZGxlciBpcyBkZXNpZ25lZCBmb3IuIFNob3VsZCBiZVxuXHQqIGxvd2VyY2FzZSwgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgaW5jbHVzaXZlIG9mIGAtYCBhbmQgYC9gLlxuXHQqL1xuXHRmcmFtZXdvcmtOYW1lO1xuXHQvKipcblx0KiBUaGUgc2lnbmluZyBrZXkgdXNlZCB0byB2YWxpZGF0ZSByZXF1ZXN0cyBmcm9tIElubmdlc3QuIFRoaXMgaXNcblx0KiBpbnRlbnRpb25hbGx5IG11dGFibGUgc28gdGhhdCB3ZSBjYW4gcGljayB1cCB0aGUgc2lnbmluZyBrZXkgZnJvbSB0aGVcblx0KiBlbnZpcm9ubWVudCBkdXJpbmcgZXhlY3V0aW9uIGlmIG5lZWRlZC5cblx0Ki9cblx0c2lnbmluZ0tleTtcblx0LyoqXG5cdCogVGhlIHNhbWUgYXMgc2lnbmluZ0tleSwgZXhjZXB0IHVzZWQgYXMgYSBmYWxsYmFjayB3aGVuIGF1dGggZmFpbHMgdXNpbmcgdGhlXG5cdCogcHJpbWFyeSBzaWduaW5nIGtleS5cblx0Ki9cblx0c2lnbmluZ0tleUZhbGxiYWNrO1xuXHQvKipcblx0KiBBIHByb3BlcnR5IHRoYXQgY2FuIGJlIHNldCB0byBpbmRpY2F0ZSB3aGV0aGVyIHdlIGJlbGlldmUgd2UgYXJlIGluXG5cdCogcHJvZHVjdGlvbiBtb2RlLlxuXHQqXG5cdCogU2hvdWxkIGJlIHNldCBldmVyeSB0aW1lIGEgcmVxdWVzdCBpcyByZWNlaXZlZC5cblx0Ki9cblx0X21vZGU7XG5cdC8qKlxuXHQqIFRoZSBsb2NhbGl6ZWQgYGZldGNoYCBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoaXMgaGFuZGxlci5cblx0Ki9cblx0ZmV0Y2g7XG5cdC8qKlxuXHQqIFRoZSBob3N0IHVzZWQgdG8gYWNjZXNzIHRoZSBJbm5nZXN0IHNlcnZlIGVuZHBvaW50LCBlLmcuOlxuXHQqXG5cdCogICAgIFwiaHR0cHM6Ly9teWFwcC5jb21cIlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgdGhlIGxpYnJhcnkgd2lsbCB0cnkgdG8gaW5mZXIgdGhpcyB1c2luZyByZXF1ZXN0IGRldGFpbHMgc3VjaFxuXHQqIGFzIHRoZSBcIkhvc3RcIiBoZWFkZXIgYW5kIHJlcXVlc3QgcGF0aCwgYnV0IHNvbWV0aW1lcyB0aGlzIGlzbid0IHBvc3NpYmxlXG5cdCogKGUuZy4gd2hlbiBydW5uaW5nIGluIGEgbW9yZSBjb250cm9sbGVkIGVudmlyb25tZW50cyBzdWNoIGFzIEFXUyBMYW1iZGEgb3Jcblx0KiB3aGVuIGRlYWxpbmcgd2l0aCBwcm94aWVzL3JlZGlyZWN0cykuXG5cdCpcblx0KiBQcm92aWRlIHRoZSBjdXN0b20gaG9zdG5hbWUgaGVyZSB0byBlbnN1cmUgdGhhdCB0aGUgcGF0aCBpcyByZXBvcnRlZFxuXHQqIGNvcnJlY3RseSB3aGVuIHJlZ2lzdGVyaW5nIGZ1bmN0aW9ucyB3aXRoIElubmdlc3QuXG5cdCpcblx0KiBUbyBhbHNvIHByb3ZpZGUgYSBjdXN0b20gcGF0aCwgdXNlIGBzZXJ2ZVBhdGhgLlxuXHQqL1xuXHRfc2VydmVIb3N0O1xuXHQvKipcblx0KiBUaGUgcGF0aCB0byB0aGUgSW5uZ2VzdCBzZXJ2ZSBlbmRwb2ludC4gZS5nLjpcblx0KlxuXHQqICAgICBcIi9zb21lL2xvbmcvcGF0aC90by9pbm5nZXN0L2VuZHBvaW50XCJcblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHRoZSBsaWJyYXJ5IHdpbGwgdHJ5IHRvIGluZmVyIHRoaXMgdXNpbmcgcmVxdWVzdCBkZXRhaWxzIHN1Y2hcblx0KiBhcyB0aGUgXCJIb3N0XCIgaGVhZGVyIGFuZCByZXF1ZXN0IHBhdGgsIGJ1dCBzb21ldGltZXMgdGhpcyBpc24ndCBwb3NzaWJsZVxuXHQqIChlLmcuIHdoZW4gcnVubmluZyBpbiBhIG1vcmUgY29udHJvbGxlZCBlbnZpcm9ubWVudHMgc3VjaCBhcyBBV1MgTGFtYmRhIG9yXG5cdCogd2hlbiBkZWFsaW5nIHdpdGggcHJveGllcy9yZWRpcmVjdHMpLlxuXHQqXG5cdCogUHJvdmlkZSB0aGUgY3VzdG9tIHBhdGggKGV4Y2x1ZGluZyB0aGUgaG9zdG5hbWUpIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlXG5cdCogcGF0aCBpcyByZXBvcnRlZCBjb3JyZWN0bHkgd2hlbiByZWdpc3RlcmluZyBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LlxuXHQqXG5cdCogVG8gYWxzbyBwcm92aWRlIGEgY3VzdG9tIGhvc3RuYW1lLCB1c2UgYHNlcnZlSG9zdGAuXG5cdCovXG5cdF9zZXJ2ZVBhdGg7XG5cdC8qKlxuXHQqIFRoZSBtaW5pbXVtIGxldmVsIHRvIGxvZyBmcm9tIHRoZSBJbm5nZXN0IHNlcnZlIGhhbmRsZXIuXG5cdCovXG5cdGxvZ0xldmVsO1xuXHRzdHJlYW1pbmc7XG5cdC8qKlxuXHQqIEEgcHJpdmF0ZSBjb2xsZWN0aW9uIG9mIGp1c3QgSW5uZ2VzdCBmdW5jdGlvbnMsIGFzIHRoZXkgaGF2ZSBiZWVuIHBhc3NlZFxuXHQqIHdoZW4gaW5zdGFudGlhdGluZyB0aGUgY2xhc3MuXG5cdCovXG5cdHJhd0Zucztcblx0Y2xpZW50O1xuXHQvKipcblx0KiBBIHByaXZhdGUgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgYmVpbmcgc2VydmVkLiBUaGlzIG1hcCBpcyB1c2VkXG5cdCogdG8gZmluZCBhbmQgcmVnaXN0ZXIgZnVuY3Rpb25zIHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCBJbm5nZXN0IENsb3VkLlxuXHQqL1xuXHRmbnMgPSB7fTtcblx0ZW52ID0gYWxsUHJvY2Vzc0VudigpO1xuXHRhbGxvd0V4cGlyZWRTaWduYXR1cmVzO1xuXHRfb3B0aW9ucztcblx0c2tpcFNpZ25hdHVyZVZhbGlkYXRpb247XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblx0XHQvKipcblx0XHQqIHYyIC0+IHYzIG1pZ3JhdGlvbiBlcnJvci5cblx0XHQqXG5cdFx0KiBJZiBhIHNlcnZlIGhhbmRsZXIgaXMgcGFzc2VkIGEgY2xpZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaXQnbGwgYmVcblx0XHQqIHNwcmVhZCBpbiB0byB0aGVzZSBvcHRpb25zLiBXZSBzaG91bGQgYmUgYWJsZSB0byBkZXRlY3QgdGhpcyBieSBwaWNraW5nXG5cdFx0KiB1cCBhIHVuaXF1ZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0LlxuXHRcdCovXG5cdFx0aWYgKE9iamVjdC5oYXNPd24ob3B0aW9ucywgXCJldmVudEtleVwiKSkgdGhyb3cgbmV3IEVycm9yKGAke2xvZ1ByZWZpeH0gWW91J3ZlIHBhc3NlZCBhbiBJbm5nZXN0IGNsaWVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8geW91ciBzZXJ2ZSBoYW5kbGVyLiBUaGlzIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gdjM7IHBsZWFzZSBwYXNzIHRoZSBJbm5nZXN0IGNsaWVudCBhcyB0aGUgXFxgY2xpZW50XFxgIHByb3BlcnR5IG9mIGFuIG9wdGlvbnMgb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcblx0XHR0aGlzLmZyYW1ld29ya05hbWUgPSBvcHRpb25zLmZyYW1ld29ya05hbWU7XG5cdFx0dGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcblx0XHRpZiAob3B0aW9ucy5pZCkgY29uc29sZS53YXJuKGAke2xvZ1ByZWZpeH0gVGhlIFxcYGlkXFxgIHNlcnZlIG9wdGlvbiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjRgKTtcblx0XHR0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCB0aGlzLmNsaWVudC5pZDtcblx0XHR0aGlzLmhhbmRsZXIgPSBvcHRpb25zLmhhbmRsZXI7XG5cdFx0LyoqXG5cdFx0KiBQcm92aWRlIGEgaGlkZGVuIG9wdGlvbiB0byBhbGxvdyBleHBpcmVkIHNpZ25hdHVyZXMgdG8gYmUgYWNjZXB0ZWQgZHVyaW5nXG5cdFx0KiB0ZXN0aW5nLlxuXHRcdCovXG5cdFx0dGhpcy5hbGxvd0V4cGlyZWRTaWduYXR1cmVzID0gQm9vbGVhbihhcmd1bWVudHNbXCIwXCJdPy5fX3Rlc3RpbmdBbGxvd0V4cGlyZWRTaWduYXR1cmVzKTtcblx0XHR0aGlzLnJhd0ZucyA9IG9wdGlvbnMuZnVuY3Rpb25zPy5maWx0ZXIoQm9vbGVhbikgPz8gW107XG5cdFx0aWYgKHRoaXMucmF3Rm5zLmxlbmd0aCAhPT0gKG9wdGlvbnMuZnVuY3Rpb25zID8/IFtdKS5sZW5ndGgpIGNvbnNvbGUud2FybihgU29tZSBmdW5jdGlvbnMgcGFzc2VkIHRvIHNlcnZlKCkgYXJlIHVuZGVmaW5lZCBhbmQgbWlzY29uZmlndXJlZC4gIFBsZWFzZSBjaGVjayB5b3VyIGltcG9ydHMuYCk7XG5cdFx0dGhpcy5mbnMgPSB0aGlzLnJhd0Zucy5yZWR1Y2UoKGFjYywgZm4pID0+IHtcblx0XHRcdGNvbnN0IGNvbmZpZ3MgPSBmbltcImdldENvbmZpZ1wiXSh7XG5cdFx0XHRcdGJhc2VVcmw6IG5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpLFxuXHRcdFx0XHRhcHBQcmVmaXg6IHRoaXMuaWRcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgZm5zID0gY29uZmlncy5yZWR1Y2UoKGFjYyQxLCB7IGlkIH0sIGluZGV4KSA9PiB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Li4uYWNjJDEsXG5cdFx0XHRcdFx0W2lkXToge1xuXHRcdFx0XHRcdFx0Zm4sXG5cdFx0XHRcdFx0XHRvbkZhaWx1cmU6IEJvb2xlYW4oaW5kZXgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSwge30pO1xuXHRcdFx0Y29uZmlncy5mb3JFYWNoKCh7IGlkIH0pID0+IHtcblx0XHRcdFx0aWYgKGFjY1tpZF0pIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIElEIFwiJHtpZH1cIjsgcGxlYXNlIGNoYW5nZSBhIGZ1bmN0aW9uJ3MgbmFtZSBvciBwcm92aWRlIGFuIGV4cGxpY2l0IElEIHRvIGF2b2lkIGNvbmZsaWN0cy5gKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4uYWNjLFxuXHRcdFx0XHQuLi5mbnNcblx0XHRcdH07XG5cdFx0fSwge30pO1xuXHRcdHRoaXMuaW5uZ2VzdFJlZ2lzdGVyVXJsID0gbmV3IFVSTChcIi9mbi9yZWdpc3RlclwiLCB0aGlzLmFwaUJhc2VVcmwpO1xuXHRcdHRoaXMuc2lnbmluZ0tleSA9IG9wdGlvbnMuc2lnbmluZ0tleTtcblx0XHR0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IG9wdGlvbnMuc2lnbmluZ0tleUZhbGxiYWNrO1xuXHRcdHRoaXMuX3NlcnZlSG9zdCA9IG9wdGlvbnMuc2VydmVIb3N0IHx8IHRoaXMuZW52W2VudktleXMuSW5uZ2VzdFNlcnZlSG9zdF07XG5cdFx0dGhpcy5fc2VydmVQYXRoID0gb3B0aW9ucy5zZXJ2ZVBhdGggfHwgdGhpcy5lbnZbZW52S2V5cy5Jbm5nZXN0U2VydmVQYXRoXTtcblx0XHR0aGlzLnNraXBTaWduYXR1cmVWYWxpZGF0aW9uID0gb3B0aW9ucy5za2lwU2lnbmF0dXJlVmFsaWRhdGlvbiB8fCBmYWxzZTtcblx0XHRjb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBcImluZm9cIjtcblx0XHR0aGlzLmxvZ0xldmVsID0gei5lbnVtKGxvZ0xldmVscykuZGVmYXVsdChkZWZhdWx0TG9nTGV2ZWwpLmNhdGNoKChjdHgpID0+IHtcblx0XHRcdHRoaXMubG9nKFwid2FyblwiLCBgVW5rbm93biBsb2cgbGV2ZWwgcGFzc2VkOiAke1N0cmluZyhjdHguaW5wdXQpfTsgZGVmYXVsdGluZyB0byAke2RlZmF1bHRMb2dMZXZlbH1gKTtcblx0XHRcdHJldHVybiBkZWZhdWx0TG9nTGV2ZWw7XG5cdFx0fSkucGFyc2Uob3B0aW9ucy5sb2dMZXZlbCB8fCB0aGlzLmVudltlbnZLZXlzLklubmdlc3RMb2dMZXZlbF0pO1xuXHRcdGlmICh0aGlzLmxvZ0xldmVsID09PSBcImRlYnVnXCIpIHtcblx0XHRcdC8qKlxuXHRcdFx0KiBgZGVidWdgIGlzIGFuIG9sZCBsaWJyYXJ5OyBzb21ldGltZXMgaXRzIHJ1bnRpbWUgZGV0ZWN0aW9uIGRvZXNuJ3Qgd29ya1xuXHRcdFx0KiBmb3IgbmV3ZXIgcGFpcmluZ3Mgb2YgZnJhbWV3b3JrL3J1bnRpbWUuXG5cdFx0XHQqXG5cdFx0XHQqIE9uZSBzaWxseSBzeW1wdG9tIG9mIHRoaXMgaXMgdGhhdCBgRGVidWcoKWAgcmV0dXJucyBhbiBhbm9ueW1vdXNcblx0XHRcdCogZnVuY3Rpb24gd2l0aCBubyBleHRyYSBwcm9wZXJ0aWVzIGluc3RlYWQgb2YgYSBgRGVidWdnZXJgIGluc3RhbmNlIGlmXG5cdFx0XHQqIHRoZSB3cm9uZyBjb2RlIGlzIGNvbnN1bWVkIGZvbGxvd2luZyBhIGJhZCBkZXRlY3Rpb24uIFRoaXMgcmVzdWx0cyBpblxuXHRcdFx0KiB0aGUgZm9sbG93aW5nIGAuZW5hYmxlKClgIGNhbGwgZmFpbGluZywgc28gd2UganVzdCB0cnkgY2FyZWZ1bGx5IHRvXG5cdFx0XHQqIGVuYWJsZSBpdCBoZXJlLlxuXHRcdFx0Ki9cblx0XHRcdGlmIChkZWJ1Zy5lbmFibGUgJiYgdHlwZW9mIGRlYnVnLmVuYWJsZSA9PT0gXCJmdW5jdGlvblwiKSBkZWJ1Zy5lbmFibGUoYCR7ZGVidWdQcmVmaXh9OipgKTtcblx0XHR9XG5cdFx0Y29uc3QgZGVmYXVsdFN0cmVhbWluZ09wdGlvbiA9IGZhbHNlO1xuXHRcdHRoaXMuc3RyZWFtaW5nID0gei51bmlvbihbei5lbnVtKFtcImFsbG93XCIsIFwiZm9yY2VcIl0pLCB6LmxpdGVyYWwoZmFsc2UpXSkuZGVmYXVsdChkZWZhdWx0U3RyZWFtaW5nT3B0aW9uKS5jYXRjaCgoY3R4KSA9PiB7XG5cdFx0XHR0aGlzLmxvZyhcIndhcm5cIiwgYFVua25vd24gc3RyZWFtaW5nIG9wdGlvbiBwYXNzZWQ6ICR7U3RyaW5nKGN0eC5pbnB1dCl9OyBkZWZhdWx0aW5nIHRvICR7U3RyaW5nKGRlZmF1bHRTdHJlYW1pbmdPcHRpb24pfWApO1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRTdHJlYW1pbmdPcHRpb247XG5cdFx0fSkucGFyc2Uob3B0aW9ucy5zdHJlYW1pbmcgfHwgdGhpcy5lbnZbZW52S2V5cy5Jbm5nZXN0U3RyZWFtaW5nXSk7XG5cdFx0dGhpcy5mZXRjaCA9IG9wdGlvbnMuZmV0Y2ggPyBnZXRGZXRjaChvcHRpb25zLmZldGNoKSA6IHRoaXMuY2xpZW50W1wiZmV0Y2hcIl07XG5cdH1cblx0LyoqXG5cdCogR2V0IHRoZSBBUEkgYmFzZSBVUkwgZm9yIHRoZSBJbm5nZXN0IEFQSS5cblx0KlxuXHQqIFRoaXMgaXMgYSBnZXR0ZXIgdG8gZW5jb3VyYWdlIGNoZWNraW5nIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIEFQSSBiYXNlIFVSTFxuXHQqIGVhY2ggdGltZSBpdCdzIGFjY2Vzc2VkLCBhcyBpdCBtYXkgY2hhbmdlIGR1cmluZyBleGVjdXRpb24uXG5cdCovXG5cdGdldCBhcGlCYXNlVXJsKCkge1xuXHRcdHJldHVybiB0aGlzLl9vcHRpb25zLmJhc2VVcmwgfHwgdGhpcy5lbnZbZW52S2V5cy5Jbm5nZXN0QXBpQmFzZVVybF0gfHwgdGhpcy5lbnZbZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHwgdGhpcy5jbGllbnQuYXBpQmFzZVVybCB8fCBkZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmw7XG5cdH1cblx0LyoqXG5cdCogR2V0IHRoZSBldmVudCBBUEkgYmFzZSBVUkwgZm9yIHRoZSBJbm5nZXN0IEFQSS5cblx0KlxuXHQqIFRoaXMgaXMgYSBnZXR0ZXIgdG8gZW5jb3VyYWdlIGNoZWNraW5nIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIGV2ZW50IEFQSVxuXHQqIGJhc2UgVVJMIGVhY2ggdGltZSBpdCdzIGFjY2Vzc2VkLCBhcyBpdCBtYXkgY2hhbmdlIGR1cmluZyBleGVjdXRpb24uXG5cdCovXG5cdGdldCBldmVudEFwaUJhc2VVcmwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYmFzZVVybCB8fCB0aGlzLmVudltlbnZLZXlzLklubmdlc3RFdmVudEFwaUJhc2VVcmxdIHx8IHRoaXMuZW52W2VudktleXMuSW5uZ2VzdEJhc2VVcmxdIHx8IHRoaXMuY2xpZW50LmV2ZW50QmFzZVVybCB8fCBkZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybDtcblx0fVxuXHQvKipcblx0KiBUaGUgaG9zdCB1c2VkIHRvIGFjY2VzcyB0aGUgSW5uZ2VzdCBzZXJ2ZSBlbmRwb2ludCwgZS5nLjpcblx0KlxuXHQqICAgICBcImh0dHBzOi8vbXlhcHAuY29tXCJcblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHRoZSBsaWJyYXJ5IHdpbGwgdHJ5IHRvIGluZmVyIHRoaXMgdXNpbmcgcmVxdWVzdCBkZXRhaWxzIHN1Y2hcblx0KiBhcyB0aGUgXCJIb3N0XCIgaGVhZGVyIGFuZCByZXF1ZXN0IHBhdGgsIGJ1dCBzb21ldGltZXMgdGhpcyBpc24ndCBwb3NzaWJsZVxuXHQqIChlLmcuIHdoZW4gcnVubmluZyBpbiBhIG1vcmUgY29udHJvbGxlZCBlbnZpcm9ubWVudHMgc3VjaCBhcyBBV1MgTGFtYmRhIG9yXG5cdCogd2hlbiBkZWFsaW5nIHdpdGggcHJveGllcy9yZWRpcmVjdHMpLlxuXHQqXG5cdCogUHJvdmlkZSB0aGUgY3VzdG9tIGhvc3RuYW1lIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlIHBhdGggaXMgcmVwb3J0ZWRcblx0KiBjb3JyZWN0bHkgd2hlbiByZWdpc3RlcmluZyBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LlxuXHQqXG5cdCogVG8gYWxzbyBwcm92aWRlIGEgY3VzdG9tIHBhdGgsIHVzZSBgc2VydmVQYXRoYC5cblx0Ki9cblx0Z2V0IHNlcnZlSG9zdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VydmVIb3N0IHx8IHRoaXMuZW52W2VudktleXMuSW5uZ2VzdFNlcnZlSG9zdF07XG5cdH1cblx0LyoqXG5cdCogVGhlIHBhdGggdG8gdGhlIElubmdlc3Qgc2VydmUgZW5kcG9pbnQuIGUuZy46XG5cdCpcblx0KiAgICAgXCIvc29tZS9sb25nL3BhdGgvdG8vaW5uZ2VzdC9lbmRwb2ludFwiXG5cdCpcblx0KiBCeSBkZWZhdWx0LCB0aGUgbGlicmFyeSB3aWxsIHRyeSB0byBpbmZlciB0aGlzIHVzaW5nIHJlcXVlc3QgZGV0YWlscyBzdWNoXG5cdCogYXMgdGhlIFwiSG9zdFwiIGhlYWRlciBhbmQgcmVxdWVzdCBwYXRoLCBidXQgc29tZXRpbWVzIHRoaXMgaXNuJ3QgcG9zc2libGVcblx0KiAoZS5nLiB3aGVuIHJ1bm5pbmcgaW4gYSBtb3JlIGNvbnRyb2xsZWQgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQVdTIExhbWJkYSBvclxuXHQqIHdoZW4gZGVhbGluZyB3aXRoIHByb3hpZXMvcmVkaXJlY3RzKS5cblx0KlxuXHQqIFByb3ZpZGUgdGhlIGN1c3RvbSBwYXRoIChleGNsdWRpbmcgdGhlIGhvc3RuYW1lKSBoZXJlIHRvIGVuc3VyZSB0aGF0IHRoZVxuXHQqIHBhdGggaXMgcmVwb3J0ZWQgY29ycmVjdGx5IHdoZW4gcmVnaXN0ZXJpbmcgZnVuY3Rpb25zIHdpdGggSW5uZ2VzdC5cblx0KlxuXHQqIFRvIGFsc28gcHJvdmlkZSBhIGN1c3RvbSBob3N0bmFtZSwgdXNlIGBzZXJ2ZUhvc3RgLlxuXHQqXG5cdCogVGhpcyBpcyBhIGdldHRlciB0byBlbmNvdXJhZ2UgY2hlY2tpbmcgdGhlIGVudmlyb25tZW50IGZvciB0aGUgc2VydmUgcGF0aFxuXHQqIGVhY2ggdGltZSBpdCdzIGFjY2Vzc2VkLCBhcyBpdCBtYXkgY2hhbmdlIGR1cmluZyBleGVjdXRpb24uXG5cdCovXG5cdGdldCBzZXJ2ZVBhdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlcnZlUGF0aCB8fCB0aGlzLmVudltlbnZLZXlzLklubmdlc3RTZXJ2ZVBhdGhdO1xuXHR9XG5cdGdldCBoYXNoZWRFdmVudEtleSgpIHtcblx0XHRpZiAoIXRoaXMuY2xpZW50W1wiZXZlbnRLZXlcIl0gfHwgdGhpcy5jbGllbnRbXCJldmVudEtleVwiXSA9PT0gZHVtbXlFdmVudEtleSkgcmV0dXJuO1xuXHRcdHJldHVybiBoYXNoRXZlbnRLZXkodGhpcy5jbGllbnRbXCJldmVudEtleVwiXSk7XG5cdH1cblx0Z2V0IGhhc2hlZFNpZ25pbmdLZXkoKSB7XG5cdFx0aWYgKCF0aGlzLnNpZ25pbmdLZXkpIHJldHVybjtcblx0XHRyZXR1cm4gaGFzaFNpZ25pbmdLZXkodGhpcy5zaWduaW5nS2V5KTtcblx0fVxuXHRnZXQgaGFzaGVkU2lnbmluZ0tleUZhbGxiYWNrKCkge1xuXHRcdGlmICghdGhpcy5zaWduaW5nS2V5RmFsbGJhY2spIHJldHVybjtcblx0XHRyZXR1cm4gaGFzaFNpZ25pbmdLZXkodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybnMgYSBgYm9vbGVhbmAgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBoYW5kbGVyIHdpbGwgc3RyZWFtIHJlc3BvbnNlc1xuXHQqIG9yIG5vdC4gVGFrZXMgaW50byBhY2NvdW50IHRoZSB1c2VyJ3MgcHJlZmVyZW5jZSBhbmQgdGhlIHBsYXRmb3JtJ3Ncblx0KiBjYXBhYmlsaXRpZXMuXG5cdCovXG5cdGFzeW5jIHNob3VsZFN0cmVhbShhY3Rpb25zKSB7XG5cdFx0aWYgKGF3YWl0IGFjdGlvbnMucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJ0ZXN0aW5nIGZvciBwcm9iZVwiLCBxdWVyeUtleXMuUHJvYmUpICE9PSB2b2lkIDApIHJldHVybiBmYWxzZTtcblx0XHRpZiAoIWFjdGlvbnMudHJhbnNmb3JtU3RyZWFtaW5nUmVzcG9uc2UpIHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcy5zdHJlYW1pbmcgPT09IFwiZm9yY2VcIikgcmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIHRoaXMuc3RyZWFtaW5nID09PSBcImFsbG93XCIgJiYgcGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyh0aGlzLmZyYW1ld29ya05hbWUsIHRoaXMuZW52KTtcblx0fVxuXHRhc3luYyBpc0lubmdlc3RSZXEoYWN0aW9ucykge1xuXHRcdGNvbnN0IHJlcU1lc3NhZ2UgPSBgY2hlY2tpbmcgaWYgdGhpcyBpcyBhbiBJbm5nZXN0IHJlcXVlc3RgO1xuXHRcdGNvbnN0IFtydW5JZCwgc2lnbmF0dXJlXSA9IGF3YWl0IFByb21pc2UuYWxsKFthY3Rpb25zLmhlYWRlcnMocmVxTWVzc2FnZSwgaGVhZGVyS2V5cy5Jbm5nZXN0UnVuSWQpLCBhY3Rpb25zLmhlYWRlcnMocmVxTWVzc2FnZSwgaGVhZGVyS2V5cy5TaWduYXR1cmUpXSk7XG5cdFx0cmV0dXJuIEJvb2xlYW4ocnVuSWQgJiYgdHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIik7XG5cdH1cblx0LyoqXG5cdCogU3RhcnQgaGFuZGxpbmcgYSByZXF1ZXN0LCBzZXR0aW5nIHVwIGVudmlyb25tZW50cywgbW9kZXMsIGFuZCByZXR1cm5pbmdcblx0KiBzb21lIGhlbHBlcnMuXG5cdCovXG5cdGFzeW5jIGluaXRSZXF1ZXN0KC4uLmFyZ3MpIHtcblx0XHRjb25zdCB0aW1lciA9IG5ldyBTZXJ2ZXJUaW1pbmcoKTtcblx0XHRjb25zdCBhY3Rpb25zID0gYXdhaXQgdGhpcy5nZXRBY3Rpb25zKHRpbWVyLCAuLi5hcmdzKTtcblx0XHRjb25zdCBbZW52LCBleHBlY3RlZFNlcnZlcktpbmRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FjdGlvbnMuZW52Py4oXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKSwgYWN0aW9ucy5oZWFkZXJzKFwiY2hlY2tpbmcgZXhwZWN0ZWQgc2VydmVyIGtpbmRcIiwgaGVhZGVyS2V5cy5Jbm5nZXN0U2VydmVyS2luZCldKTtcblx0XHR0aGlzLmVudiA9IHtcblx0XHRcdC4uLmFsbFByb2Nlc3NFbnYoKSxcblx0XHRcdC4uLmVudlxuXHRcdH07XG5cdFx0Y29uc3QgaGVhZGVyUHJvbWlzZXMgPSBmb3J3YXJkZWRIZWFkZXJzLm1hcChhc3luYyAoaGVhZGVyKSA9PiB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRoZWFkZXIsXG5cdFx0XHRcdHZhbHVlOiBhd2FpdCBhY3Rpb25zLmhlYWRlcnMoYGZldGNoaW5nICR7aGVhZGVyfSBmb3IgZm9yd2FyZGluZ2AsIGhlYWRlcilcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0Y29uc3QgaGVhZGVyc1RvRm9yd2FyZFAgPSBQcm9taXNlLmFsbChoZWFkZXJQcm9taXNlcykudGhlbigoZmV0Y2hlZEhlYWRlcnMpID0+IHtcblx0XHRcdHJldHVybiBmZXRjaGVkSGVhZGVycy5yZWR1Y2UoKGFjYywgeyBoZWFkZXIsIHZhbHVlIH0pID0+IHtcblx0XHRcdFx0aWYgKHZhbHVlKSBhY2NbaGVhZGVyXSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gYWNjO1xuXHRcdFx0fSwge30pO1xuXHRcdH0pO1xuXHRcdGNvbnN0IGdldEhlYWRlcnMgPSBhc3luYyAoKSA9PiAoe1xuXHRcdFx0Li4uaW5uZ2VzdEhlYWRlcnMoe1xuXHRcdFx0XHRlbnY6IHRoaXMuZW52LFxuXHRcdFx0XHRmcmFtZXdvcms6IHRoaXMuZnJhbWV3b3JrTmFtZSxcblx0XHRcdFx0Y2xpZW50OiB0aGlzLmNsaWVudCxcblx0XHRcdFx0ZXhwZWN0ZWRTZXJ2ZXJLaW5kOiBleHBlY3RlZFNlcnZlcktpbmQgfHwgdm9pZCAwLFxuXHRcdFx0XHRleHRyYXM6IHsgXCJTZXJ2ZXItVGltaW5nXCI6IHRpbWVyLmdldEhlYWRlcigpIH1cblx0XHRcdH0pLFxuXHRcdFx0Li4uYXdhaXQgaGVhZGVyc1RvRm9yd2FyZFBcblx0XHR9KTtcblx0XHRjb25zdCBhc3N1bWVkTW9kZSA9IGdldE1vZGUoe1xuXHRcdFx0ZW52OiB0aGlzLmVudixcblx0XHRcdGNsaWVudDogdGhpcy5jbGllbnRcblx0XHR9KTtcblx0XHRpZiAoYXNzdW1lZE1vZGUuaXNFeHBsaWNpdCkgdGhpcy5fbW9kZSA9IGFzc3VtZWRNb2RlO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3Qgc2VydmVJc1Byb2QgPSBhd2FpdCBhY3Rpb25zLmlzUHJvZHVjdGlvbj8uKFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIik7XG5cdFx0XHRpZiAodHlwZW9mIHNlcnZlSXNQcm9kID09PSBcImJvb2xlYW5cIikgdGhpcy5fbW9kZSA9IG5ldyBNb2RlKHtcblx0XHRcdFx0dHlwZTogc2VydmVJc1Byb2QgPyBcImNsb3VkXCIgOiBcImRldlwiLFxuXHRcdFx0XHRpc0V4cGxpY2l0OiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRlbHNlIHRoaXMuX21vZGUgPSBhc3N1bWVkTW9kZTtcblx0XHR9XG5cdFx0dGhpcy51cHNlcnRLZXlzRnJvbUVudigpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0aW1lcixcblx0XHRcdGFjdGlvbnMsXG5cdFx0XHRnZXRIZWFkZXJzXG5cdFx0fTtcblx0fVxuXHQvKipcblx0KiBgY3JlYXRlU3luY0hhbmRsZXJgIHNob3VsZCBiZSB1c2VkIHRvIHJldHVybiBhIHR5cGUtZXF1aXZhbGVudCB2ZXJzaW9uIG9mXG5cdCogdGhlIGBoYW5kbGVyYCBzcGVjaWZpZWQgZHVyaW5nIGluc3RhbnRpYXRpb24uXG5cdCovXG5cdGNyZWF0ZVN5bmNIYW5kbGVyKCkge1xuXHRcdHJldHVybiAoaGFuZGxlcikgPT4ge1xuXHRcdFx0cmV0dXJuIHRoaXMud3JhcEhhbmRsZXIoKGFzeW5jICguLi5hcmdzKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlcUluaXQgPSBhd2FpdCB0aGlzLmluaXRSZXF1ZXN0KC4uLmFyZ3MpO1xuXHRcdFx0XHRjb25zdCBmbiA9IG5ldyBJbm5nZXN0RnVuY3Rpb24odGhpcy5jbGllbnQsIHtcblx0XHRcdFx0XHRpZDogdGhpcy5fb3B0aW9ucy5zeW5jT3B0aW9ucz8uZnVuY3Rpb25JZCA/PyBcIlwiLFxuXHRcdFx0XHRcdHJldHJpZXM6IHRoaXMuX29wdGlvbnMuc3luY09wdGlvbnM/LnJldHJpZXMgPz8gZGVmYXVsdE1heFJldHJpZXNcblx0XHRcdFx0fSwgKCkgPT4gaGFuZGxlciguLi5hcmdzKSk7XG5cdFx0XHRcdGlmIChhd2FpdCB0aGlzLmlzSW5uZ2VzdFJlcShyZXFJbml0LmFjdGlvbnMpKSByZXR1cm4gdGhpcy5oYW5kbGVBc3luY1JlcXVlc3Qoe1xuXHRcdFx0XHRcdC4uLnJlcUluaXQsXG5cdFx0XHRcdFx0Zm9yY2VFeGVjdXRpb246IHRydWUsXG5cdFx0XHRcdFx0YXJncyxcblx0XHRcdFx0XHRmbnM6IFtmbl1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmhhbmRsZVN5bmNSZXF1ZXN0KHtcblx0XHRcdFx0XHQuLi5yZXFJbml0LFxuXHRcdFx0XHRcdGFyZ3MsXG5cdFx0XHRcdFx0YXN5bmNNb2RlOiB0aGlzLl9vcHRpb25zLnN5bmNPcHRpb25zPy5hc3luY1Jlc3BvbnNlID8/IEFzeW5jUmVzcG9uc2VUeXBlLlJlZGlyZWN0LFxuXHRcdFx0XHRcdGZuXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSkpO1xuXHRcdH07XG5cdH1cblx0LyoqXG5cdCogYGNyZWF0ZUhhbmRsZXJgIHNob3VsZCBiZSB1c2VkIHRvIHJldHVybiBhIHR5cGUtZXF1aXZhbGVudCB2ZXJzaW9uIG9mIHRoZVxuXHQqIGBoYW5kbGVyYCBzcGVjaWZpZWQgZHVyaW5nIGluc3RhbnRpYXRpb24uXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYFxuXHQqIC8vIG15LWN1c3RvbS1oYW5kbGVyLnRzXG5cdCogaW1wb3J0IHtcblx0KiAgIElubmdlc3RDb21tSGFuZGxlcixcblx0KiAgIHR5cGUgU2VydmVIYW5kbGVyT3B0aW9ucyxcblx0KiB9IGZyb20gXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyXCI7XG5cdCpcblx0KiBleHBvcnQgY29uc3Qgc2VydmUgPSAob3B0aW9uczogU2VydmVIYW5kbGVyT3B0aW9ucykgPT4ge1xuXHQqICAgY29uc3QgaGFuZGxlciA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXIoe1xuXHQqICAgICBmcmFtZXdvcmtOYW1lOiBcIm15LWN1c3RvbS1oYW5kbGVyXCIsXG5cdCogICAgIC4uLm9wdGlvbnMsXG5cdCogICAgIGhhbmRsZXI6IChyZXE6IFJlcXVlc3QpID0+IHtcblx0KiAgICAgICByZXR1cm4ge1xuXHQqICAgICAgICAgYm9keTogKCkgPT4gcmVxLmpzb24oKSxcblx0KiAgICAgICAgIGhlYWRlcnM6IChrZXkpID0+IHJlcS5oZWFkZXJzLmdldChrZXkpLFxuXHQqICAgICAgICAgbWV0aG9kOiAoKSA9PiByZXEubWV0aG9kLFxuXHQqICAgICAgICAgdXJsOiAoKSA9PiBuZXcgVVJMKHJlcS51cmwsIGBodHRwczovLyR7cmVxLmhlYWRlcnMuZ2V0KFwiaG9zdFwiKSB8fCBcIlwifWApLFxuXHQqICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6ICh7IGJvZHksIHN0YXR1cywgaGVhZGVycyB9KSA9PiB7XG5cdCogICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgeyBzdGF0dXMsIGhlYWRlcnMgfSk7XG5cdCogICAgICAgICB9LFxuXHQqICAgICAgIH07XG5cdCogICAgIH0sXG5cdCogICB9KTtcblx0KlxuXHQqICAgcmV0dXJuIGhhbmRsZXIuY3JlYXRlSGFuZGxlcigpO1xuXHQqIH07XG5cdCogYGBgXG5cdCovXG5cdGNyZWF0ZUhhbmRsZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMud3JhcEhhbmRsZXIoKGFzeW5jICguLi5hcmdzKSA9PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVBc3luY1JlcXVlc3Qoe1xuXHRcdFx0XHQuLi5hd2FpdCB0aGlzLmluaXRSZXF1ZXN0KC4uLmFyZ3MpLFxuXHRcdFx0XHRhcmdzXG5cdFx0XHR9KTtcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCogR2l2ZW4gYSBzZXQgb2YgYWN0aW9ucyB0aGF0IGxldCB1cyBhY2Nlc3MgdGhlIGluY29taW5nIHJlcXVlc3QsIGNyZWF0ZSBhXG5cdCogYGh0dHAvcnVuLnN0YXJ0ZWRgIGV2ZW50IHRoYXQgcmVwZXNlbnRzIGEgcnVuIHN0YXJ0aW5nIGZyb20gYW4gSFRUUFxuXHQqIHJlcXVlc3QuXG5cdCovXG5cdGFzeW5jIGNyZWF0ZUh0dHBFdmVudChhY3Rpb25zLCBmbikge1xuXHRcdGNvbnN0IHJlYXNvbiA9IFwiY3JlYXRpbmcgc3luYyBldmVudFwiO1xuXHRcdGNvbnN0IGNvbnRlbnRUeXBlUHJvbWlzZSA9IGFjdGlvbnMuaGVhZGVycyhyZWFzb24sIGhlYWRlcktleXMuQ29udGVudFR5cGUpLnRoZW4oKHYpID0+IHYgPz8gXCJcIik7XG5cdFx0Y29uc3QgaXBQcm9taXNlID0gYWN0aW9ucy5oZWFkZXJzKHJlYXNvbiwgaGVhZGVyS2V5cy5Gb3J3YXJkZWRGb3IpLnRoZW4oKHYpID0+IHtcblx0XHRcdGlmICh2KSByZXR1cm4gdjtcblx0XHRcdHJldHVybiBhY3Rpb25zLmhlYWRlcnMocmVhc29uLCBoZWFkZXJLZXlzLlJlYWxJcCkudGhlbigodiQxKSA9PiB2JDEgPz8gXCJcIik7XG5cdFx0fSk7XG5cdFx0Y29uc3QgbWV0aG9kUHJvbWlzZSA9IGFjdGlvbnMubWV0aG9kKHJlYXNvbik7XG5cdFx0Y29uc3QgdXJsUHJvbWlzZSA9IGFjdGlvbnMudXJsKHJlYXNvbikudGhlbigodikgPT4gdGhpcy5yZXFVcmwodikpO1xuXHRcdGNvbnN0IGRvbWFpblByb21pc2UgPSB1cmxQcm9taXNlLnRoZW4oKHVybCkgPT4gYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdH1gKTtcblx0XHRjb25zdCBwYXRoUHJvbWlzZSA9IHVybFByb21pc2UudGhlbigodXJsKSA9PiB1cmwucGF0aG5hbWUpO1xuXHRcdGNvbnN0IHF1ZXJ5UGFyYW1zUHJvbWlzZSA9IHVybFByb21pc2UudGhlbigodXJsKSA9PiB1cmwuc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCkpO1xuXHRcdGNvbnN0IGJvZHlQcm9taXNlID0gYWN0aW9ucy50ZXh0Qm9keShyZWFzb24pLnRoZW4oKGJvZHkkMSkgPT4ge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBib2R5JDEgPT09IFwic3RyaW5nXCIgPyBib2R5JDEgOiBzdHJpbmdpZnkoYm9keSQxKTtcblx0XHR9KTtcblx0XHRjb25zdCBbY29udGVudFR5cGUsIGRvbWFpbiwgaXAsIG1ldGhvZCwgcGF0aCwgcXVlcnlQYXJhbXMsIGJvZHldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0Y29udGVudFR5cGVQcm9taXNlLFxuXHRcdFx0ZG9tYWluUHJvbWlzZSxcblx0XHRcdGlwUHJvbWlzZSxcblx0XHRcdG1ldGhvZFByb21pc2UsXG5cdFx0XHRwYXRoUHJvbWlzZSxcblx0XHRcdHF1ZXJ5UGFyYW1zUHJvbWlzZSxcblx0XHRcdGJvZHlQcm9taXNlXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IFwiaHR0cC9ydW4uc3RhcnRlZFwiLFxuXHRcdFx0ZGF0YToge1xuXHRcdFx0XHRjb250ZW50X3R5cGU6IGNvbnRlbnRUeXBlLFxuXHRcdFx0XHRkb21haW4sXG5cdFx0XHRcdGlwLFxuXHRcdFx0XHRtZXRob2QsXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHF1ZXJ5X3BhcmFtczogcXVlcnlQYXJhbXMsXG5cdFx0XHRcdGJvZHksXG5cdFx0XHRcdGZuOiBmbi5pZCgpXG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRhc3luYyBoYW5kbGVTeW5jUmVxdWVzdCh7IHRpbWVyLCBhY3Rpb25zLCBmbiwgYXN5bmNNb2RlLCBhcmdzIH0pIHtcblx0XHRpZiAoIWFjdGlvbnMuZXhwZXJpbWVudGFsVHJhbnNmb3JtU3luY1Jlc3BvbnNlKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgc3luY2hyb25vdXMgSW5uZ2VzdCBmdW5jdGlvbiBleGVjdXRpb25zLlwiKTtcblx0XHRpZiAoYXdhaXQgZ2V0QXN5bmNDdHgoKSkgdGhyb3cgbmV3IEVycm9yKFwiV2UgYWxyZWFkeSBzZWVtIHRvIGJlIGluIHRoZSBjb250ZXh0IG9mIGFuIElubmdlc3QgZXhlY3V0aW9uLCBidXQgZGlkbid0IGV4cGVjdCB0byBiZS4gRGlkIHlvdSBhbHJlYWR5IHdyYXAgdGhpcyBoYW5kbGVyP1wiKTtcblx0XHRjb25zdCBydW5JZCA9IHVsaWQoKTtcblx0XHRjb25zdCBldmVudCA9IGF3YWl0IHRoaXMuY3JlYXRlSHR0cEV2ZW50KGFjdGlvbnMsIGZuKTtcblx0XHRjb25zdCBleGVWZXJzaW9uID0gUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OO1xuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuW1wiY3JlYXRlRXhlY3V0aW9uXCJdKHtcblx0XHRcdHZlcnNpb246IGV4ZVZlcnNpb24sXG5cdFx0XHRwYXJ0aWFsT3B0aW9uczoge1xuXHRcdFx0XHRjbGllbnQ6IHRoaXMuY2xpZW50LFxuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0cnVuSWQsXG5cdFx0XHRcdFx0ZXZlbnQsXG5cdFx0XHRcdFx0YXR0ZW1wdDogMCxcblx0XHRcdFx0XHRldmVudHM6IFtldmVudF0sXG5cdFx0XHRcdFx0bWF4QXR0ZW1wdHM6IGZuLm9wdHMucmV0cmllcyA/PyBkZWZhdWx0TWF4UmV0cmllc1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRydW5JZCxcblx0XHRcdFx0aGVhZGVyczoge30sXG5cdFx0XHRcdHJlcUFyZ3M6IGFyZ3MsXG5cdFx0XHRcdHN0ZXBDb21wbGV0aW9uT3JkZXI6IFtdLFxuXHRcdFx0XHRzdGVwU3RhdGU6IHt9LFxuXHRcdFx0XHRkaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uOiBmYWxzZSxcblx0XHRcdFx0aXNGYWlsdXJlSGFuZGxlcjogZmFsc2UsXG5cdFx0XHRcdHRpbWVyLFxuXHRcdFx0XHRjcmVhdGVSZXNwb25zZTogKGRhdGEpID0+IGFjdGlvbnMuZXhwZXJpbWVudGFsVHJhbnNmb3JtU3luY1Jlc3BvbnNlKFwiY3JlYXRpbmcgc3luYyBleGVjdXRpb25cIiwgZGF0YSkudGhlbigocmVzKSA9PiAoe1xuXHRcdFx0XHRcdC4uLnJlcyxcblx0XHRcdFx0XHR2ZXJzaW9uOiBleGVWZXJzaW9uXG5cdFx0XHRcdH0pKSxcblx0XHRcdFx0c3RlcE1vZGU6IFN0ZXBNb2RlLlN5bmNcblx0XHRcdH1cblx0XHR9KS5zdGFydCgpO1xuXHRcdGNvbnN0IHJlc3VsdEhhbmRsZXIgPSB7XG5cdFx0XHRcInN0ZXAtbm90LWZvdW5kXCI6ICgpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiV2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHJlc3VsdCAnc3RlcC1ub3QtZm91bmQnIHdoZW4gY2hlY2twb2ludGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgYGlubmdlc3RgIFNES1wiKTtcblx0XHRcdH0sXG5cdFx0XHRcInN0ZXBzLWZvdW5kXCI6ICgpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiV2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHJlc3VsdCAnc3RlcHMtZm91bmQnIHdoZW4gY2hlY2twb2ludGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgYGlubmdlc3RgIFNES1wiKTtcblx0XHRcdH0sXG5cdFx0XHRcInN0ZXAtcmFuXCI6ICgpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiV2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHJlc3VsdCAnc3RlcC1yYW4nIHdoZW4gY2hlY2twb2ludGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgYGlubmdlc3RgIFNES1wiKTtcblx0XHRcdH0sXG5cdFx0XHRcImZ1bmN0aW9uLXJlamVjdGVkXCI6ICgpID0+IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiV2Ugc2hvdWxkIG5vdCBnZXQgdGhlIHJlc3VsdCAnZnVuY3Rpb24tcmVqZWN0ZWQnIHdoZW4gY2hlY2twb2ludGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgYGlubmdlc3RgIFNES1wiKTtcblx0XHRcdH0sXG5cdFx0XHRcImZ1bmN0aW9uLXJlc29sdmVkXCI6ICh7IGRhdGEgfSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH0sXG5cdFx0XHRcImNoYW5nZS1tb2RlXCI6IGFzeW5jICh7IHRva2VuIH0pID0+IHtcblx0XHRcdFx0c3dpdGNoIChhc3luY01vZGUpIHtcblx0XHRcdFx0XHRjYXNlIEFzeW5jUmVzcG9uc2VUeXBlLlJlZGlyZWN0OiByZXR1cm4gYWN0aW9ucy50cmFuc2Zvcm1SZXNwb25zZShcImNyZWF0aW5nIHN5bmMtPmFzeW5jIHJlZGlyZWN0IHJlc3BvbnNlXCIsIHtcblx0XHRcdFx0XHRcdHN0YXR1czogMzAyLFxuXHRcdFx0XHRcdFx0aGVhZGVyczogeyBbaGVhZGVyS2V5cy5Mb2NhdGlvbl06IGF3YWl0IHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXVtcImdldFRhcmdldFVybFwiXShgL3YxL2h0dHAvcnVucy8ke3J1bklkfS9vdXRwdXQ/dG9rZW49JHt0b2tlbn1gKS50aGVuKCh1cmwpID0+IHVybC50b1N0cmluZygpKSB9LFxuXHRcdFx0XHRcdFx0dmVyc2lvbjogZXhlVmVyc2lvbixcblx0XHRcdFx0XHRcdGJvZHk6IFwiXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjYXNlIEFzeW5jUmVzcG9uc2VUeXBlLlRva2VuOiByZXR1cm4gYWN0aW9ucy50cmFuc2Zvcm1SZXNwb25zZShcImNyZWF0aW5nIHN5bmMtPmFzeW5jIHRva2VuIHJlc3BvbnNlXCIsIHtcblx0XHRcdFx0XHRcdHN0YXR1czogMjAwLFxuXHRcdFx0XHRcdFx0aGVhZGVyczoge30sXG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiBleGVWZXJzaW9uLFxuXHRcdFx0XHRcdFx0Ym9keTogc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRcdFx0cnVuX2lkOiBydW5JZCxcblx0XHRcdFx0XHRcdFx0dG9rZW5cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0ZGVmYXVsdDogYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBjaGFuZ2UtbW9kZVwiKTtcblx0XHRcdH1cblx0XHR9W3Jlc3VsdC50eXBlXTtcblx0XHRpZiAoIXJlc3VsdEhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihgTm8gaGFuZGxlciBmb3IgZXhlY3V0aW9uIHJlc3VsdCB0eXBlOiAke3Jlc3VsdC50eXBlfS4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgXFxgaW5uZ2VzdFxcYCBTREtgKTtcblx0XHRyZXR1cm4gcmVzdWx0SGFuZGxlcihyZXN1bHQpO1xuXHR9XG5cdGFzeW5jIGhhbmRsZUFzeW5jUmVxdWVzdCh7IHRpbWVyLCBhY3Rpb25zLCBhcmdzLCBnZXRIZWFkZXJzLCBmb3JjZUV4ZWN1dGlvbiwgZm5zIH0pIHtcblx0XHRpZiAoZm9yY2VFeGVjdXRpb24gJiYgIWFjdGlvbnMuZXhwZXJpbWVudGFsVHJhbnNmb3JtU3luY1Jlc3BvbnNlKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgYXN5bmMgZXhlY3V0aW9ucyBpbiBJbm5nZXN0IGZvciBBUElzLlwiKTtcblx0XHRjb25zdCBtZXRob2RQID0gYWN0aW9ucy5tZXRob2QoXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKTtcblx0XHRjb25zdCBjb250ZW50TGVuZ3RoID0gYXdhaXQgYWN0aW9ucy5oZWFkZXJzKFwiY2hlY2tpbmcgc2lnbmF0dXJlIGZvciByZXF1ZXN0XCIsIGhlYWRlcktleXMuQ29udGVudExlbmd0aCkudGhlbigodmFsdWUpID0+IHtcblx0XHRcdGlmICghdmFsdWUpIHJldHVybjtcblx0XHRcdHJldHVybiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKTtcblx0XHR9KTtcblx0XHRjb25zdCBbc2lnbmF0dXJlLCBtZXRob2QsIGJvZHldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0YWN0aW9ucy5oZWFkZXJzKFwiY2hlY2tpbmcgc2lnbmF0dXJlIGZvciByZXF1ZXN0XCIsIGhlYWRlcktleXMuU2lnbmF0dXJlKS50aGVuKChoZWFkZXJTaWduYXR1cmUpID0+IHtcblx0XHRcdFx0cmV0dXJuIGhlYWRlclNpZ25hdHVyZSA/PyB2b2lkIDA7XG5cdFx0XHR9KSxcblx0XHRcdG1ldGhvZFAsXG5cdFx0XHRtZXRob2RQLnRoZW4oKG1ldGhvZCQxKSA9PiB7XG5cdFx0XHRcdGlmIChtZXRob2QkMSA9PT0gXCJQT1NUXCIgfHwgbWV0aG9kJDEgPT09IFwiUFVUXCIpIHtcblx0XHRcdFx0XHRpZiAoIWNvbnRlbnRMZW5ndGgpIHJldHVybiBcIlwiO1xuXHRcdFx0XHRcdHJldHVybiBhY3Rpb25zLmJvZHkoYGNoZWNraW5nIGJvZHkgZm9yIHJlcXVlc3Qgc2lnbmluZyBhcyBtZXRob2QgaXMgJHttZXRob2QkMX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdH0pXG5cdFx0XSk7XG5cdFx0Y29uc3Qgc2lnbmF0dXJlVmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlLCBib2R5KTtcblx0XHRjb25zdCBhY3Rpb25SZXMgPSB0aW1lci53cmFwKFwiYWN0aW9uXCIsICgpID0+IHRoaXMuaGFuZGxlQWN0aW9uKHtcblx0XHRcdGFjdGlvbnMsXG5cdFx0XHR0aW1lcixcblx0XHRcdGdldEhlYWRlcnMsXG5cdFx0XHRyZXFBcmdzOiBhcmdzLFxuXHRcdFx0c2lnbmF0dXJlVmFsaWRhdGlvbixcblx0XHRcdGJvZHksXG5cdFx0XHRtZXRob2QsXG5cdFx0XHRmb3JjZUV4ZWN1dGlvbjogQm9vbGVhbihmb3JjZUV4ZWN1dGlvbiksXG5cdFx0XHRmbnNcblx0XHR9KSk7XG5cdFx0LyoqXG5cdFx0KiBQcmVwYXJlcyBhbiBhY3Rpb24gcmVzcG9uc2UgYnkgbWVyZ2luZyByZXR1cm5lZCBkYXRhIHRvIHByb3ZpZGVcblx0XHQqIHRyYWlsaW5nIGluZm9ybWF0aW9uIHN1Y2ggYXMgYFNlcnZlci1UaW1pbmdgIGhlYWRlcnMuXG5cdFx0KlxuXHRcdCogSXQgc2hvdWxkIGFsd2F5cyBwcmlvcml0aXplIHRoZSBoZWFkZXJzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24sIGFzIHRoZXlcblx0XHQqIG1heSBjb250YWluIGltcG9ydGFudCBpbmZvcm1hdGlvbiBzdWNoIGFzIGBDb250ZW50LVR5cGVgLlxuXHRcdCovXG5cdFx0Y29uc3QgcHJlcGFyZUFjdGlvblJlcyA9IGFzeW5jIChyZXMpID0+IHtcblx0XHRcdGNvbnN0IGhlYWRlcnMgPSB7XG5cdFx0XHRcdC4uLmF3YWl0IGdldEhlYWRlcnMoKSxcblx0XHRcdFx0Li4ucmVzLmhlYWRlcnMsXG5cdFx0XHRcdC4uLnJlcy52ZXJzaW9uID09PSBudWxsID8ge30gOiB7IFtoZWFkZXJLZXlzLlJlcXVlc3RWZXJzaW9uXTogKHJlcy52ZXJzaW9uID8/IFBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTikudG9TdHJpbmcoKSB9XG5cdFx0XHR9O1xuXHRcdFx0bGV0IHNpZ25hdHVyZSQxO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2lnbmF0dXJlJDEgPSBhd2FpdCBzaWduYXR1cmVWYWxpZGF0aW9uLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0XHRcdGlmICghcmVzdWx0LnN1Y2Nlc3MgfHwgIXJlc3VsdC5rZXlVc2VkKSByZXR1cm47XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmVzcG9uc2VTaWduYXR1cmUocmVzdWx0LmtleVVzZWQsIHJlcy5ib2R5KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHQuLi5yZXMsXG5cdFx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoc2VyaWFsaXplRXJyb3IoZXJyKSksXG5cdFx0XHRcdFx0c3RhdHVzOiA1MDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChzaWduYXR1cmUkMSkgaGVhZGVyc1toZWFkZXJLZXlzLlNpZ25hdHVyZV0gPSBzaWduYXR1cmUkMTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC4uLnJlcyxcblx0XHRcdFx0aGVhZGVyc1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdGlmIChhd2FpdCB0aGlzLnNob3VsZFN0cmVhbShhY3Rpb25zKSkge1xuXHRcdFx0aWYgKGF3YWl0IGFjdGlvbnMubWV0aG9kKFwic3RhcnRpbmcgc3RyZWFtaW5nIHJlc3BvbnNlXCIpID09PSBcIlBPU1RcIikge1xuXHRcdFx0XHRjb25zdCB7IHN0cmVhbSwgZmluYWxpemUgfSA9IGF3YWl0IGNyZWF0ZVN0cmVhbSgpO1xuXHRcdFx0XHQvKipcblx0XHRcdFx0KiBFcnJvcnMgYXJlIGhhbmRsZWQgYnkgYGhhbmRsZUFjdGlvbmAgaGVyZSB0byBlbnN1cmUgdGhhdCBhblxuXHRcdFx0XHQqIGFwcHJvcHJpYXRlIHJlc3BvbnNlIGlzIGFsd2F5cyBnaXZlbi5cblx0XHRcdFx0Ki9cblx0XHRcdFx0YWN0aW9uUmVzLnRoZW4oKHJlcykgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBmaW5hbGl6ZShwcmVwYXJlQWN0aW9uUmVzKHJlcykpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIHRpbWVyLndyYXAoXCJyZXNcIiwgYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBhY3Rpb25zLnRyYW5zZm9ybVN0cmVhbWluZ1Jlc3BvbnNlPy4oXCJzdGFydGluZyBzdHJlYW1pbmcgcmVzcG9uc2VcIiwge1xuXHRcdFx0XHRcdFx0c3RhdHVzOiAyMDEsXG5cdFx0XHRcdFx0XHRoZWFkZXJzOiBhd2FpdCBnZXRIZWFkZXJzKCksXG5cdFx0XHRcdFx0XHRib2R5OiBzdHJlYW0sXG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiBudWxsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGltZXIud3JhcChcInJlc1wiLCBhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gYWN0aW9uUmVzLnRoZW4ocHJlcGFyZUFjdGlvblJlcykudGhlbigoYWN0aW9uUmVzJDEpID0+IHtcblx0XHRcdFx0cmV0dXJuIGFjdGlvbnMudHJhbnNmb3JtUmVzcG9uc2UoXCJzZW5kaW5nIGJhY2sgcmVzcG9uc2VcIiwgYWN0aW9uUmVzJDEpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblx0YXN5bmMgZ2V0QWN0aW9ucyh0aW1lciwgLi4uYXJncykge1xuXHRcdC8qKlxuXHRcdCogVXNlZCBmb3IgdGVzdGluZywgYWxsb3cgc2V0dGluZyBhY3Rpb24gb3ZlcnJpZGVzIGV4dGVybmFsbHkgd2hlblxuXHRcdCogY2FsbGluZyB0aGUgaGFuZGxlci4gQWx3YXlzIHNlYXJjaCB0aGUgZmluYWwgYXJndW1lbnQuXG5cdFx0Ki9cblx0XHRjb25zdCBsYXN0QXJnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXHRcdGNvbnN0IGFjdGlvbk92ZXJyaWRlcyA9IHR5cGVvZiBsYXN0QXJnID09PSBcIm9iamVjdFwiICYmIGxhc3RBcmcgIT09IG51bGwgJiYgXCJhY3Rpb25PdmVycmlkZXNcIiBpbiBsYXN0QXJnICYmIHR5cGVvZiBsYXN0QXJnW1wiYWN0aW9uT3ZlcnJpZGVzXCJdID09PSBcIm9iamVjdFwiICYmIGxhc3RBcmdbXCJhY3Rpb25PdmVycmlkZXNcIl0gIT09IG51bGwgPyBsYXN0QXJnW1wiYWN0aW9uT3ZlcnJpZGVzXCJdIDoge307XG5cdFx0LyoqXG5cdFx0KiBXZSBwdXJwb3NlZnVsbHkgYGF3YWl0YCB0aGUgaGFuZGxlciwgYXMgaXQgY291bGQgYmUgZWl0aGVyIHN5bmMgb3Jcblx0XHQqIGFzeW5jLlxuXHRcdCovXG5cdFx0Y29uc3QgcmF3QWN0aW9ucyA9IHtcblx0XHRcdC4uLmF3YWl0IHRpbWVyLndyYXAoXCJoYW5kbGVyXCIsICgpID0+IHRoaXMuaGFuZGxlciguLi5hcmdzKSkuY2F0Y2gocmV0aHJvd0Vycm9yKFwiU2VydmUgaGFuZGxlciBmYWlsZWQgdG8gcnVuXCIpKSxcblx0XHRcdC4uLmFjdGlvbk92ZXJyaWRlc1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0KiBNYXBwZWQgcHJvbWlzaWZpZWQgaGFuZGxlcnMgZnJvbSB1c2VybGFuZCBgc2VydmUoKWAgZnVuY3Rpb24gbWl4ZWQgaW5cblx0XHQqIHdpdGggc29tZSBoZWxwZXJzLlxuXHRcdCovXG5cdFx0Y29uc3QgYWN0aW9ucyA9IHtcblx0XHRcdC4uLk9iamVjdC5lbnRyaWVzKHJhd0FjdGlvbnMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYWNjO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdC4uLmFjYyxcblx0XHRcdFx0XHRba2V5XTogKHJlYXNvbiwgLi4uYXJncyQxKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBlcnJNZXNzYWdlID0gW2BGYWlsZWQgY2FsbGluZyBcXGAke2tleX1cXGAgZnJvbSBzZXJ2ZSBoYW5kbGVyYCwgcmVhc29uXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiB3aGVuIFwiKTtcblx0XHRcdFx0XHRcdGNvbnN0IGZuID0gKCkgPT4gdmFsdWUoLi4uYXJncyQxKTtcblx0XHRcdFx0XHRcdHJldHVybiBydW5Bc1Byb21pc2UoZm4pLmNhdGNoKHJldGhyb3dFcnJvcihlcnJNZXNzYWdlKSkuY2F0Y2goKGVycikgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxvZyhcImVycm9yXCIsIGVycik7XG5cdFx0XHRcdFx0XHRcdHRocm93IGVycjtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sIHt9KSxcblx0XHRcdHF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzOiBhc3luYyAocmVhc29uLCBrZXkpID0+IHtcblx0XHRcdFx0Y29uc3QgdXJsID0gYXdhaXQgYWN0aW9ucy51cmwocmVhc29uKTtcblx0XHRcdFx0cmV0dXJuIGF3YWl0IGFjdGlvbnMucXVlcnlTdHJpbmc/LihyZWFzb24sIGtleSwgdXJsKSB8fCB1cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpIHx8IHZvaWQgMDtcblx0XHRcdH0sXG5cdFx0XHQuLi5hY3Rpb25PdmVycmlkZXNcblx0XHR9O1xuXHRcdHJldHVybiBhY3Rpb25zO1xuXHR9XG5cdHdyYXBIYW5kbGVyKGhhbmRsZXIpIHtcblx0XHQvKipcblx0XHQqIFNvbWUgcGxhdGZvcm1zIGNoZWNrIChhdCBydW50aW1lKSB0aGUgbGVuZ3RoIG9mIHRoZSBmdW5jdGlvbiBiZWluZyB1c2VkXG5cdFx0KiB0byBoYW5kbGUgYW4gZW5kcG9pbnQuIElmIHRoaXMgaXMgYSB2YXJpYWRpYyBmdW5jdGlvbiwgaXQgd2lsbCBmYWlsIHRoYXRcblx0XHQqIGNoZWNrLlxuXHRcdCpcblx0XHQqIFRoZXJlZm9yZSwgd2UgZXhwZWN0IHRoZSBhcmd1bWVudHMgYWNjZXB0ZWQgdG8gYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuXHRcdCogYGhhbmRsZXJgIGZ1bmN0aW9uIHBhc3NlZCBpbnRlcm5hbGx5LlxuXHRcdCpcblx0XHQqIFdlIGFsc28gc2V0IGEgbmFtZSB0byBhdm9pZCBhIGNvbW1vbiB1c2VsZXNzIG5hbWUgaW4gdHJhY2luZyBzdWNoIGFzXG5cdFx0KiBgXCJhbm9ueW1vdXNcImAgb3IgYFwiYm91bmQgZnVuY3Rpb25cImAuXG5cdFx0KlxuXHRcdCogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdC9pc3N1ZXMvMzI4NFxuXHRcdCovXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaGFuZGxlciwge1xuXHRcdFx0bmFtZTogeyB2YWx1ZTogXCJJbm5nZXN0SGFuZGxlclwiIH0sXG5cdFx0XHRsZW5ndGg6IHsgdmFsdWU6IHRoaXMuaGFuZGxlci5sZW5ndGggfVxuXHRcdH0pO1xuXHRcdHJldHVybiBoYW5kbGVyO1xuXHR9XG5cdGdldCBtb2RlKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb2RlO1xuXHR9XG5cdHNldCBtb2RlKG0pIHtcblx0XHR0aGlzLl9tb2RlID0gbTtcblx0XHRpZiAobSkgdGhpcy5jbGllbnRbXCJtb2RlXCJdID0gbTtcblx0fVxuXHQvKipcblx0KiBHaXZlbiBhIHNldCBvZiBmdW5jdGlvbnMgdG8gY2hlY2sgaWYgYW4gYWN0aW9uIGlzIGF2YWlsYWJsZSBmcm9tIHRoZVxuXHQqIGluc3RhbmNlJ3MgaGFuZGxlciwgZW5hY3QgYW55IGFjdGlvbiB0aGF0IGlzIGZvdW5kLlxuXHQqXG5cdCogVGhpcyBtZXRob2QgY2FuIGZldGNoIHZhcnlpbmcgcGF5bG9hZHMgb2YgZGF0YSwgYnV0IHVsdGltYXRlbHkgaXMgdGhlIHBsYWNlXG5cdCogd2hlcmUgX2RlY2lzaW9uc18gYXJlIG1hZGUgcmVnYXJkaW5nIGZ1bmN0aW9uYWxpdHkuXG5cdCpcblx0KiBGb3IgZXhhbXBsZSwgaWYgd2UgZmluZCB0aGF0IHdlIHNob3VsZCBiZSB2aWV3aW5nIHRoZSBVSSwgdGhpcyBmdW5jdGlvblxuXHQqIHdpbGwgZGVjaWRlIHdoZXRoZXIgdGhlIFVJIHNob3VsZCBiZSB2aXNpYmxlIGJhc2VkIG9uIHRoZSBwYXlsb2FkIGl0IGhhc1xuXHQqIGZvdW5kIChlLmcuIGVudiB2YXJzLCBvcHRpb25zLCBldGMpLlxuXHQqL1xuXHRhc3luYyBoYW5kbGVBY3Rpb24oeyBhY3Rpb25zLCB0aW1lciwgZ2V0SGVhZGVycywgcmVxQXJncywgc2lnbmF0dXJlVmFsaWRhdGlvbiwgYm9keTogcmF3Qm9keSwgbWV0aG9kLCBmb3JjZUV4ZWN1dGlvbiwgZm5zIH0pIHtcblx0XHRjb25zdCBpc01pc3NpbmdCb2R5ID0gcmF3Qm9keSA9PT0gdm9pZCAwO1xuXHRcdGxldCBib2R5ID0gcmF3Qm9keTtcblx0XHR0cnkge1xuXHRcdFx0bGV0IHVybCA9IGF3YWl0IGFjdGlvbnMudXJsKFwic3RhcnRpbmcgdG8gaGFuZGxlIHJlcXVlc3RcIik7XG5cdFx0XHRpZiAobWV0aG9kID09PSBcIlBPU1RcIiB8fCBmb3JjZUV4ZWN1dGlvbikge1xuXHRcdFx0XHRpZiAoIWZvcmNlRXhlY3V0aW9uICYmIGlzTWlzc2luZ0JvZHkpIHtcblx0XHRcdFx0XHR0aGlzLmxvZyhcImVycm9yXCIsIFwiTWlzc2luZyBib2R5IHdoZW4gZXhlY3V0aW5nLCBwb3NzaWJseSBkdWUgdG8gbWlzc2luZyByZXF1ZXN0IGJvZHkgbWlkZGxld2FyZVwiKTtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0c3RhdHVzOiA1MDAsXG5cdFx0XHRcdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoc2VyaWFsaXplRXJyb3IoLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWVzdCBib2R5IHdoZW4gZXhlY3V0aW5nLCBwb3NzaWJseSBkdWUgdG8gbWlzc2luZyByZXF1ZXN0IGJvZHkgbWlkZGxld2FyZVwiKSkpLFxuXHRcdFx0XHRcdFx0dmVyc2lvbjogdm9pZCAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2lnbmF0dXJlVmFsaWRhdGlvbjtcblx0XHRcdFx0aWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHJldHVybiB7XG5cdFx0XHRcdFx0c3RhdHVzOiA0MDEsXG5cdFx0XHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdFx0XHRcdGJvZHk6IHN0cmluZ2lmeShzZXJpYWxpemVFcnJvcih2YWxpZGF0aW9uUmVzdWx0LmVycikpLFxuXHRcdFx0XHRcdHZlcnNpb246IHZvaWQgMFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRsZXQgZm47XG5cdFx0XHRcdGxldCBmbklkO1xuXHRcdFx0XHRsZXQgc3RlcElkO1xuXHRcdFx0XHRpZiAoZm9yY2VFeGVjdXRpb24pIHtcblx0XHRcdFx0XHRmbiA9IGZucz8ubGVuZ3RoICYmIGZuc1swXSA/IHtcblx0XHRcdFx0XHRcdGZuOiBmbnNbMF0sXG5cdFx0XHRcdFx0XHRvbkZhaWx1cmU6IGZhbHNlXG5cdFx0XHRcdFx0fSA6IE9iamVjdC52YWx1ZXModGhpcy5mbnMpWzBdO1xuXHRcdFx0XHRcdGZuSWQgPSBmbj8uZm4uaWQoKTtcblx0XHRcdFx0XHRzdGVwSWQgPSBcInN0ZXBcIjtcblx0XHRcdFx0XHRib2R5ID0ge1xuXHRcdFx0XHRcdFx0ZXZlbnQ6IHt9LFxuXHRcdFx0XHRcdFx0ZXZlbnRzOiBbXSxcblx0XHRcdFx0XHRcdHN0ZXBzOiB7fSxcblx0XHRcdFx0XHRcdHZlcnNpb246IFBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTixcblx0XHRcdFx0XHRcdGN0eDoge1xuXHRcdFx0XHRcdFx0XHRhdHRlbXB0OiAwLFxuXHRcdFx0XHRcdFx0XHRkaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb246IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHR1c2VfYXBpOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRtYXhfYXR0ZW1wdHM6IDMsXG5cdFx0XHRcdFx0XHRcdHJ1bl9pZDogYXdhaXQgYWN0aW9ucy5oZWFkZXJzKFwiZ2V0dGluZyBydW4gSUQgZm9yIGZvcmNlZCBleGVjdXRpb25cIiwgaGVhZGVyS2V5cy5Jbm5nZXN0UnVuSWQpLFxuXHRcdFx0XHRcdFx0XHRzdGFjazoge1xuXHRcdFx0XHRcdFx0XHRcdHN0YWNrOiBbXSxcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50OiAwXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHJhd1Byb2JlID0gYXdhaXQgYWN0aW9ucy5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInRlc3RpbmcgZm9yIHByb2JlXCIsIHF1ZXJ5S2V5cy5Qcm9iZSk7XG5cdFx0XHRcdFx0aWYgKHJhd1Byb2JlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwcm9iZSQxID0gZW51bUZyb21WYWx1ZShwcm9iZSwgcmF3UHJvYmUpO1xuXHRcdFx0XHRcdFx0aWYgKCFwcm9iZSQxKSByZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRzdGF0dXM6IDQwMCxcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoc2VyaWFsaXplRXJyb3IoLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcihgVW5rbm93biBwcm9iZSBcIiR7cmF3UHJvYmV9XCJgKSkpLFxuXHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiB2b2lkIDBcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBbcHJvYmUuVHJ1c3RdOiAoKSA9PiAoe1xuXHRcdFx0XHRcdFx0XHRzdGF0dXM6IDIwMCxcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiBcIlwiLFxuXHRcdFx0XHRcdFx0XHR2ZXJzaW9uOiB2b2lkIDBcblx0XHRcdFx0XHRcdH0pIH1bcHJvYmUkMV0oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm5JZCA9IGF3YWl0IGFjdGlvbnMucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJwcm9jZXNzaW5nIHJ1biByZXF1ZXN0XCIsIHF1ZXJ5S2V5cy5GbklkKTtcblx0XHRcdFx0XHRpZiAoIWZuSWQpIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIElEIGZvdW5kIGluIGFzeW5jIHJlcXVlc3RcIik7XG5cdFx0XHRcdFx0Zm4gPSB0aGlzLmZuc1tmbklkXTtcblx0XHRcdFx0XHRzdGVwSWQgPSBhd2FpdCBhY3Rpb25zLnF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzKFwicHJvY2Vzc2luZyBydW4gcmVxdWVzdFwiLCBxdWVyeUtleXMuU3RlcElkKSB8fCBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgZm5JZCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhZm4pIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIElEIGZvdW5kIGluIHJlcXVlc3RcIik7XG5cdFx0XHRcdGNvbnN0IHsgdmVyc2lvbjogdmVyc2lvbiQxLCByZXN1bHQgfSA9IHRoaXMucnVuU3RlcCh7XG5cdFx0XHRcdFx0ZnVuY3Rpb25JZDogZm5JZCxcblx0XHRcdFx0XHRkYXRhOiBib2R5LFxuXHRcdFx0XHRcdHN0ZXBJZCxcblx0XHRcdFx0XHR0aW1lcixcblx0XHRcdFx0XHRyZXFBcmdzLFxuXHRcdFx0XHRcdGhlYWRlcnM6IGF3YWl0IGdldEhlYWRlcnMoKSxcblx0XHRcdFx0XHRmbixcblx0XHRcdFx0XHRmb3JjZUV4ZWN1dGlvbixcblx0XHRcdFx0XHRhY3Rpb25zXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjb25zdCBzdGVwT3V0cHV0ID0gYXdhaXQgcmVzdWx0O1xuXHRcdFx0XHQvKipcblx0XHRcdFx0KiBGdW5jdGlvbnMgY2FuIHJldHVybiBgdW5kZWZpbmVkYCwgYnV0IHdlJ2xsIGFsd2F5cyBjb252ZXJ0IHRoaXMgdG9cblx0XHRcdFx0KiBgbnVsbGAsIGFzIHRoaXMgaXMgYXBwcm9wcmlhdGVseSBzZXJpYWxpemFibGUgYnkgSlNPTi5cblx0XHRcdFx0Ki9cblx0XHRcdFx0Y29uc3Qgb3BEYXRhVW5kZWZpbmVkVG9OdWxsID0gKG9wKSA9PiB7XG5cdFx0XHRcdFx0b3AuZGF0YSA9IHVuZGVmaW5lZFRvTnVsbChvcC5kYXRhKTtcblx0XHRcdFx0XHRyZXR1cm4gb3A7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGNvbnN0IGhhbmRsZXIgPSB7XG5cdFx0XHRcdFx0XCJmdW5jdGlvbi1yZWplY3RlZFwiOiAocmVzdWx0JDEpID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHN0YXR1czogcmVzdWx0JDEucmV0cmlhYmxlID8gNTAwIDogNDAwLFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdFx0XHRcdFx0XHRcdFx0W2hlYWRlcktleXMuTm9SZXRyeV06IHJlc3VsdCQxLnJldHJpYWJsZSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdC4uLnR5cGVvZiByZXN1bHQkMS5yZXRyaWFibGUgPT09IFwic3RyaW5nXCIgPyB7IFtoZWFkZXJLZXlzLlJldHJ5QWZ0ZXJdOiByZXN1bHQkMS5yZXRyaWFibGUgfSA6IHt9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHN0cmluZ2lmeSh1bmRlZmluZWRUb051bGwocmVzdWx0JDEuZXJyb3IpKSxcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJmdW5jdGlvbi1yZXNvbHZlZFwiOiAocmVzdWx0JDEpID0+IHtcblx0XHRcdFx0XHRcdGlmIChmb3JjZUV4ZWN1dGlvbikge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBydW5Db21wbGV0ZU9wID0ge1xuXHRcdFx0XHRcdFx0XHRcdGlkOiBfaW50ZXJuYWxzLmhhc2hJZChcImNvbXBsZXRlXCIpLFxuXHRcdFx0XHRcdFx0XHRcdG9wOiBTdGVwT3BDb2RlLlJ1bkNvbXBsZXRlLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGE6IHVuZGVmaW5lZFRvTnVsbChyZXN1bHQkMS5kYXRhKVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1czogMjA2LFxuXHRcdFx0XHRcdFx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHRcdFx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkocnVuQ29tcGxldGVPcCksXG5cdFx0XHRcdFx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRzdGF0dXM6IDIwMCxcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkodW5kZWZpbmVkVG9OdWxsKHJlc3VsdCQxLmRhdGEpKSxcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJzdGVwLW5vdC1mb3VuZFwiOiAocmVzdWx0JDEpID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHN0YXR1czogNTAwLFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdFx0XHRcdFx0XHRcdFx0W2hlYWRlcktleXMuTm9SZXRyeV06IFwiZmFsc2VcIlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoeyBlcnJvcjogYENvdWxkIG5vdCBmaW5kIHN0ZXAgXCIke3Jlc3VsdCQxLnN0ZXAuZGlzcGxheU5hbWUgfHwgcmVzdWx0JDEuc3RlcC5pZH1cIiB0byBydW47IHRpbWVkIG91dGAgfSksXG5cdFx0XHRcdFx0XHRcdHZlcnNpb246IHZlcnNpb24kMVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFwic3RlcC1yYW5cIjogKHJlc3VsdCQxKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdGVwID0gb3BEYXRhVW5kZWZpbmVkVG9OdWxsKHJlc3VsdCQxLnN0ZXApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0c3RhdHVzOiAyMDYsXG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcblx0XHRcdFx0XHRcdFx0XHQuLi50eXBlb2YgcmVzdWx0JDEucmV0cmlhYmxlICE9PSBcInVuZGVmaW5lZFwiID8ge1xuXHRcdFx0XHRcdFx0XHRcdFx0W2hlYWRlcktleXMuTm9SZXRyeV06IHJlc3VsdCQxLnJldHJpYWJsZSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0Li4udHlwZW9mIHJlc3VsdCQxLnJldHJpYWJsZSA9PT0gXCJzdHJpbmdcIiA/IHsgW2hlYWRlcktleXMuUmV0cnlBZnRlcl06IHJlc3VsdCQxLnJldHJpYWJsZSB9IDoge31cblx0XHRcdFx0XHRcdFx0XHR9IDoge31cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Ym9keTogc3RyaW5naWZ5KFtzdGVwXSksXG5cdFx0XHRcdFx0XHRcdHZlcnNpb246IHZlcnNpb24kMVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFwic3RlcHMtZm91bmRcIjogKHJlc3VsdCQxKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdGVwcyA9IHJlc3VsdCQxLnN0ZXBzLm1hcChvcERhdGFVbmRlZmluZWRUb051bGwpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0c3RhdHVzOiAyMDYsXG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHRcdFx0XHRcdFx0Ym9keTogc3RyaW5naWZ5KHN0ZXBzKSxcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJjaGFuZ2UtbW9kZVwiOiAocmVzdWx0JDEpID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHN0YXR1czogNTAwLFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdFx0XHRcdFx0XHRcdFx0W2hlYWRlcktleXMuTm9SZXRyeV06IFwidHJ1ZVwiXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHN0cmluZ2lmeSh7IGVycm9yOiBgV2Ugd2FudGVkIHRvIGNoYW5nZSBtb2RlIHRvIFwiJHtyZXN1bHQkMS50b31cIiwgYnV0IHRoaXMgaXMgbm90IHN1cHBvcnRlZCB3aXRoaW4gdGhlIElubmdlc3RDb21tSGFuZGxlci4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgSW5uZ2VzdCBTREsuYCB9KSxcblx0XHRcdFx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVtzdGVwT3V0cHV0LnR5cGVdO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBhd2FpdCBoYW5kbGVyKHN0ZXBPdXRwdXQpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHR0aGlzLmxvZyhcImVycm9yXCIsIFwiRXJyb3IgaGFuZGxpbmcgZXhlY3V0aW9uIHJlc3VsdFwiLCBlcnIpO1xuXHRcdFx0XHRcdHRocm93IGVycjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgZW52ID0gKGF3YWl0IGdldEhlYWRlcnMoKSlbaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0gPz8gbnVsbDtcblx0XHRcdGlmIChtZXRob2QgPT09IFwiR0VUXCIpIHJldHVybiB7XG5cdFx0XHRcdHN0YXR1czogMjAwLFxuXHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoYXdhaXQgdGhpcy5pbnRyb3NwZWN0aW9uQm9keSh7XG5cdFx0XHRcdFx0YWN0aW9ucyxcblx0XHRcdFx0XHRlbnYsXG5cdFx0XHRcdFx0c2lnbmF0dXJlVmFsaWRhdGlvbixcblx0XHRcdFx0XHR1cmxcblx0XHRcdFx0fSkpLFxuXHRcdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0XHRcdHZlcnNpb246IHZvaWQgMFxuXHRcdFx0fTtcblx0XHRcdGlmIChtZXRob2QgPT09IFwiUFVUXCIpIHtcblx0XHRcdFx0Y29uc3QgW2RlcGxveUlkLCBpbkJhbmRTeW5jUmVxdWVzdGVkXSA9IGF3YWl0IFByb21pc2UuYWxsKFthY3Rpb25zLnF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzKFwicHJvY2Vzc2luZyBkZXBsb3ltZW50IHJlcXVlc3RcIiwgcXVlcnlLZXlzLkRlcGxveUlkKS50aGVuKChkZXBsb3lJZCQxKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIGRlcGxveUlkJDEgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiBkZXBsb3lJZCQxO1xuXHRcdFx0XHR9KSwgUHJvbWlzZS5yZXNvbHZlKHBhcnNlQXNCb29sZWFuKHRoaXMuZW52W2VudktleXMuSW5uZ2VzdEFsbG93SW5CYW5kU3luY10pKS50aGVuKChhbGxvd0luQmFuZFN5bmMpID0+IHtcblx0XHRcdFx0XHRpZiAoYWxsb3dJbkJhbmRTeW5jICE9PSB2b2lkIDAgJiYgIWFsbG93SW5CYW5kU3luYykgcmV0dXJuIHN5bmNLaW5kLk91dE9mQmFuZDtcblx0XHRcdFx0XHRyZXR1cm4gYWN0aW9ucy5oZWFkZXJzKFwicHJvY2Vzc2luZyBkZXBsb3ltZW50IHJlcXVlc3RcIiwgaGVhZGVyS2V5cy5Jbm5nZXN0U3luY0tpbmQpO1xuXHRcdFx0XHR9KS50aGVuKChraW5kKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIGtpbmQgPT09IHN5bmNLaW5kLkluQmFuZDtcblx0XHRcdFx0fSldKTtcblx0XHRcdFx0aWYgKGluQmFuZFN5bmNSZXF1ZXN0ZWQpIHtcblx0XHRcdFx0XHRpZiAoaXNNaXNzaW5nQm9keSkge1xuXHRcdFx0XHRcdFx0dGhpcy5sb2coXCJlcnJvclwiLCBcIk1pc3NpbmcgYm9keSB3aGVuIHN5bmNpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0c3RhdHVzOiA1MDAsXG5cdFx0XHRcdFx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHRcdFx0XHRcdFx0Ym9keTogc3RyaW5naWZ5KHNlcmlhbGl6ZUVycm9yKC8qIEBfX1BVUkVfXyAqLyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVlc3QgYm9keSB3aGVuIHN5bmNpbmcsIHBvc3NpYmx5IGR1ZSB0byBtaXNzaW5nIHJlcXVlc3QgYm9keSBtaWRkbGV3YXJlXCIpKSksXG5cdFx0XHRcdFx0XHRcdHZlcnNpb246IHZvaWQgMFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCEoYXdhaXQgc2lnbmF0dXJlVmFsaWRhdGlvbikuc3VjY2VzcykgcmV0dXJuIHtcblx0XHRcdFx0XHRcdHN0YXR1czogNDAxLFxuXHRcdFx0XHRcdFx0Ym9keTogc3RyaW5naWZ5KHsgY29kZTogXCJzaWdfdmVyaWZpY2F0aW9uX2ZhaWxlZFwiIH0pLFxuXHRcdFx0XHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdFx0XHRcdFx0dmVyc2lvbjogdm9pZCAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRjb25zdCByZXMgPSBpbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEuc2FmZVBhcnNlKGJvZHkpO1xuXHRcdFx0XHRcdGlmICghcmVzLnN1Y2Nlc3MpIHJldHVybiB7XG5cdFx0XHRcdFx0XHRzdGF0dXM6IDQwMCxcblx0XHRcdFx0XHRcdGJvZHk6IHN0cmluZ2lmeSh7XG5cdFx0XHRcdFx0XHRcdGNvZGU6IFwiaW52YWxpZF9yZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlXG5cdFx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHRcdFx0XHRcdHZlcnNpb246IHZvaWQgMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dXJsID0gdGhpcy5yZXFVcmwobmV3IFVSTChyZXMuZGF0YS51cmwpKTtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0c3RhdHVzOiAyMDAsXG5cdFx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoYXdhaXQgdGhpcy5pbkJhbmRSZWdpc3RlckJvZHkoe1xuXHRcdFx0XHRcdFx0XHRhY3Rpb25zLFxuXHRcdFx0XHRcdFx0XHRkZXBsb3lJZCxcblx0XHRcdFx0XHRcdFx0ZW52LFxuXHRcdFx0XHRcdFx0XHRzaWduYXR1cmVWYWxpZGF0aW9uLFxuXHRcdFx0XHRcdFx0XHR1cmxcblx0XHRcdFx0XHRcdH0pKSxcblx0XHRcdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHRcdFx0XCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG5cdFx0XHRcdFx0XHRcdFtoZWFkZXJLZXlzLklubmdlc3RTeW5jS2luZF06IHN5bmNLaW5kLkluQmFuZFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHZlcnNpb246IHZvaWQgMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgeyBzdGF0dXMsIG1lc3NhZ2UsIG1vZGlmaWVkIH0gPSBhd2FpdCB0aGlzLnJlZ2lzdGVyKHRoaXMucmVxVXJsKHVybCksIGRlcGxveUlkLCBnZXRIZWFkZXJzKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzdGF0dXMsXG5cdFx0XHRcdFx0Ym9keTogc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRcdG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRtb2RpZmllZFxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHRcdFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuXHRcdFx0XHRcdFx0W2hlYWRlcktleXMuSW5uZ2VzdFN5bmNLaW5kXTogc3luY0tpbmQuT3V0T2ZCYW5kXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR2ZXJzaW9uOiB2b2lkIDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0YXR1czogNTAwLFxuXHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoe1xuXHRcdFx0XHRcdHR5cGU6IFwiaW50ZXJuYWxcIixcblx0XHRcdFx0XHQuLi5zZXJpYWxpemVFcnJvcihlcnIpXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0XHRcdHZlcnNpb246IHZvaWQgMFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXR1czogNDA1LFxuXHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRtZXNzYWdlOiBcIk5vIGFjdGlvbiBmb3VuZDsgcmVxdWVzdCB3YXMgbGlrZWx5IG5vdCBQT1NULCBQVVQsIG9yIEdFVFwiLFxuXHRcdFx0XHRtb2RlOiB0aGlzLl9tb2RlXG5cdFx0XHR9KSxcblx0XHRcdGhlYWRlcnM6IHt9LFxuXHRcdFx0dmVyc2lvbjogdm9pZCAwXG5cdFx0fTtcblx0fVxuXHRydW5TdGVwKHsgYWN0aW9ucywgZnVuY3Rpb25JZCwgc3RlcElkLCBkYXRhLCB0aW1lciwgcmVxQXJncywgaGVhZGVycywgZm4sIGZvcmNlRXhlY3V0aW9uIH0pIHtcblx0XHRpZiAoIWZuKSB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGZ1bmN0aW9uIHdpdGggSUQgXCIke2Z1bmN0aW9uSWR9XCJgKTtcblx0XHRjb25zdCBpbW1lZGlhdGVGbkRhdGEgPSBwYXJzZUZuRGF0YShkYXRhKTtcblx0XHRsZXQgeyB2ZXJzaW9uOiB2ZXJzaW9uJDEgfSA9IGltbWVkaWF0ZUZuRGF0YTtcblx0XHRpZiAodmVyc2lvbiQxID09PSBFeGVjdXRpb25WZXJzaW9uLlYxICYmIGZuLmZuW1wic2hvdWxkT3B0aW1pemVQYXJhbGxlbGlzbVwiXT8uKCkpIHZlcnNpb24kMSA9IEV4ZWN1dGlvblZlcnNpb24uVjI7XG5cdFx0Y29uc3QgcmVzdWx0ID0gcnVuQXNQcm9taXNlKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IGFueUZuRGF0YSA9IGF3YWl0IGZldGNoQWxsRm5EYXRhKHtcblx0XHRcdFx0ZGF0YTogaW1tZWRpYXRlRm5EYXRhLFxuXHRcdFx0XHRhcGk6IHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXSxcblx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHR9KTtcblx0XHRcdGlmICghYW55Rm5EYXRhLm9rKSB0aHJvdyBuZXcgRXJyb3IoYW55Rm5EYXRhLmVycm9yKTtcblx0XHRcdGNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gZm9yY2VFeGVjdXRpb24gJiYgYWN0aW9ucy5leHBlcmltZW50YWxUcmFuc2Zvcm1TeW5jUmVzcG9uc2UgPyAoZGF0YSQxKSA9PiBhY3Rpb25zLmV4cGVyaW1lbnRhbFRyYW5zZm9ybVN5bmNSZXNwb25zZShcImNyZWF0ZWQgc3luYy0+YXN5bmMgcmVzcG9uc2VcIiwgZGF0YSQxKS50aGVuKChyZXMpID0+ICh7XG5cdFx0XHRcdC4uLnJlcyxcblx0XHRcdFx0dmVyc2lvbjogdmVyc2lvbiQxXG5cdFx0XHR9KSkgOiB2b2lkIDA7XG5cdFx0XHRjb25zdCBleGVjdXRpb25PcHRpb25zID0gYXdhaXQgKChzKSA9PiBzKSh7XG5cdFx0XHRcdFtFeGVjdXRpb25WZXJzaW9uLlYwXTogKHsgZXZlbnQsIGV2ZW50cywgc3RlcHMsIGN0eCwgdmVyc2lvbjogdmVyc2lvbiQyIH0pID0+IHtcblx0XHRcdFx0XHRjb25zdCBzdGVwU3RhdGUgPSBPYmplY3QuZW50cmllcyhzdGVwcyA/PyB7fSkucmVkdWNlKChhY2MsIFtpZCwgZGF0YSQxXSkgPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0Li4uYWNjLFxuXHRcdFx0XHRcdFx0XHRbaWRdOiB7XG5cdFx0XHRcdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogZGF0YSQxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSwge30pO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiB2ZXJzaW9uJDIsXG5cdFx0XHRcdFx0XHRwYXJ0aWFsT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRjbGllbnQ6IHRoaXMuY2xpZW50LFxuXHRcdFx0XHRcdFx0XHRydW5JZDogY3R4Py5ydW5faWQgfHwgXCJcIixcblx0XHRcdFx0XHRcdFx0c3RlcE1vZGU6IFN0ZXBNb2RlLkFzeW5jLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQsXG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnRzLFxuXHRcdFx0XHRcdFx0XHRcdHJ1bklkOiBjdHg/LnJ1bl9pZCB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0XHRcdGF0dGVtcHQ6IGN0eD8uYXR0ZW1wdCA/PyAwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0ZXBTdGF0ZSxcblx0XHRcdFx0XHRcdFx0cmVxdWVzdGVkUnVuU3RlcDogc3RlcElkID09PSBcInN0ZXBcIiA/IHZvaWQgMCA6IHN0ZXBJZCB8fCB2b2lkIDAsXG5cdFx0XHRcdFx0XHRcdHRpbWVyLFxuXHRcdFx0XHRcdFx0XHRpc0ZhaWx1cmVIYW5kbGVyOiBmbi5vbkZhaWx1cmUsXG5cdFx0XHRcdFx0XHRcdHN0ZXBDb21wbGV0aW9uT3JkZXI6IGN0eD8uc3RhY2s/LnN0YWNrID8/IFtdLFxuXHRcdFx0XHRcdFx0XHRyZXFBcmdzLFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVSZXNwb25zZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFtFeGVjdXRpb25WZXJzaW9uLlYxXTogKHsgZXZlbnQsIGV2ZW50cywgc3RlcHMsIGN0eCwgdmVyc2lvbjogdmVyc2lvbiQyIH0pID0+IHtcblx0XHRcdFx0XHRjb25zdCBzdGVwU3RhdGUgPSBPYmplY3QuZW50cmllcyhzdGVwcyA/PyB7fSkucmVkdWNlKChhY2MsIFtpZCwgcmVzdWx0JDFdKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHQuLi5hY2MsXG5cdFx0XHRcdFx0XHRcdFtpZF06IHJlc3VsdCQxLnR5cGUgPT09IFwiZGF0YVwiID8ge1xuXHRcdFx0XHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGE6IHJlc3VsdCQxLmRhdGFcblx0XHRcdFx0XHRcdFx0fSA6IHJlc3VsdCQxLnR5cGUgPT09IFwiaW5wdXRcIiA/IHtcblx0XHRcdFx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRcdFx0XHRpbnB1dDogcmVzdWx0JDEuaW5wdXRcblx0XHRcdFx0XHRcdFx0fSA6IHtcblx0XHRcdFx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogcmVzdWx0JDEuZXJyb3Jcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9LCB7fSk7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHZlcnNpb246IHZlcnNpb24kMixcblx0XHRcdFx0XHRcdHBhcnRpYWxPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdGNsaWVudDogdGhpcy5jbGllbnQsXG5cdFx0XHRcdFx0XHRcdHJ1bklkOiBjdHg/LnJ1bl9pZCB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0XHRzdGVwTW9kZTogU3RlcE1vZGUuQXN5bmMsXG5cdFx0XHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRldmVudCxcblx0XHRcdFx0XHRcdFx0XHRldmVudHMsXG5cdFx0XHRcdFx0XHRcdFx0cnVuSWQ6IGN0eD8ucnVuX2lkIHx8IFwiXCIsXG5cdFx0XHRcdFx0XHRcdFx0YXR0ZW1wdDogY3R4Py5hdHRlbXB0ID8/IDAsXG5cdFx0XHRcdFx0XHRcdFx0bWF4QXR0ZW1wdHM6IGN0eD8ubWF4X2F0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0ZXBTdGF0ZSxcblx0XHRcdFx0XHRcdFx0cmVxdWVzdGVkUnVuU3RlcDogc3RlcElkID09PSBcInN0ZXBcIiA/IHZvaWQgMCA6IHN0ZXBJZCB8fCB2b2lkIDAsXG5cdFx0XHRcdFx0XHRcdHRpbWVyLFxuXHRcdFx0XHRcdFx0XHRpc0ZhaWx1cmVIYW5kbGVyOiBmbi5vbkZhaWx1cmUsXG5cdFx0XHRcdFx0XHRcdGRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb246IGN0eD8uZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uLFxuXHRcdFx0XHRcdFx0XHRzdGVwQ29tcGxldGlvbk9yZGVyOiBjdHg/LnN0YWNrPy5zdGFjayA/PyBbXSxcblx0XHRcdFx0XHRcdFx0cmVxQXJncyxcblx0XHRcdFx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0XHRcdFx0Y3JlYXRlUmVzcG9uc2Vcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRbRXhlY3V0aW9uVmVyc2lvbi5WMl06ICh7IGV2ZW50LCBldmVudHMsIHN0ZXBzLCBjdHgsIHZlcnNpb246IHZlcnNpb24kMiB9KSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RlcFN0YXRlID0gT2JqZWN0LmVudHJpZXMoc3RlcHMgPz8ge30pLnJlZHVjZSgoYWNjLCBbaWQsIHJlc3VsdCQxXSkgPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0Li4uYWNjLFxuXHRcdFx0XHRcdFx0XHRbaWRdOiByZXN1bHQkMS50eXBlID09PSBcImRhdGFcIiA/IHtcblx0XHRcdFx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhOiByZXN1bHQkMS5kYXRhXG5cdFx0XHRcdFx0XHRcdH0gOiByZXN1bHQkMS50eXBlID09PSBcImlucHV0XCIgPyB7XG5cdFx0XHRcdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0XHRcdFx0aW5wdXQ6IHJlc3VsdCQxLmlucHV0XG5cdFx0XHRcdFx0XHRcdH0gOiB7XG5cdFx0XHRcdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IHJlc3VsdCQxLmVycm9yXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSwge30pO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR2ZXJzaW9uOiB2ZXJzaW9uJDIsXG5cdFx0XHRcdFx0XHRwYXJ0aWFsT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRjbGllbnQ6IHRoaXMuY2xpZW50LFxuXHRcdFx0XHRcdFx0XHRydW5JZDogY3R4Py5ydW5faWQgfHwgXCJcIixcblx0XHRcdFx0XHRcdFx0c3RlcE1vZGU6IFN0ZXBNb2RlLkFzeW5jLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQsXG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnRzLFxuXHRcdFx0XHRcdFx0XHRcdHJ1bklkOiBjdHg/LnJ1bl9pZCB8fCBcIlwiLFxuXHRcdFx0XHRcdFx0XHRcdGF0dGVtcHQ6IGN0eD8uYXR0ZW1wdCA/PyAwLFxuXHRcdFx0XHRcdFx0XHRcdG1heEF0dGVtcHRzOiBjdHg/Lm1heF9hdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdGVwU3RhdGUsXG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RlZFJ1blN0ZXA6IHN0ZXBJZCA9PT0gXCJzdGVwXCIgPyB2b2lkIDAgOiBzdGVwSWQgfHwgdm9pZCAwLFxuXHRcdFx0XHRcdFx0XHR0aW1lcixcblx0XHRcdFx0XHRcdFx0aXNGYWlsdXJlSGFuZGxlcjogZm4ub25GYWlsdXJlLFxuXHRcdFx0XHRcdFx0XHRkaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uOiBjdHg/LmRpc2FibGVfaW1tZWRpYXRlX2V4ZWN1dGlvbixcblx0XHRcdFx0XHRcdFx0c3RlcENvbXBsZXRpb25PcmRlcjogY3R4Py5zdGFjaz8uc3RhY2sgPz8gW10sXG5cdFx0XHRcdFx0XHRcdHJlcUFyZ3MsXG5cdFx0XHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0XHRcdGNyZWF0ZVJlc3BvbnNlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSlbdmVyc2lvbiQxXShhbnlGbkRhdGEudmFsdWUpO1xuXHRcdFx0cmV0dXJuIGZuLmZuW1wiY3JlYXRlRXhlY3V0aW9uXCJdKGV4ZWN1dGlvbk9wdGlvbnMpLnN0YXJ0KCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnNpb246IHZlcnNpb24kMSxcblx0XHRcdHJlc3VsdFxuXHRcdH07XG5cdH1cblx0Y29uZmlncyh1cmwpIHtcblx0XHRjb25zdCBjb25maWdzID0gT2JqZWN0LnZhbHVlcyh0aGlzLnJhd0ZucykucmVkdWNlKChhY2MsIGZuKSA9PiBbLi4uYWNjLCAuLi5mbltcImdldENvbmZpZ1wiXSh7XG5cdFx0XHRiYXNlVXJsOiB1cmwsXG5cdFx0XHRhcHBQcmVmaXg6IHRoaXMuaWRcblx0XHR9KV0sIFtdKTtcblx0XHRmb3IgKGNvbnN0IGNvbmZpZyBvZiBjb25maWdzKSB7XG5cdFx0XHRjb25zdCBjaGVjayA9IGZ1bmN0aW9uQ29uZmlnU2NoZW1hLnNhZmVQYXJzZShjb25maWcpO1xuXHRcdFx0aWYgKCFjaGVjay5zdWNjZXNzKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9ycyA9IGNoZWNrLmVycm9yLmVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCI7IFwiKTtcblx0XHRcdFx0dGhpcy5sb2coXCJ3YXJuXCIsIGBDb25maWcgaW52YWxpZCBmb3IgZnVuY3Rpb24gXCIke2NvbmZpZy5pZH1cIiA6ICR7ZXJyb3JzfWApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29uZmlncztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYW4gSW5uZ2VzdCBzZXJ2ZSBlbmRwb2ludCBVUkwgZ2l2ZW4gYSBwb3RlbnRpYWwgYHBhdGhgIGFuZCBgaG9zdGAuXG5cdCpcblx0KiBXaWxsIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBgc2VydmVIb3N0YCBhbmQgYHNlcnZlUGF0aGAgaWYgdGhleSBoYXZlIGJlZW5cblx0KiBzZXQgd2hlbiByZWdpc3RlcmluZy5cblx0Ki9cblx0cmVxVXJsKHVybCkge1xuXHRcdGxldCByZXQgPSBuZXcgVVJMKHVybCk7XG5cdFx0Y29uc3Qgc2VydmVIb3N0ID0gdGhpcy5zZXJ2ZUhvc3QgfHwgdGhpcy5lbnZbZW52S2V5cy5Jbm5nZXN0U2VydmVIb3N0XTtcblx0XHRjb25zdCBzZXJ2ZVBhdGggPSB0aGlzLnNlcnZlUGF0aCB8fCB0aGlzLmVudltlbnZLZXlzLklubmdlc3RTZXJ2ZVBhdGhdO1xuXHRcdGlmIChzZXJ2ZVBhdGgpIHJldC5wYXRobmFtZSA9IHNlcnZlUGF0aDtcblx0XHRpZiAoc2VydmVIb3N0KSByZXQgPSBuZXcgVVJMKHJldC5wYXRobmFtZSArIHJldC5zZWFyY2gsIHNlcnZlSG9zdCk7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXHRyZWdpc3RlckJvZHkoeyB1cmwsIGRlcGxveUlkIH0pIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dXJsOiB1cmwuaHJlZixcblx0XHRcdGRlcGxveVR5cGU6IFwicGluZ1wiLFxuXHRcdFx0ZnJhbWV3b3JrOiB0aGlzLmZyYW1ld29ya05hbWUsXG5cdFx0XHRhcHBOYW1lOiB0aGlzLmlkLFxuXHRcdFx0ZnVuY3Rpb25zOiB0aGlzLmNvbmZpZ3ModXJsKSxcblx0XHRcdHNkazogYGpzOnYke3ZlcnNpb259YCxcblx0XHRcdHY6IFwiMC4xXCIsXG5cdFx0XHRkZXBsb3lJZDogZGVwbG95SWQgfHwgdm9pZCAwLFxuXHRcdFx0Y2FwYWJpbGl0aWVzOiB7XG5cdFx0XHRcdHRydXN0X3Byb2JlOiBcInYxXCIsXG5cdFx0XHRcdGNvbm5lY3Q6IFwidjFcIlxuXHRcdFx0fSxcblx0XHRcdGFwcFZlcnNpb246IHRoaXMuY2xpZW50LmFwcFZlcnNpb25cblx0XHR9O1xuXHR9XG5cdGFzeW5jIGluQmFuZFJlZ2lzdGVyQm9keSh7IGFjdGlvbnMsIGRlcGxveUlkLCBlbnYsIHNpZ25hdHVyZVZhbGlkYXRpb24sIHVybCB9KSB7XG5cdFx0Y29uc3QgcmVnaXN0ZXJCb2R5ID0gdGhpcy5yZWdpc3RlckJvZHkoe1xuXHRcdFx0ZGVwbG95SWQsXG5cdFx0XHR1cmxcblx0XHR9KTtcblx0XHRjb25zdCBpbnRyb3NwZWN0aW9uQm9keSA9IGF3YWl0IHRoaXMuaW50cm9zcGVjdGlvbkJvZHkoe1xuXHRcdFx0YWN0aW9ucyxcblx0XHRcdGVudixcblx0XHRcdHNpZ25hdHVyZVZhbGlkYXRpb24sXG5cdFx0XHR1cmxcblx0XHR9KTtcblx0XHRjb25zdCBib2R5ID0ge1xuXHRcdFx0YXBwX2lkOiB0aGlzLmlkLFxuXHRcdFx0YXBwVmVyc2lvbjogdGhpcy5jbGllbnQuYXBwVmVyc2lvbixcblx0XHRcdGNhcGFiaWxpdGllczogcmVnaXN0ZXJCb2R5LmNhcGFiaWxpdGllcyxcblx0XHRcdGVudixcblx0XHRcdGZyYW1ld29yazogcmVnaXN0ZXJCb2R5LmZyYW1ld29yayxcblx0XHRcdGZ1bmN0aW9uczogcmVnaXN0ZXJCb2R5LmZ1bmN0aW9ucyxcblx0XHRcdGluc3BlY3Rpb246IGludHJvc3BlY3Rpb25Cb2R5LFxuXHRcdFx0cGxhdGZvcm06IGdldFBsYXRmb3JtTmFtZSh7XG5cdFx0XHRcdC4uLmFsbFByb2Nlc3NFbnYoKSxcblx0XHRcdFx0Li4udGhpcy5lbnZcblx0XHRcdH0pLFxuXHRcdFx0c2RrX2F1dGhvcjogXCJpbm5nZXN0XCIsXG5cdFx0XHRzZGtfbGFuZ3VhZ2U6IFwiXCIsXG5cdFx0XHRzZGtfdmVyc2lvbjogXCJcIixcblx0XHRcdHNkazogcmVnaXN0ZXJCb2R5LnNkayxcblx0XHRcdHVybDogcmVnaXN0ZXJCb2R5LnVybFxuXHRcdH07XG5cdFx0aWYgKGludHJvc3BlY3Rpb25Cb2R5LmF1dGhlbnRpY2F0aW9uX3N1Y2NlZWRlZCkge1xuXHRcdFx0Ym9keS5zZGtfbGFuZ3VhZ2UgPSBpbnRyb3NwZWN0aW9uQm9keS5zZGtfbGFuZ3VhZ2U7XG5cdFx0XHRib2R5LnNka192ZXJzaW9uID0gaW50cm9zcGVjdGlvbkJvZHkuc2RrX3ZlcnNpb247XG5cdFx0fVxuXHRcdHJldHVybiBib2R5O1xuXHR9XG5cdGFzeW5jIGludHJvc3BlY3Rpb25Cb2R5KHsgYWN0aW9ucywgZW52LCBzaWduYXR1cmVWYWxpZGF0aW9uLCB1cmwgfSkge1xuXHRcdGNvbnN0IHJlZ2lzdGVyQm9keSA9IHRoaXMucmVnaXN0ZXJCb2R5KHtcblx0XHRcdHVybDogdGhpcy5yZXFVcmwodXJsKSxcblx0XHRcdGRlcGxveUlkOiBudWxsXG5cdFx0fSk7XG5cdFx0aWYgKCF0aGlzLl9tb2RlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2RlIHNldDsgY2Fubm90IGludHJvc3BlY3Qgd2l0aG91dCBtb2RlXCIpO1xuXHRcdGxldCBpbnRyb3NwZWN0aW9uID0ge1xuXHRcdFx0YXV0aGVudGljYXRpb25fc3VjY2VlZGVkOiBudWxsLFxuXHRcdFx0ZXh0cmE6IHsgaXNfbW9kZV9leHBsaWNpdDogdGhpcy5fbW9kZS5pc0V4cGxpY2l0IH0sXG5cdFx0XHRoYXNfZXZlbnRfa2V5OiB0aGlzLmNsaWVudFtcImV2ZW50S2V5U2V0XCJdKCksXG5cdFx0XHRoYXNfc2lnbmluZ19rZXk6IEJvb2xlYW4odGhpcy5zaWduaW5nS2V5KSxcblx0XHRcdGZ1bmN0aW9uX2NvdW50OiByZWdpc3RlckJvZHkuZnVuY3Rpb25zLmxlbmd0aCxcblx0XHRcdG1vZGU6IHRoaXMuX21vZGUudHlwZSxcblx0XHRcdHNjaGVtYV92ZXJzaW9uOiBcIjIwMjQtMDUtMjRcIlxuXHRcdH07XG5cdFx0aWYgKHRoaXMuX21vZGUudHlwZSA9PT0gXCJjbG91ZFwiKSB0cnkge1xuXHRcdFx0aWYgKCEoYXdhaXQgc2lnbmF0dXJlVmFsaWRhdGlvbikuc3VjY2VzcykgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIHZhbGlkYXRpb24gZmFpbGVkXCIpO1xuXHRcdFx0aW50cm9zcGVjdGlvbiA9IHtcblx0XHRcdFx0Li4uaW50cm9zcGVjdGlvbixcblx0XHRcdFx0YXV0aGVudGljYXRpb25fc3VjY2VlZGVkOiB0cnVlLFxuXHRcdFx0XHRhcGlfb3JpZ2luOiB0aGlzLmFwaUJhc2VVcmwsXG5cdFx0XHRcdGFwcF9pZDogdGhpcy5pZCxcblx0XHRcdFx0Y2FwYWJpbGl0aWVzOiB7XG5cdFx0XHRcdFx0dHJ1c3RfcHJvYmU6IFwidjFcIixcblx0XHRcdFx0XHRjb25uZWN0OiBcInYxXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0ZW52LFxuXHRcdFx0XHRldmVudF9hcGlfb3JpZ2luOiB0aGlzLmV2ZW50QXBpQmFzZVVybCxcblx0XHRcdFx0ZXZlbnRfa2V5X2hhc2g6IHRoaXMuaGFzaGVkRXZlbnRLZXkgPz8gbnVsbCxcblx0XHRcdFx0ZXh0cmE6IHtcblx0XHRcdFx0XHQuLi5pbnRyb3NwZWN0aW9uLmV4dHJhLFxuXHRcdFx0XHRcdGlzX3N0cmVhbWluZzogYXdhaXQgdGhpcy5zaG91bGRTdHJlYW0oYWN0aW9ucylcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnJhbWV3b3JrOiB0aGlzLmZyYW1ld29ya05hbWUsXG5cdFx0XHRcdHNka19sYW5ndWFnZTogXCJqc1wiLFxuXHRcdFx0XHRzZGtfdmVyc2lvbjogdmVyc2lvbixcblx0XHRcdFx0c2VydmVfb3JpZ2luOiB0aGlzLnNlcnZlSG9zdCA/PyBudWxsLFxuXHRcdFx0XHRzZXJ2ZV9wYXRoOiB0aGlzLnNlcnZlUGF0aCA/PyBudWxsLFxuXHRcdFx0XHRzaWduaW5nX2tleV9mYWxsYmFja19oYXNoOiB0aGlzLmhhc2hlZFNpZ25pbmdLZXlGYWxsYmFjayA/PyBudWxsLFxuXHRcdFx0XHRzaWduaW5nX2tleV9oYXNoOiB0aGlzLmhhc2hlZFNpZ25pbmdLZXkgPz8gbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIHtcblx0XHRcdGludHJvc3BlY3Rpb24gPSB7XG5cdFx0XHRcdC4uLmludHJvc3BlY3Rpb24sXG5cdFx0XHRcdGF1dGhlbnRpY2F0aW9uX3N1Y2NlZWRlZDogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBpbnRyb3NwZWN0aW9uO1xuXHR9XG5cdGFzeW5jIHJlZ2lzdGVyKHVybCwgZGVwbG95SWQsIGdldEhlYWRlcnMpIHtcblx0XHRjb25zdCBib2R5ID0gdGhpcy5yZWdpc3RlckJvZHkoe1xuXHRcdFx0dXJsLFxuXHRcdFx0ZGVwbG95SWRcblx0XHR9KTtcblx0XHRsZXQgcmVzO1xuXHRcdGxldCByZWdpc3RlclVSTCA9IG5ldyBVUkwodGhpcy5pbm5nZXN0UmVnaXN0ZXJVcmwuaHJlZik7XG5cdFx0aWYgKHRoaXMuX21vZGUgJiYgdGhpcy5fbW9kZS5pc0luZmVycmVkICYmIHRoaXMuX21vZGUuaXNEZXYpIHtcblx0XHRcdGNvbnN0IGhvc3QgPSBkZXZTZXJ2ZXJIb3N0KHRoaXMuZW52KTtcblx0XHRcdGlmIChhd2FpdCBkZXZTZXJ2ZXJBdmFpbGFibGUoaG9zdCwgdGhpcy5mZXRjaCkpIHJlZ2lzdGVyVVJMID0gZGV2U2VydmVyVXJsKGhvc3QsIFwiL2ZuL3JlZ2lzdGVyXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fbW9kZT8uZXhwbGljaXREZXZVcmwpIHJlZ2lzdGVyVVJMID0gZGV2U2VydmVyVXJsKHRoaXMuX21vZGUuZXhwbGljaXREZXZVcmwuaHJlZiwgXCIvZm4vcmVnaXN0ZXJcIik7XG5cdFx0aWYgKGRlcGxveUlkKSByZWdpc3RlclVSTC5zZWFyY2hQYXJhbXMuc2V0KHF1ZXJ5S2V5cy5EZXBsb3lJZCwgZGVwbG95SWQpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXMgPSBhd2FpdCBmZXRjaFdpdGhBdXRoRmFsbGJhY2soe1xuXHRcdFx0XHRhdXRoVG9rZW46IHRoaXMuaGFzaGVkU2lnbmluZ0tleSxcblx0XHRcdFx0YXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkU2lnbmluZ0tleUZhbGxiYWNrLFxuXHRcdFx0XHRmZXRjaDogdGhpcy5mZXRjaCxcblx0XHRcdFx0dXJsOiByZWdpc3RlclVSTC5ocmVmLFxuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0bWV0aG9kOiBcIlBPU1RcIixcblx0XHRcdFx0XHRib2R5OiBzdHJpbmdpZnkoYm9keSksXG5cdFx0XHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRcdFx0Li4uYXdhaXQgZ2V0SGVhZGVycygpLFxuXHRcdFx0XHRcdFx0W2hlYWRlcktleXMuSW5uZ2VzdFN5bmNLaW5kXTogc3luY0tpbmQuT3V0T2ZCYW5kXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRyZWRpcmVjdDogXCJmb2xsb3dcIlxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHRoaXMubG9nKFwiZXJyb3JcIiwgZXJyKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHN0YXR1czogNTAwLFxuXHRcdFx0XHRtZXNzYWdlOiBgRmFpbGVkIHRvIHJlZ2lzdGVyJHtlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGA7ICR7ZXJyLm1lc3NhZ2V9YCA6IFwiXCJ9YCxcblx0XHRcdFx0bW9kaWZpZWQ6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRjb25zdCByYXcgPSBhd2FpdCByZXMudGV4dCgpO1xuXHRcdGxldCBkYXRhID0ge307XG5cdFx0dHJ5IHtcblx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKHJhdyk7XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHR0aGlzLmxvZyhcIndhcm5cIiwgXCJDb3VsZG4ndCB1bnBhY2sgcmVnaXN0ZXIgcmVzcG9uc2U6XCIsIGVycik7XG5cdFx0XHRsZXQgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIHJlZ2lzdGVyXCI7XG5cdFx0XHRpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIG1lc3NhZ2UgKz0gYDsgJHtlcnIubWVzc2FnZX1gO1xuXHRcdFx0bWVzc2FnZSArPSBgOyBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzfWA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdGF0dXM6IDUwMCxcblx0XHRcdFx0bWVzc2FnZSxcblx0XHRcdFx0bW9kaWZpZWQ6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRsZXQgc3RhdHVzO1xuXHRcdGxldCBlcnJvcjtcblx0XHRsZXQgc2tpcHBlZDtcblx0XHRsZXQgbW9kaWZpZWQ7XG5cdFx0dHJ5IHtcblx0XHRcdCh7c3RhdHVzLCBlcnJvciwgc2tpcHBlZCwgbW9kaWZpZWR9ID0gcmVnaXN0ZXJSZXNTY2hlbWEucGFyc2UoZGF0YSkpO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0dGhpcy5sb2coXCJ3YXJuXCIsIFwiSW52YWxpZCByZWdpc3RlciByZXNwb25zZSBzY2hlbWE6XCIsIGVycik7XG5cdFx0XHRsZXQgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIHJlZ2lzdGVyXCI7XG5cdFx0XHRpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIG1lc3NhZ2UgKz0gYDsgJHtlcnIubWVzc2FnZX1gO1xuXHRcdFx0bWVzc2FnZSArPSBgOyBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzfWA7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdGF0dXM6IDUwMCxcblx0XHRcdFx0bWVzc2FnZSxcblx0XHRcdFx0bW9kaWZpZWQ6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAoIXNraXBwZWQpIHRoaXMubG9nKFwiZGVidWdcIiwgXCJyZWdpc3RlcmVkIGlubmdlc3QgZnVuY3Rpb25zOlwiLCByZXMuc3RhdHVzLCByZXMuc3RhdHVzVGV4dCwgZGF0YSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXR1cyxcblx0XHRcdG1lc3NhZ2U6IGVycm9yLFxuXHRcdFx0bW9kaWZpZWRcblx0XHR9O1xuXHR9XG5cdC8qKlxuXHQqIEdpdmVuIGFuIGVudmlyb25tZW50LCB1cHNlcnQgYW55IG1pc3Npbmcga2V5cy4gVGhpcyBpcyB1c2VmdWwgaW5cblx0KiBzaXR1YXRpb25zIHdoZXJlIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgcGFzc2VkIGRpcmVjdGx5IHRvIGhhbmRsZXJzIG9yXG5cdCogYXJlIG90aGVyd2lzZSBkaWZmaWN1bHQgdG8gYWNjZXNzIGR1cmluZyBpbml0aWFsaXphdGlvbi5cblx0Ki9cblx0dXBzZXJ0S2V5c0Zyb21FbnYoKSB7XG5cdFx0aWYgKHRoaXMuZW52W2VudktleXMuSW5uZ2VzdFNpZ25pbmdLZXldKSB7XG5cdFx0XHRpZiAoIXRoaXMuc2lnbmluZ0tleSkgdGhpcy5zaWduaW5nS2V5ID0gU3RyaW5nKHRoaXMuZW52W2VudktleXMuSW5uZ2VzdFNpZ25pbmdLZXldKTtcblx0XHRcdHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5zZXRTaWduaW5nS2V5KHRoaXMuc2lnbmluZ0tleSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmVudltlbnZLZXlzLklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2tdKSB7XG5cdFx0XHRpZiAoIXRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKSB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IFN0cmluZyh0aGlzLmVudltlbnZLZXlzLklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2tdKTtcblx0XHRcdHRoaXMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5zZXRTaWduaW5nS2V5RmFsbGJhY2sodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuY2xpZW50W1wiZXZlbnRLZXlTZXRcIl0oKSAmJiB0aGlzLmVudltlbnZLZXlzLklubmdlc3RFdmVudEtleV0pIHRoaXMuY2xpZW50LnNldEV2ZW50S2V5KFN0cmluZyh0aGlzLmVudltlbnZLZXlzLklubmdlc3RFdmVudEtleV0pKTtcblx0XHRpZiAodGhpcy5lbnZbZW52S2V5cy5Jbm5nZXN0RGV2U2VydmVyVXJsXSkgdGhpcy5sb2coXCJ3YXJuXCIsIGBVc2Ugb2YgJHtlbnZLZXlzLklubmdlc3REZXZTZXJ2ZXJVcmx9IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBsZWFzZSB1c2UgJHtlbnZLZXlzLklubmdlc3RCYXNlVXJsfSBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9zZGsvbWlncmF0aW9uYCk7XG5cdH1cblx0LyoqXG5cdCogVmFsaWRhdGUgdGhlIHNpZ25hdHVyZSBvZiBhIHJlcXVlc3QgYW5kIHJldHVybiB0aGUgc2lnbmluZyBrZXkgdXNlZCB0b1xuXHQqIHZhbGlkYXRlIGl0LlxuXHQqL1xuXHRhc3luYyB2YWxpZGF0ZVNpZ25hdHVyZShzaWcsIGJvZHkpIHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuc2tpcFNpZ25hdHVyZVZhbGlkYXRpb24pIHJldHVybiB7XG5cdFx0XHRcdHN1Y2Nlc3M6IHRydWUsXG5cdFx0XHRcdGtleVVzZWQ6IFwiXCJcblx0XHRcdH07XG5cdFx0XHRpZiAodGhpcy5fbW9kZSAmJiAhdGhpcy5fbW9kZS5pc0Nsb3VkKSByZXR1cm4ge1xuXHRcdFx0XHRzdWNjZXNzOiB0cnVlLFxuXHRcdFx0XHRrZXlVc2VkOiBcIlwiXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCF0aGlzLnNpZ25pbmdLZXkpIHRocm93IG5ldyBFcnJvcihgTm8gc2lnbmluZyBrZXkgZm91bmQgaW4gY2xpZW50IG9wdGlvbnMgb3IgJHtlbnZLZXlzLklubmdlc3RTaWduaW5nS2V5fSBlbnYgdmFyLiBGaW5kIHlvdXIga2V5cyBhdCBodHRwczovL2FwcC5pbm5nZXN0LmNvbS9zZWNyZXRzYCk7XG5cdFx0XHRpZiAoIXNpZykgdGhyb3cgbmV3IEVycm9yKGBObyAke2hlYWRlcktleXMuU2lnbmF0dXJlfSBwcm92aWRlZGApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3VjY2VzczogdHJ1ZSxcblx0XHRcdFx0a2V5VXNlZDogbmV3IFJlcXVlc3RTaWduYXR1cmUoc2lnKS52ZXJpZnlTaWduYXR1cmUoe1xuXHRcdFx0XHRcdGJvZHksXG5cdFx0XHRcdFx0YWxsb3dFeHBpcmVkU2lnbmF0dXJlczogdGhpcy5hbGxvd0V4cGlyZWRTaWduYXR1cmVzLFxuXHRcdFx0XHRcdHNpZ25pbmdLZXk6IHRoaXMuc2lnbmluZ0tleSxcblx0XHRcdFx0XHRzaWduaW5nS2V5RmFsbGJhY2s6IHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrXG5cdFx0XHRcdH0pXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c3VjY2VzczogZmFsc2UsXG5cdFx0XHRcdGVyclxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblx0Z2V0UmVzcG9uc2VTaWduYXR1cmUoa2V5LCBib2R5KSB7XG5cdFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblx0XHRyZXR1cm4gYHQ9JHtub3d9JnM9JHtzaWduRGF0YVdpdGhLZXkoYm9keSwga2V5LCBub3cudG9TdHJpbmcoKSl9YDtcblx0fVxuXHQvKipcblx0KiBMb2cgdG8gc3Rkb3V0L3N0ZGVyciBpZiB0aGUgbG9nIGxldmVsIGlzIHNldCB0byBpbmNsdWRlIHRoZSBnaXZlbiBsZXZlbC5cblx0KiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWwgaXMgYFwiaW5mb1wiYC5cblx0KlxuXHQqIFRoaXMgaXMgYW4gYWJzdHJhY3Rpb24gb3ZlciBgY29uc29sZS5sb2dgIGFuZCB3aWxsIHRyeSB0byB1c2UgdGhlIGNvcnJlY3Rcblx0KiBtZXRob2QgZm9yIHRoZSBnaXZlbiBsb2cgbGV2ZWwuICBGb3IgZXhhbXBsZSwgYGxvZyhcImVycm9yXCIsIFwiZm9vXCIpYCB3aWxsXG5cdCogY2FsbCBgY29uc29sZS5lcnJvcihcImZvb1wiKWAuXG5cdCovXG5cdGxvZyhsZXZlbCwgLi4uYXJncykge1xuXHRcdGNvbnN0IGxvZ0xldmVscyQxID0gW1xuXHRcdFx0XCJkZWJ1Z1wiLFxuXHRcdFx0XCJpbmZvXCIsXG5cdFx0XHRcIndhcm5cIixcblx0XHRcdFwiZXJyb3JcIixcblx0XHRcdFwiZmF0YWxcIixcblx0XHRcdFwic2lsZW50XCJcblx0XHRdO1xuXHRcdGNvbnN0IGxvZ0xldmVsU2V0dGluZyA9IGxvZ0xldmVscyQxLmluZGV4T2YodGhpcy5sb2dMZXZlbCk7XG5cdFx0aWYgKGxvZ0xldmVscyQxLmluZGV4T2YobGV2ZWwpID49IGxvZ0xldmVsU2V0dGluZykge1xuXHRcdFx0bGV0IGxvZ2dlciA9IGNvbnNvbGUubG9nO1xuXHRcdFx0aWYgKE9iamVjdC5oYXNPd24oY29uc29sZSwgbGV2ZWwpKSBsb2dnZXIgPSBjb25zb2xlW2xldmVsXTtcblx0XHRcdGxvZ2dlcihgJHtsb2dQcmVmaXh9ICR7bGV2ZWx9IC1gLCAuLi5hcmdzKTtcblx0XHR9XG5cdH1cbn07XG52YXIgUmVxdWVzdFNpZ25hdHVyZSA9IGNsYXNzIHtcblx0dGltZXN0YW1wO1xuXHRzaWduYXR1cmU7XG5cdGNvbnN0cnVjdG9yKHNpZykge1xuXHRcdGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2lnKTtcblx0XHR0aGlzLnRpbWVzdGFtcCA9IHBhcmFtcy5nZXQoXCJ0XCIpIHx8IFwiXCI7XG5cdFx0dGhpcy5zaWduYXR1cmUgPSBwYXJhbXMuZ2V0KFwic1wiKSB8fCBcIlwiO1xuXHRcdGlmICghdGhpcy50aW1lc3RhbXAgfHwgIXRoaXMuc2lnbmF0dXJlKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHtoZWFkZXJLZXlzLlNpZ25hdHVyZX0gcHJvdmlkZWRgKTtcblx0fVxuXHRoYXNFeHBpcmVkKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpIHtcblx0XHRpZiAoYWxsb3dFeHBpcmVkU2lnbmF0dXJlcykgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBEYXRlLm5vdygpIC0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGhpcy50aW1lc3RhbXApICogMWUzKSkudmFsdWVPZigpID4gMWUzICogNjAgKiA1O1xuXHR9XG5cdCN2ZXJpZnlTaWduYXR1cmUoeyBib2R5LCBzaWduaW5nS2V5LCBhbGxvd0V4cGlyZWRTaWduYXR1cmVzIH0pIHtcblx0XHRpZiAodGhpcy5oYXNFeHBpcmVkKGFsbG93RXhwaXJlZFNpZ25hdHVyZXMpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgaGFzIGV4cGlyZWRcIik7XG5cdFx0aWYgKHNpZ25EYXRhV2l0aEtleShib2R5LCBzaWduaW5nS2V5LCB0aGlzLnRpbWVzdGFtcCkgIT09IHRoaXMuc2lnbmF0dXJlKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hdHVyZVwiKTtcblx0fVxuXHR2ZXJpZnlTaWduYXR1cmUoeyBib2R5LCBzaWduaW5nS2V5LCBzaWduaW5nS2V5RmFsbGJhY2ssIGFsbG93RXhwaXJlZFNpZ25hdHVyZXMgfSkge1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLiN2ZXJpZnlTaWduYXR1cmUoe1xuXHRcdFx0XHRib2R5LFxuXHRcdFx0XHRzaWduaW5nS2V5LFxuXHRcdFx0XHRhbGxvd0V4cGlyZWRTaWduYXR1cmVzXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzaWduaW5nS2V5O1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0aWYgKCFzaWduaW5nS2V5RmFsbGJhY2spIHRocm93IGVycjtcblx0XHRcdHRoaXMuI3ZlcmlmeVNpZ25hdHVyZSh7XG5cdFx0XHRcdGJvZHksXG5cdFx0XHRcdHNpZ25pbmdLZXk6IHNpZ25pbmdLZXlGYWxsYmFjayxcblx0XHRcdFx0YWxsb3dFeHBpcmVkU2lnbmF0dXJlc1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2lnbmluZ0tleUZhbGxiYWNrO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBJbm5nZXN0Q29tbUhhbmRsZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RDb21tSGFuZGxlci5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QXN5bmNDdHgiLCJ2ZXJzaW9uIiwiRXhlY3V0aW9uVmVyc2lvbiIsImRlYnVnUHJlZml4IiwiZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsIiwiZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwiLCJkZWZhdWx0TWF4UmV0cmllcyIsImR1bW15RXZlbnRLZXkiLCJlbnZLZXlzIiwiZm9yd2FyZGVkSGVhZGVycyIsImhlYWRlcktleXMiLCJsb2dQcmVmaXgiLCJwcm9iZSIsInF1ZXJ5S2V5cyIsInN5bmNLaW5kIiwiQXN5bmNSZXNwb25zZVR5cGUiLCJTdGVwTW9kZSIsIlN0ZXBPcENvZGUiLCJmdW5jdGlvbkNvbmZpZ1NjaGVtYSIsImluQmFuZFN5bmNSZXF1ZXN0Qm9keVNjaGVtYSIsImxvZ0xldmVscyIsIlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTiIsInJldGhyb3dFcnJvciIsInNlcmlhbGl6ZUVycm9yIiwiZmV0Y2hBbGxGbkRhdGEiLCJwYXJzZUZuRGF0YSIsInVuZGVmaW5lZFRvTnVsbCIsImhhc2hFdmVudEtleSIsImhhc2hTaWduaW5nS2V5Iiwic3RyaW5naWZ5IiwiTW9kZSIsImFsbFByb2Nlc3NFbnYiLCJkZXZTZXJ2ZXJIb3N0IiwiZ2V0RmV0Y2giLCJnZXRNb2RlIiwiZ2V0UGxhdGZvcm1OYW1lIiwiaW5uZ2VzdEhlYWRlcnMiLCJwYXJzZUFzQm9vbGVhbiIsInBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmciLCJkZXZTZXJ2ZXJBdmFpbGFibGUiLCJkZXZTZXJ2ZXJVcmwiLCJlbnVtRnJvbVZhbHVlIiwiZmV0Y2hXaXRoQXV0aEZhbGxiYWNrIiwic2lnbkRhdGFXaXRoS2V5IiwicnVuQXNQcm9taXNlIiwiU2VydmVyVGltaW5nIiwiY3JlYXRlU3RyZWFtIiwiSW5uZ2VzdEZ1bmN0aW9uIiwiX2ludGVybmFscyIsImRlYnVnIiwidWxpZCIsInoiLCJyZWdpc3RlclJlc1NjaGVtYSIsIm9iamVjdCIsInN0YXR1cyIsIm51bWJlciIsImRlZmF1bHQiLCJza2lwcGVkIiwiYm9vbGVhbiIsIm9wdGlvbmFsIiwibW9kaWZpZWQiLCJlcnJvciIsInN0cmluZyIsIklubmdlc3RDb21tSGFuZGxlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImZucyIsImVudiIsIl9vcHRpb25zIiwiT2JqZWN0IiwiaGFzT3duIiwiRXJyb3IiLCJmcmFtZXdvcmtOYW1lIiwiY2xpZW50IiwiaWQiLCJjb25zb2xlIiwid2FybiIsImhhbmRsZXIiLCJhbGxvd0V4cGlyZWRTaWduYXR1cmVzIiwiQm9vbGVhbiIsImFyZ3VtZW50cyIsIl9fdGVzdGluZ0FsbG93RXhwaXJlZFNpZ25hdHVyZXMiLCJyYXdGbnMiLCJmdW5jdGlvbnMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJmbiIsImNvbmZpZ3MiLCJiYXNlVXJsIiwiVVJMIiwiYXBwUHJlZml4IiwiYWNjJDEiLCJpbmRleCIsIm9uRmFpbHVyZSIsImZvckVhY2giLCJpbm5nZXN0UmVnaXN0ZXJVcmwiLCJhcGlCYXNlVXJsIiwic2lnbmluZ0tleSIsInNpZ25pbmdLZXlGYWxsYmFjayIsIl9zZXJ2ZUhvc3QiLCJzZXJ2ZUhvc3QiLCJJbm5nZXN0U2VydmVIb3N0IiwiX3NlcnZlUGF0aCIsInNlcnZlUGF0aCIsIklubmdlc3RTZXJ2ZVBhdGgiLCJza2lwU2lnbmF0dXJlVmFsaWRhdGlvbiIsImRlZmF1bHRMb2dMZXZlbCIsImxvZ0xldmVsIiwiZW51bSIsImNhdGNoIiwiY3R4IiwibG9nIiwiU3RyaW5nIiwiaW5wdXQiLCJwYXJzZSIsIklubmdlc3RMb2dMZXZlbCIsImVuYWJsZSIsImRlZmF1bHRTdHJlYW1pbmdPcHRpb24iLCJzdHJlYW1pbmciLCJ1bmlvbiIsImxpdGVyYWwiLCJJbm5nZXN0U3RyZWFtaW5nIiwiZmV0Y2giLCJJbm5nZXN0QXBpQmFzZVVybCIsIklubmdlc3RCYXNlVXJsIiwiZXZlbnRBcGlCYXNlVXJsIiwiSW5uZ2VzdEV2ZW50QXBpQmFzZVVybCIsImV2ZW50QmFzZVVybCIsImhhc2hlZEV2ZW50S2V5IiwiaGFzaGVkU2lnbmluZ0tleSIsImhhc2hlZFNpZ25pbmdLZXlGYWxsYmFjayIsInNob3VsZFN0cmVhbSIsImFjdGlvbnMiLCJxdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyIsIlByb2JlIiwidHJhbnNmb3JtU3RyZWFtaW5nUmVzcG9uc2UiLCJpc0lubmdlc3RSZXEiLCJyZXFNZXNzYWdlIiwicnVuSWQiLCJzaWduYXR1cmUiLCJQcm9taXNlIiwiYWxsIiwiaGVhZGVycyIsIklubmdlc3RSdW5JZCIsIlNpZ25hdHVyZSIsImluaXRSZXF1ZXN0IiwiYXJncyIsInRpbWVyIiwiZ2V0QWN0aW9ucyIsImV4cGVjdGVkU2VydmVyS2luZCIsIklubmdlc3RTZXJ2ZXJLaW5kIiwiaGVhZGVyUHJvbWlzZXMiLCJtYXAiLCJoZWFkZXIiLCJ2YWx1ZSIsImhlYWRlcnNUb0ZvcndhcmRQIiwidGhlbiIsImZldGNoZWRIZWFkZXJzIiwiZ2V0SGVhZGVycyIsImZyYW1ld29yayIsImV4dHJhcyIsImdldEhlYWRlciIsImFzc3VtZWRNb2RlIiwiaXNFeHBsaWNpdCIsIl9tb2RlIiwic2VydmVJc1Byb2QiLCJpc1Byb2R1Y3Rpb24iLCJ0eXBlIiwidXBzZXJ0S2V5c0Zyb21FbnYiLCJjcmVhdGVTeW5jSGFuZGxlciIsIndyYXBIYW5kbGVyIiwicmVxSW5pdCIsInN5bmNPcHRpb25zIiwiZnVuY3Rpb25JZCIsInJldHJpZXMiLCJoYW5kbGVBc3luY1JlcXVlc3QiLCJmb3JjZUV4ZWN1dGlvbiIsImhhbmRsZVN5bmNSZXF1ZXN0IiwiYXN5bmNNb2RlIiwiYXN5bmNSZXNwb25zZSIsIlJlZGlyZWN0IiwiY3JlYXRlSGFuZGxlciIsImNyZWF0ZUh0dHBFdmVudCIsInJlYXNvbiIsImNvbnRlbnRUeXBlUHJvbWlzZSIsIkNvbnRlbnRUeXBlIiwidiIsImlwUHJvbWlzZSIsIkZvcndhcmRlZEZvciIsIlJlYWxJcCIsInYkMSIsIm1ldGhvZFByb21pc2UiLCJtZXRob2QiLCJ1cmxQcm9taXNlIiwidXJsIiwicmVxVXJsIiwiZG9tYWluUHJvbWlzZSIsInByb3RvY29sIiwiaG9zdCIsInBhdGhQcm9taXNlIiwicGF0aG5hbWUiLCJxdWVyeVBhcmFtc1Byb21pc2UiLCJzZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsImJvZHlQcm9taXNlIiwidGV4dEJvZHkiLCJib2R5JDEiLCJjb250ZW50VHlwZSIsImRvbWFpbiIsImlwIiwicGF0aCIsInF1ZXJ5UGFyYW1zIiwiYm9keSIsIm5hbWUiLCJkYXRhIiwiY29udGVudF90eXBlIiwicXVlcnlfcGFyYW1zIiwiZXhwZXJpbWVudGFsVHJhbnNmb3JtU3luY1Jlc3BvbnNlIiwiZXZlbnQiLCJleGVWZXJzaW9uIiwicmVzdWx0IiwicGFydGlhbE9wdGlvbnMiLCJhdHRlbXB0IiwiZXZlbnRzIiwibWF4QXR0ZW1wdHMiLCJvcHRzIiwicmVxQXJncyIsInN0ZXBDb21wbGV0aW9uT3JkZXIiLCJzdGVwU3RhdGUiLCJkaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uIiwiaXNGYWlsdXJlSGFuZGxlciIsImNyZWF0ZVJlc3BvbnNlIiwicmVzIiwic3RlcE1vZGUiLCJTeW5jIiwic3RhcnQiLCJyZXN1bHRIYW5kbGVyIiwidG9rZW4iLCJ0cmFuc2Zvcm1SZXNwb25zZSIsIkxvY2F0aW9uIiwiVG9rZW4iLCJydW5faWQiLCJtZXRob2RQIiwiY29udGVudExlbmd0aCIsIkNvbnRlbnRMZW5ndGgiLCJOdW1iZXIiLCJwYXJzZUludCIsImhlYWRlclNpZ25hdHVyZSIsIm1ldGhvZCQxIiwic2lnbmF0dXJlVmFsaWRhdGlvbiIsInZhbGlkYXRlU2lnbmF0dXJlIiwiYWN0aW9uUmVzIiwid3JhcCIsImhhbmRsZUFjdGlvbiIsInByZXBhcmVBY3Rpb25SZXMiLCJSZXF1ZXN0VmVyc2lvbiIsInNpZ25hdHVyZSQxIiwic3VjY2VzcyIsImtleVVzZWQiLCJnZXRSZXNwb25zZVNpZ25hdHVyZSIsImVyciIsInN0cmVhbSIsImZpbmFsaXplIiwiYWN0aW9uUmVzJDEiLCJsYXN0QXJnIiwiYWN0aW9uT3ZlcnJpZGVzIiwicmF3QWN0aW9ucyIsImVudHJpZXMiLCJrZXkiLCJhcmdzJDEiLCJlcnJNZXNzYWdlIiwiam9pbiIsInF1ZXJ5U3RyaW5nIiwiZ2V0IiwiZGVmaW5lUHJvcGVydGllcyIsIm1vZGUiLCJtIiwicmF3Qm9keSIsImlzTWlzc2luZ0JvZHkiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiZm5JZCIsInN0ZXBJZCIsInZhbHVlcyIsInN0ZXBzIiwiZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uIiwidXNlX2FwaSIsIm1heF9hdHRlbXB0cyIsInN0YWNrIiwiY3VycmVudCIsInJhd1Byb2JlIiwicHJvYmUkMSIsIlRydXN0IiwiRm5JZCIsIlN0ZXBJZCIsInZlcnNpb24kMSIsInJ1blN0ZXAiLCJzdGVwT3V0cHV0Iiwib3BEYXRhVW5kZWZpbmVkVG9OdWxsIiwib3AiLCJyZXN1bHQkMSIsInJldHJpYWJsZSIsIk5vUmV0cnkiLCJSZXRyeUFmdGVyIiwicnVuQ29tcGxldGVPcCIsImhhc2hJZCIsIlJ1bkNvbXBsZXRlIiwic3RlcCIsImRpc3BsYXlOYW1lIiwidG8iLCJFbnZpcm9ubWVudCIsImludHJvc3BlY3Rpb25Cb2R5IiwiZGVwbG95SWQiLCJpbkJhbmRTeW5jUmVxdWVzdGVkIiwiRGVwbG95SWQiLCJkZXBsb3lJZCQxIiwicmVzb2x2ZSIsIklubmdlc3RBbGxvd0luQmFuZFN5bmMiLCJhbGxvd0luQmFuZFN5bmMiLCJPdXRPZkJhbmQiLCJJbm5nZXN0U3luY0tpbmQiLCJraW5kIiwiSW5CYW5kIiwiY29kZSIsInNhZmVQYXJzZSIsIm1lc3NhZ2UiLCJpbkJhbmRSZWdpc3RlckJvZHkiLCJyZWdpc3RlciIsIkpTT04iLCJpbW1lZGlhdGVGbkRhdGEiLCJWMSIsIlYyIiwiYW55Rm5EYXRhIiwiYXBpIiwib2siLCJkYXRhJDEiLCJleGVjdXRpb25PcHRpb25zIiwicyIsIlYwIiwidmVyc2lvbiQyIiwiQXN5bmMiLCJyZXF1ZXN0ZWRSdW5TdGVwIiwiY29uZmlnIiwiY2hlY2siLCJlcnJvcnMiLCJyZXQiLCJzZWFyY2giLCJyZWdpc3RlckJvZHkiLCJocmVmIiwiZGVwbG95VHlwZSIsImFwcE5hbWUiLCJzZGsiLCJjYXBhYmlsaXRpZXMiLCJ0cnVzdF9wcm9iZSIsImNvbm5lY3QiLCJhcHBWZXJzaW9uIiwiYXBwX2lkIiwiaW5zcGVjdGlvbiIsInBsYXRmb3JtIiwic2RrX2F1dGhvciIsInNka19sYW5ndWFnZSIsInNka192ZXJzaW9uIiwiYXV0aGVudGljYXRpb25fc3VjY2VlZGVkIiwiaW50cm9zcGVjdGlvbiIsImV4dHJhIiwiaXNfbW9kZV9leHBsaWNpdCIsImhhc19ldmVudF9rZXkiLCJoYXNfc2lnbmluZ19rZXkiLCJmdW5jdGlvbl9jb3VudCIsInNjaGVtYV92ZXJzaW9uIiwiYXBpX29yaWdpbiIsImV2ZW50X2FwaV9vcmlnaW4iLCJldmVudF9rZXlfaGFzaCIsImlzX3N0cmVhbWluZyIsInNlcnZlX29yaWdpbiIsInNlcnZlX3BhdGgiLCJzaWduaW5nX2tleV9mYWxsYmFja19oYXNoIiwic2lnbmluZ19rZXlfaGFzaCIsInJlZ2lzdGVyVVJMIiwiaXNJbmZlcnJlZCIsImlzRGV2IiwiZXhwbGljaXREZXZVcmwiLCJzZXQiLCJhdXRoVG9rZW4iLCJhdXRoVG9rZW5GYWxsYmFjayIsInJlZGlyZWN0IiwicmF3IiwidGV4dCIsInN0YXR1c1RleHQiLCJJbm5nZXN0U2lnbmluZ0tleSIsInNldFNpZ25pbmdLZXkiLCJJbm5nZXN0U2lnbmluZ0tleUZhbGxiYWNrIiwic2V0U2lnbmluZ0tleUZhbGxiYWNrIiwiSW5uZ2VzdEV2ZW50S2V5Iiwic2V0RXZlbnRLZXkiLCJJbm5nZXN0RGV2U2VydmVyVXJsIiwic2lnIiwiaXNDbG91ZCIsIlJlcXVlc3RTaWduYXR1cmUiLCJ2ZXJpZnlTaWduYXR1cmUiLCJub3ciLCJEYXRlIiwibGV2ZWwiLCJsb2dMZXZlbHMkMSIsImxvZ0xldmVsU2V0dGluZyIsImluZGV4T2YiLCJsb2dnZXIiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0aW1lc3RhbXAiLCJoYXNFeHBpcmVkIiwidmFsdWVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestCommHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunction.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunction.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InngestFunction: () => (/* binding */ InngestFunction)\n/* harmony export */ });\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _helpers_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/* harmony import */ var _execution_v0_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./execution/v0.js */ \"(rsc)/./node_modules/inngest/components/execution/v0.js\");\n/* harmony import */ var _execution_v2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./execution/v2.js */ \"(rsc)/./node_modules/inngest/components/execution/v2.js\");\n/* harmony import */ var _execution_v1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./execution/v1.js */ \"(rsc)/./node_modules/inngest/components/execution/v1.js\");\n\n\n\n\n\n//#region src/components/InngestFunction.ts\n/**\n* A stateless Inngest function, wrapping up function configuration and any\n* in-memory steps to run when triggered.\n*\n* This function can be \"registered\" to create a handler that Inngest can\n* trigger remotely.\n*\n* @public\n*/ var InngestFunction = class InngestFunction {\n    static{\n        this.stepId = \"step\";\n    }\n    static{\n        this.failureSuffix = \"-failure\";\n    }\n    get [Symbol.toStringTag]() {\n        return InngestFunction.Tag;\n    }\n    /**\n\t* A stateless Inngest function, wrapping up function configuration and any\n\t* in-memory steps to run when triggered.\n\t*\n\t* This function can be \"registered\" to create a handler that Inngest can\n\t* trigger remotely.\n\t*/ constructor(client, opts, fn){\n        this.client = client;\n        this.opts = opts;\n        this.fn = fn;\n        this.onFailureFn = this.opts.onFailure;\n        this.middleware = this.client[\"initializeMiddleware\"](this.opts.middleware, {\n            registerInput: {\n                fn: this\n            },\n            prefixStack: this.client[\"middleware\"]\n        });\n    }\n    /**\n\t* The generated or given ID for this function.\n\t*/ id(prefix) {\n        return [\n            prefix,\n            this.opts.id\n        ].filter(Boolean).join(\"-\");\n    }\n    /**\n\t* The generated or given ID for this function, prefixed with the app ID. This\n\t* is used for routing invokes and identifying the function across apps.\n\t*/ get absoluteId() {\n        return this.id(this.client.id);\n    }\n    /**\n\t* The name of this function as it will appear in the Inngest Cloud UI.\n\t*/ get name() {\n        return this.opts.name || this.id();\n    }\n    /**\n\t* The description of this function.\n\t*/ get description() {\n        return this.opts.description;\n    }\n    /**\n\t* Retrieve the Inngest config for this function.\n\t*/ getConfig({ baseUrl, appPrefix, isConnect }) {\n        const fnId = this.id(appPrefix);\n        const stepUrl = new URL(baseUrl.href);\n        stepUrl.searchParams.set(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.queryKeys.FnId, fnId);\n        stepUrl.searchParams.set(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.queryKeys.StepId, InngestFunction.stepId);\n        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton } = this.opts;\n        /**\n\t\t* Convert retries into the format required when defining function\n\t\t* configuration.\n\t\t*/ const retries = typeof attempts === \"undefined\" ? void 0 : {\n            attempts\n        };\n        const fn = {\n            id: fnId,\n            name: this.name,\n            triggers: (this.opts.triggers ?? []).map((trigger)=>{\n                if (\"event\" in trigger) return {\n                    event: trigger.event,\n                    expression: trigger.if\n                };\n                return {\n                    cron: trigger.cron\n                };\n            }),\n            steps: {\n                [InngestFunction.stepId]: {\n                    id: InngestFunction.stepId,\n                    name: InngestFunction.stepId,\n                    runtime: {\n                        type: isConnect ? \"ws\" : \"http\",\n                        url: stepUrl.href\n                    },\n                    retries\n                }\n            },\n            idempotency,\n            batchEvents,\n            rateLimit,\n            throttle,\n            concurrency,\n            debounce,\n            priority,\n            timeouts,\n            singleton\n        };\n        if (cancelOn) fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match })=>{\n            const ret = {\n                event\n            };\n            if (timeout) ret.timeout = (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_1__.timeStr)(timeout);\n            if (match) ret.if = `event.${match} == async.${match}`;\n            else if (ifStr) ret.if = ifStr;\n            return ret;\n        }, []);\n        const config = [\n            fn\n        ];\n        if (this.onFailureFn) {\n            const id = `${fn.id}${InngestFunction.failureSuffix}`;\n            const name = `${fn.name ?? fn.id} (failure)`;\n            const failureStepUrl = new URL(stepUrl.href);\n            failureStepUrl.searchParams.set(_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.queryKeys.FnId, id);\n            config.push({\n                id,\n                name,\n                triggers: [\n                    {\n                        event: _helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.internalEvents.FunctionFailed,\n                        expression: `event.data.function_id == '${fnId}'`\n                    }\n                ],\n                steps: {\n                    [InngestFunction.stepId]: {\n                        id: InngestFunction.stepId,\n                        name: InngestFunction.stepId,\n                        runtime: {\n                            type: \"http\",\n                            url: failureStepUrl.href\n                        },\n                        retries: {\n                            attempts: 1\n                        }\n                    }\n                }\n            });\n        }\n        return config;\n    }\n    createExecution(opts) {\n        const options = {\n            fn: this,\n            ...opts.partialOptions\n        };\n        return ({\n            [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.ExecutionVersion.V2]: ()=>(0,_execution_v2_js__WEBPACK_IMPORTED_MODULE_2__.createV2InngestExecution)(options),\n            [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.ExecutionVersion.V1]: ()=>(0,_execution_v1_js__WEBPACK_IMPORTED_MODULE_3__.createV1InngestExecution)(options),\n            [_helpers_consts_js__WEBPACK_IMPORTED_MODULE_0__.ExecutionVersion.V0]: ()=>(0,_execution_v0_js__WEBPACK_IMPORTED_MODULE_4__.createV0InngestExecution)(options)\n        })[opts.version]();\n    }\n    shouldOptimizeParallelism() {\n        return this.opts.optimizeParallelism ?? this.client[\"options\"].optimizeParallelism ?? false;\n    }\n};\n(function(_InngestFunction) {\n    _InngestFunction.Tag = \"Inngest.Function\";\n})(InngestFunction || (InngestFunction = {}));\n//#endregion\n //# sourceMappingURL=InngestFunction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUY7QUFDbkM7QUFDYTtBQUNBO0FBQ0E7QUFFN0QsMkNBQTJDO0FBQzNDOzs7Ozs7OztBQVFBLEdBQ0EsSUFBSU8sa0JBQWtCLE1BQU1BOzthQUNwQkMsU0FBUzs7O2FBQ1RDLGdCQUFnQjs7SUFDdkIsSUFBSSxDQUFDQyxPQUFPQyxXQUFXLENBQUMsR0FBRztRQUMxQixPQUFPSixnQkFBZ0JLLEdBQUc7SUFDM0I7SUFNQTs7Ozs7O0NBTUEsR0FDQUMsWUFBWUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsQ0FBRTtRQUM3QixJQUFJLENBQUNGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJLENBQUNGLElBQUksQ0FBQ0csU0FBUztRQUN0QyxJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJLENBQUNMLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQ0ksVUFBVSxFQUFFO1lBQzNFQyxlQUFlO2dCQUFFSixJQUFJLElBQUk7WUFBQztZQUMxQkssYUFBYSxJQUFJLENBQUNQLE1BQU0sQ0FBQyxhQUFhO1FBQ3ZDO0lBQ0Q7SUFDQTs7Q0FFQSxHQUNBUSxHQUFHQyxNQUFNLEVBQUU7UUFDVixPQUFPO1lBQUNBO1lBQVEsSUFBSSxDQUFDUixJQUFJLENBQUNPLEVBQUU7U0FBQyxDQUFDRSxNQUFNLENBQUNDLFNBQVNDLElBQUksQ0FBQztJQUNwRDtJQUNBOzs7Q0FHQSxHQUNBLElBQUlDLGFBQWE7UUFDaEIsT0FBTyxJQUFJLENBQUNMLEVBQUUsQ0FBQyxJQUFJLENBQUNSLE1BQU0sQ0FBQ1EsRUFBRTtJQUM5QjtJQUNBOztDQUVBLEdBQ0EsSUFBSU0sT0FBTztRQUNW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QUFvQkEsQ0FBQUEsa0JBQWtCLENBQUM7QUFFMUMsWUFBWTtBQUNlLENBQzNCLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvbi5qcz80ZmZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4ZWN1dGlvblZlcnNpb24sIGludGVybmFsRXZlbnRzLCBxdWVyeUtleXMgfSBmcm9tIFwiLi4vaGVscGVycy9jb25zdHMuanNcIjtcbmltcG9ydCB7IHRpbWVTdHIgfSBmcm9tIFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVWMElubmdlc3RFeGVjdXRpb24gfSBmcm9tIFwiLi9leGVjdXRpb24vdjAuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvbiB9IGZyb20gXCIuL2V4ZWN1dGlvbi92Mi5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uIH0gZnJvbSBcIi4vZXhlY3V0aW9uL3YxLmpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvY29tcG9uZW50cy9Jbm5nZXN0RnVuY3Rpb24udHNcbi8qKlxuKiBBIHN0YXRlbGVzcyBJbm5nZXN0IGZ1bmN0aW9uLCB3cmFwcGluZyB1cCBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGFuZCBhbnlcbiogaW4tbWVtb3J5IHN0ZXBzIHRvIHJ1biB3aGVuIHRyaWdnZXJlZC5cbipcbiogVGhpcyBmdW5jdGlvbiBjYW4gYmUgXCJyZWdpc3RlcmVkXCIgdG8gY3JlYXRlIGEgaGFuZGxlciB0aGF0IElubmdlc3QgY2FuXG4qIHRyaWdnZXIgcmVtb3RlbHkuXG4qXG4qIEBwdWJsaWNcbiovXG52YXIgSW5uZ2VzdEZ1bmN0aW9uID0gY2xhc3MgSW5uZ2VzdEZ1bmN0aW9uIHtcblx0c3RhdGljIHN0ZXBJZCA9IFwic3RlcFwiO1xuXHRzdGF0aWMgZmFpbHVyZVN1ZmZpeCA9IFwiLWZhaWx1cmVcIjtcblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiBJbm5nZXN0RnVuY3Rpb24uVGFnO1xuXHR9XG5cdG9wdHM7XG5cdGZuO1xuXHRvbkZhaWx1cmVGbjtcblx0Y2xpZW50O1xuXHRtaWRkbGV3YXJlO1xuXHQvKipcblx0KiBBIHN0YXRlbGVzcyBJbm5nZXN0IGZ1bmN0aW9uLCB3cmFwcGluZyB1cCBmdW5jdGlvbiBjb25maWd1cmF0aW9uIGFuZCBhbnlcblx0KiBpbi1tZW1vcnkgc3RlcHMgdG8gcnVuIHdoZW4gdHJpZ2dlcmVkLlxuXHQqXG5cdCogVGhpcyBmdW5jdGlvbiBjYW4gYmUgXCJyZWdpc3RlcmVkXCIgdG8gY3JlYXRlIGEgaGFuZGxlciB0aGF0IElubmdlc3QgY2FuXG5cdCogdHJpZ2dlciByZW1vdGVseS5cblx0Ki9cblx0Y29uc3RydWN0b3IoY2xpZW50LCBvcHRzLCBmbikge1xuXHRcdHRoaXMuY2xpZW50ID0gY2xpZW50O1xuXHRcdHRoaXMub3B0cyA9IG9wdHM7XG5cdFx0dGhpcy5mbiA9IGZuO1xuXHRcdHRoaXMub25GYWlsdXJlRm4gPSB0aGlzLm9wdHMub25GYWlsdXJlO1xuXHRcdHRoaXMubWlkZGxld2FyZSA9IHRoaXMuY2xpZW50W1wiaW5pdGlhbGl6ZU1pZGRsZXdhcmVcIl0odGhpcy5vcHRzLm1pZGRsZXdhcmUsIHtcblx0XHRcdHJlZ2lzdGVySW5wdXQ6IHsgZm46IHRoaXMgfSxcblx0XHRcdHByZWZpeFN0YWNrOiB0aGlzLmNsaWVudFtcIm1pZGRsZXdhcmVcIl1cblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBUaGUgZ2VuZXJhdGVkIG9yIGdpdmVuIElEIGZvciB0aGlzIGZ1bmN0aW9uLlxuXHQqL1xuXHRpZChwcmVmaXgpIHtcblx0XHRyZXR1cm4gW3ByZWZpeCwgdGhpcy5vcHRzLmlkXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIi1cIik7XG5cdH1cblx0LyoqXG5cdCogVGhlIGdlbmVyYXRlZCBvciBnaXZlbiBJRCBmb3IgdGhpcyBmdW5jdGlvbiwgcHJlZml4ZWQgd2l0aCB0aGUgYXBwIElELiBUaGlzXG5cdCogaXMgdXNlZCBmb3Igcm91dGluZyBpbnZva2VzIGFuZCBpZGVudGlmeWluZyB0aGUgZnVuY3Rpb24gYWNyb3NzIGFwcHMuXG5cdCovXG5cdGdldCBhYnNvbHV0ZUlkKCkge1xuXHRcdHJldHVybiB0aGlzLmlkKHRoaXMuY2xpZW50LmlkKTtcblx0fVxuXHQvKipcblx0KiBUaGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uIGFzIGl0IHdpbGwgYXBwZWFyIGluIHRoZSBJbm5nZXN0IENsb3VkIFVJLlxuXHQqL1xuXHRnZXQgbmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRzLm5hbWUgfHwgdGhpcy5pZCgpO1xuXHR9XG5cdC8qKlxuXHQqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLlxuXHQqL1xuXHRnZXQgZGVzY3JpcHRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0cy5kZXNjcmlwdGlvbjtcblx0fVxuXHQvKipcblx0KiBSZXRyaWV2ZSB0aGUgSW5uZ2VzdCBjb25maWcgZm9yIHRoaXMgZnVuY3Rpb24uXG5cdCovXG5cdGdldENvbmZpZyh7IGJhc2VVcmwsIGFwcFByZWZpeCwgaXNDb25uZWN0IH0pIHtcblx0XHRjb25zdCBmbklkID0gdGhpcy5pZChhcHBQcmVmaXgpO1xuXHRcdGNvbnN0IHN0ZXBVcmwgPSBuZXcgVVJMKGJhc2VVcmwuaHJlZik7XG5cdFx0c3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KHF1ZXJ5S2V5cy5GbklkLCBmbklkKTtcblx0XHRzdGVwVXJsLnNlYXJjaFBhcmFtcy5zZXQocXVlcnlLZXlzLlN0ZXBJZCwgSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZCk7XG5cdFx0Y29uc3QgeyByZXRyaWVzOiBhdHRlbXB0cywgY2FuY2VsT24sIGlkZW1wb3RlbmN5LCBiYXRjaEV2ZW50cywgcmF0ZUxpbWl0LCB0aHJvdHRsZSwgY29uY3VycmVuY3ksIGRlYm91bmNlLCB0aW1lb3V0cywgcHJpb3JpdHksIHNpbmdsZXRvbiB9ID0gdGhpcy5vcHRzO1xuXHRcdC8qKlxuXHRcdCogQ29udmVydCByZXRyaWVzIGludG8gdGhlIGZvcm1hdCByZXF1aXJlZCB3aGVuIGRlZmluaW5nIGZ1bmN0aW9uXG5cdFx0KiBjb25maWd1cmF0aW9uLlxuXHRcdCovXG5cdFx0Y29uc3QgcmV0cmllcyA9IHR5cGVvZiBhdHRlbXB0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHsgYXR0ZW1wdHMgfTtcblx0XHRjb25zdCBmbiA9IHtcblx0XHRcdGlkOiBmbklkLFxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0dHJpZ2dlcnM6ICh0aGlzLm9wdHMudHJpZ2dlcnMgPz8gW10pLm1hcCgodHJpZ2dlcikgPT4ge1xuXHRcdFx0XHRpZiAoXCJldmVudFwiIGluIHRyaWdnZXIpIHJldHVybiB7XG5cdFx0XHRcdFx0ZXZlbnQ6IHRyaWdnZXIuZXZlbnQsXG5cdFx0XHRcdFx0ZXhwcmVzc2lvbjogdHJpZ2dlci5pZlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4geyBjcm9uOiB0cmlnZ2VyLmNyb24gfTtcblx0XHRcdH0pLFxuXHRcdFx0c3RlcHM6IHsgW0lubmdlc3RGdW5jdGlvbi5zdGVwSWRdOiB7XG5cdFx0XHRcdGlkOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuXHRcdFx0XHRuYW1lOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuXHRcdFx0XHRydW50aW1lOiB7XG5cdFx0XHRcdFx0dHlwZTogaXNDb25uZWN0ID8gXCJ3c1wiIDogXCJodHRwXCIsXG5cdFx0XHRcdFx0dXJsOiBzdGVwVXJsLmhyZWZcblx0XHRcdFx0fSxcblx0XHRcdFx0cmV0cmllc1xuXHRcdFx0fSB9LFxuXHRcdFx0aWRlbXBvdGVuY3ksXG5cdFx0XHRiYXRjaEV2ZW50cyxcblx0XHRcdHJhdGVMaW1pdCxcblx0XHRcdHRocm90dGxlLFxuXHRcdFx0Y29uY3VycmVuY3ksXG5cdFx0XHRkZWJvdW5jZSxcblx0XHRcdHByaW9yaXR5LFxuXHRcdFx0dGltZW91dHMsXG5cdFx0XHRzaW5nbGV0b25cblx0XHR9O1xuXHRcdGlmIChjYW5jZWxPbikgZm4uY2FuY2VsID0gY2FuY2VsT24ubWFwKCh7IGV2ZW50LCB0aW1lb3V0LCBpZjogaWZTdHIsIG1hdGNoIH0pID0+IHtcblx0XHRcdGNvbnN0IHJldCA9IHsgZXZlbnQgfTtcblx0XHRcdGlmICh0aW1lb3V0KSByZXQudGltZW91dCA9IHRpbWVTdHIodGltZW91dCk7XG5cdFx0XHRpZiAobWF0Y2gpIHJldC5pZiA9IGBldmVudC4ke21hdGNofSA9PSBhc3luYy4ke21hdGNofWA7XG5cdFx0XHRlbHNlIGlmIChpZlN0cikgcmV0LmlmID0gaWZTdHI7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0sIFtdKTtcblx0XHRjb25zdCBjb25maWcgPSBbZm5dO1xuXHRcdGlmICh0aGlzLm9uRmFpbHVyZUZuKSB7XG5cdFx0XHRjb25zdCBpZCA9IGAke2ZuLmlkfSR7SW5uZ2VzdEZ1bmN0aW9uLmZhaWx1cmVTdWZmaXh9YDtcblx0XHRcdGNvbnN0IG5hbWUgPSBgJHtmbi5uYW1lID8/IGZuLmlkfSAoZmFpbHVyZSlgO1xuXHRcdFx0Y29uc3QgZmFpbHVyZVN0ZXBVcmwgPSBuZXcgVVJMKHN0ZXBVcmwuaHJlZik7XG5cdFx0XHRmYWlsdXJlU3RlcFVybC5zZWFyY2hQYXJhbXMuc2V0KHF1ZXJ5S2V5cy5GbklkLCBpZCk7XG5cdFx0XHRjb25maWcucHVzaCh7XG5cdFx0XHRcdGlkLFxuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHR0cmlnZ2VyczogW3tcblx0XHRcdFx0XHRldmVudDogaW50ZXJuYWxFdmVudHMuRnVuY3Rpb25GYWlsZWQsXG5cdFx0XHRcdFx0ZXhwcmVzc2lvbjogYGV2ZW50LmRhdGEuZnVuY3Rpb25faWQgPT0gJyR7Zm5JZH0nYFxuXHRcdFx0XHR9XSxcblx0XHRcdFx0c3RlcHM6IHsgW0lubmdlc3RGdW5jdGlvbi5zdGVwSWRdOiB7XG5cdFx0XHRcdFx0aWQ6IElubmdlc3RGdW5jdGlvbi5zdGVwSWQsXG5cdFx0XHRcdFx0bmFtZTogSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZCxcblx0XHRcdFx0XHRydW50aW1lOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcImh0dHBcIixcblx0XHRcdFx0XHRcdHVybDogZmFpbHVyZVN0ZXBVcmwuaHJlZlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmV0cmllczogeyBhdHRlbXB0czogMSB9XG5cdFx0XHRcdH0gfVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBjb25maWc7XG5cdH1cblx0Y3JlYXRlRXhlY3V0aW9uKG9wdHMpIHtcblx0XHRjb25zdCBvcHRpb25zID0ge1xuXHRcdFx0Zm46IHRoaXMsXG5cdFx0XHQuLi5vcHRzLnBhcnRpYWxPcHRpb25zXG5cdFx0fTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0W0V4ZWN1dGlvblZlcnNpb24uVjJdOiAoKSA9PiBjcmVhdGVWMklubmdlc3RFeGVjdXRpb24ob3B0aW9ucyksXG5cdFx0XHRbRXhlY3V0aW9uVmVyc2lvbi5WMV06ICgpID0+IGNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbihvcHRpb25zKSxcblx0XHRcdFtFeGVjdXRpb25WZXJzaW9uLlYwXTogKCkgPT4gY3JlYXRlVjBJbm5nZXN0RXhlY3V0aW9uKG9wdGlvbnMpXG5cdFx0fVtvcHRzLnZlcnNpb25dKCk7XG5cdH1cblx0c2hvdWxkT3B0aW1pemVQYXJhbGxlbGlzbSgpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRzLm9wdGltaXplUGFyYWxsZWxpc20gPz8gdGhpcy5jbGllbnRbXCJvcHRpb25zXCJdLm9wdGltaXplUGFyYWxsZWxpc20gPz8gZmFsc2U7XG5cdH1cbn07XG4oZnVuY3Rpb24oX0lubmdlc3RGdW5jdGlvbikge1xuXHRfSW5uZ2VzdEZ1bmN0aW9uLlRhZyA9IFwiSW5uZ2VzdC5GdW5jdGlvblwiO1xufSkoSW5uZ2VzdEZ1bmN0aW9uIHx8IChJbm5nZXN0RnVuY3Rpb24gPSB7fSkpO1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IElubmdlc3RGdW5jdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdEZ1bmN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJFeGVjdXRpb25WZXJzaW9uIiwiaW50ZXJuYWxFdmVudHMiLCJxdWVyeUtleXMiLCJ0aW1lU3RyIiwiY3JlYXRlVjBJbm5nZXN0RXhlY3V0aW9uIiwiY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uIiwiY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uIiwiSW5uZ2VzdEZ1bmN0aW9uIiwic3RlcElkIiwiZmFpbHVyZVN1ZmZpeCIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiVGFnIiwiY29uc3RydWN0b3IiLCJjbGllbnQiLCJvcHRzIiwiZm4iLCJvbkZhaWx1cmVGbiIsIm9uRmFpbHVyZSIsIm1pZGRsZXdhcmUiLCJyZWdpc3RlcklucHV0IiwicHJlZml4U3RhY2siLCJpZCIsInByZWZpeCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiYWJzb2x1dGVJZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImdldENvbmZpZyIsImJhc2VVcmwiLCJhcHBQcmVmaXgiLCJpc0Nvbm5lY3QiLCJmbklkIiwic3RlcFVybCIsIlVSTCIsImhyZWYiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJGbklkIiwiU3RlcElkIiwicmV0cmllcyIsImF0dGVtcHRzIiwiY2FuY2VsT24iLCJpZGVtcG90ZW5jeSIsImJhdGNoRXZlbnRzIiwicmF0ZUxpbWl0IiwidGhyb3R0bGUiLCJjb25jdXJyZW5jeSIsImRlYm91bmNlIiwidGltZW91dHMiLCJwcmlvcml0eSIsInNpbmdsZXRvbiIsInRyaWdnZXJzIiwibWFwIiwidHJpZ2dlciIsImV2ZW50IiwiZXhwcmVzc2lvbiIsImlmIiwiY3JvbiIsInN0ZXBzIiwicnVudGltZSIsInR5cGUiLCJ1cmwiLCJjYW5jZWwiLCJ0aW1lb3V0IiwiaWZTdHIiLCJtYXRjaCIsInJldCIsImNvbmZpZyIsImZhaWx1cmVTdGVwVXJsIiwicHVzaCIsIkZ1bmN0aW9uRmFpbGVkIiwiY3JlYXRlRXhlY3V0aW9uIiwib3B0aW9ucyIsInBhcnRpYWxPcHRpb25zIiwiVjIiLCJWMSIsIlYwIiwidmVyc2lvbiIsInNob3VsZE9wdGltaXplUGFyYWxsZWxpc20iLCJvcHRpbWl6ZVBhcmFsbGVsaXNtIiwiX0lubmdlc3RGdW5jdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunctionReference.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunctionReference.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InngestFunctionReference: () => (/* binding */ InngestFunctionReference),\n/* harmony export */   referenceFunction: () => (/* binding */ referenceFunction)\n/* harmony export */ });\n//#region src/components/InngestFunctionReference.ts\n/**\n* A reference to an `InngestFunction` that can be used to represent both local\n* and remote functions without pulling in the full function definition (i.e.\n* dependencies).\n*\n* These references can be invoked in the same manner as a regular\n* `InngestFunction`.\n*\n* To create a reference function, use the {@link referenceFunction} helper.\n*\n* @public\n*/ var InngestFunctionReference = class InngestFunctionReference {\n    get [Symbol.toStringTag]() {\n        return InngestFunctionReference.Tag;\n    }\n    constructor(opts){\n        this.opts = opts;\n    }\n};\n/**\n* Create a reference to an `InngestFunction` that can be used to represent both\n* local and remote functions without pulling in the full function definition\n* (i.e. dependencies).\n*\n* These references can be invoked in the same manner as a regular\n* `InngestFunction`.\n*\n* @public\n*/ const referenceFunction = ({ functionId, appId })=>{\n    return new InngestFunctionReference({\n        functionId,\n        appId\n    });\n};\n(function(_InngestFunctionReference) {\n    _InngestFunctionReference.Tag = \"Inngest.FunctionReference\";\n})(InngestFunctionReference || (InngestFunctionReference = {}));\n//#endregion\n //# sourceMappingURL=InngestFunctionReference.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9EQUFvRDtBQUNwRDs7Ozs7Ozs7Ozs7QUFXQSxHQUNBLElBQUlBLDJCQUEyQixNQUFNQTtJQUNwQyxJQUFJLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxHQUFHO1FBQzFCLE9BQU9GLHlCQUF5QkcsR0FBRztJQUNwQztJQUNBQyxZQUFZQyxJQUFJLENBQUU7UUFDakIsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2I7QUFDRDtBQUNBOzs7Ozs7Ozs7QUFTQSxHQUNBLE1BQU1DLG9CQUFvQixDQUFDLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFO0lBQy9DLE9BQU8sSUFBSVIseUJBQXlCO1FBQ25DTztRQUNBQztJQUNEO0FBQ0Q7QUFDQyxVQUFTQyx5QkFBeUI7SUFDbENBLDBCQUEwQk4sR0FBRyxHQUFHO0FBQ2pDLEdBQUdILDRCQUE2QkEsQ0FBQUEsMkJBQTJCLENBQUM7QUFFNUQsWUFBWTtBQUMyQyxDQUN2RCxvREFBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuanM/ZjdhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlLnRzXG4vKipcbiogQSByZWZlcmVuY2UgdG8gYW4gYElubmdlc3RGdW5jdGlvbmAgdGhhdCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYm90aCBsb2NhbFxuKiBhbmQgcmVtb3RlIGZ1bmN0aW9ucyB3aXRob3V0IHB1bGxpbmcgaW4gdGhlIGZ1bGwgZnVuY3Rpb24gZGVmaW5pdGlvbiAoaS5lLlxuKiBkZXBlbmRlbmNpZXMpLlxuKlxuKiBUaGVzZSByZWZlcmVuY2VzIGNhbiBiZSBpbnZva2VkIGluIHRoZSBzYW1lIG1hbm5lciBhcyBhIHJlZ3VsYXJcbiogYElubmdlc3RGdW5jdGlvbmAuXG4qXG4qIFRvIGNyZWF0ZSBhIHJlZmVyZW5jZSBmdW5jdGlvbiwgdXNlIHRoZSB7QGxpbmsgcmVmZXJlbmNlRnVuY3Rpb259IGhlbHBlci5cbipcbiogQHB1YmxpY1xuKi9cbnZhciBJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UgPSBjbGFzcyBJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2Uge1xuXHRnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG5cdFx0cmV0dXJuIElubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5UYWc7XG5cdH1cblx0Y29uc3RydWN0b3Iob3B0cykge1xuXHRcdHRoaXMub3B0cyA9IG9wdHM7XG5cdH1cbn07XG4vKipcbiogQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIGFuIGBJbm5nZXN0RnVuY3Rpb25gIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGJvdGhcbiogbG9jYWwgYW5kIHJlbW90ZSBmdW5jdGlvbnMgd2l0aG91dCBwdWxsaW5nIGluIHRoZSBmdWxsIGZ1bmN0aW9uIGRlZmluaXRpb25cbiogKGkuZS4gZGVwZW5kZW5jaWVzKS5cbipcbiogVGhlc2UgcmVmZXJlbmNlcyBjYW4gYmUgaW52b2tlZCBpbiB0aGUgc2FtZSBtYW5uZXIgYXMgYSByZWd1bGFyXG4qIGBJbm5nZXN0RnVuY3Rpb25gLlxuKlxuKiBAcHVibGljXG4qL1xuY29uc3QgcmVmZXJlbmNlRnVuY3Rpb24gPSAoeyBmdW5jdGlvbklkLCBhcHBJZCB9KSA9PiB7XG5cdHJldHVybiBuZXcgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlKHtcblx0XHRmdW5jdGlvbklkLFxuXHRcdGFwcElkXG5cdH0pO1xufTtcbihmdW5jdGlvbihfSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlKSB7XG5cdF9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuVGFnID0gXCJJbm5nZXN0LkZ1bmN0aW9uUmVmZXJlbmNlXCI7XG59KShJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UgfHwgKElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSA9IHt9KSk7XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlLCByZWZlcmVuY2VGdW5jdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIlRhZyIsImNvbnN0cnVjdG9yIiwib3B0cyIsInJlZmVyZW5jZUZ1bmN0aW9uIiwiZnVuY3Rpb25JZCIsImFwcElkIiwiX0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestMiddleware.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/InngestMiddleware.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InngestMiddleware: () => (/* binding */ InngestMiddleware),\n/* harmony export */   getHookStack: () => (/* binding */ getHookStack)\n/* harmony export */ });\n/* harmony import */ var _helpers_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n\n//#region src/components/InngestMiddleware.ts\n/**\n* A middleware that can be registered with Inngest to hook into various\n* lifecycles of the SDK and affect input and output of Inngest functionality.\n*\n* See {@link https://innge.st/middleware}\n*\n* @example\n*\n* ```ts\n* export const inngest = new Inngest({\n*   middleware: [\n*     new InngestMiddleware({\n*       name: \"My Middleware\",\n*       init: () => {\n*         // ...\n*       }\n*     })\n*   ]\n* });\n* ```\n*\n* @public\n*/ var InngestMiddleware = class InngestMiddleware {\n    get [Symbol.toStringTag]() {\n        return InngestMiddleware.Tag;\n    }\n    constructor({ name, init }){\n        this.name = name;\n        this.init = init;\n    }\n};\n(function(_InngestMiddleware) {\n    _InngestMiddleware.Tag = \"Inngest.Middleware\";\n})(InngestMiddleware || (InngestMiddleware = {}));\n/**\n* Given some middleware and an entrypoint, runs the initializer for the given\n* `key` and returns functions that will pass arguments through a stack of each\n* given hook in a middleware's lifecycle.\n*\n* Lets the middleware initialize before starting.\n*/ const getHookStack = async (middleware, key, arg, transforms)=>{\n    const hookDirs = hookDirections[key];\n    if (!hookDirs) throw new Error(`No hook directions found for key \"${String(key)}\". This is likely a bug in the Inngest SDK.`);\n    const hooksRegistered = await (await middleware).reduce((acc, mw)=>{\n        const fn = mw[key];\n        if (fn) return [\n            ...acc,\n            fn\n        ];\n        return acc;\n    }, []).reduce(async (acc, fn)=>{\n        return [\n            ...await acc,\n            await fn(arg)\n        ];\n    }, Promise.resolve([]));\n    const ret = {};\n    for (const hook of hooksRegistered){\n        const hookKeys = Object.keys(hook);\n        for (const key$1 of hookKeys){\n            let fns = [\n                hook[key$1]\n            ];\n            const existingWaterfall = ret[key$1];\n            if (existingWaterfall) if (hookDirs[key$1] === \"forward\") fns = [\n                existingWaterfall,\n                hook[key$1]\n            ];\n            else fns = [\n                hook[key$1],\n                existingWaterfall\n            ];\n            const transform = transforms[key$1];\n            ret[key$1] = (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_0__.waterfall)(fns, transform);\n        }\n    }\n    for (const k of Object.keys(ret)){\n        const key$1 = k;\n        ret[key$1] = (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_0__.cacheFn)(ret[key$1]);\n    }\n    return ret;\n};\n/**\n* The direction of each hook that exists in the middleware lifecycle.\n* This is used to determine whether hooks found in a stack run forwards or\n* backwards, creating onion-like behaviour.\n*/ const hookDirections = {\n    onFunctionRun: {\n        transformInput: \"forward\",\n        beforeMemoization: \"forward\",\n        afterMemoization: \"backward\",\n        beforeExecution: \"forward\",\n        afterExecution: \"backward\",\n        transformOutput: \"backward\",\n        beforeResponse: \"forward\",\n        finished: \"forward\"\n    },\n    onSendEvent: {\n        transformInput: \"forward\",\n        transformOutput: \"backward\"\n    }\n};\n//#endregion\n //# sourceMappingURL=InngestMiddleware.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RNaWRkbGV3YXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RDtBQUU3RCw2Q0FBNkM7QUFDN0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsR0FDQSxJQUFJRSxvQkFBb0IsTUFBTUE7SUFDN0IsSUFBSSxDQUFDQyxPQUFPQyxXQUFXLENBQUMsR0FBRztRQUMxQixPQUFPRixrQkFBa0JHLEdBQUc7SUFDN0I7SUFzQkFDLFlBQVksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUUsQ0FBRTtRQUMzQixJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDYjtBQUNEO0FBQ0MsVUFBU0Msa0JBQWtCO0lBQzNCQSxtQkFBbUJKLEdBQUcsR0FBRztBQUMxQixHQUFHSCxxQkFBc0JBLENBQUFBLG9CQUFvQixDQUFDO0FBQzlDOzs7Ozs7QUFNQSxHQUNBLE1BQU1RLGVBQWUsT0FBT0MsWUFBWUMsS0FBS0MsS0FBS0M7SUFDakQsTUFBTUMsV0FBV0MsY0FBYyxDQUFDSixJQUFJO0lBQ3BDLElBQUksQ0FBQ0csVUFBVSxNQUFNLElBQUlFLE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRUMsT0FBT04sS0FBSywyQ0FBMkMsQ0FBQztJQUM1SCxNQUFNTyxrQkFBa0IsTUFBTSxDQUFDLE1BQU1SLFVBQVMsRUFBR1MsTUFBTSxDQUFDLENBQUNDLEtBQUtDO1FBQzdELE1BQU1DLEtBQUtELEVBQUUsQ0FBQ1YsSUFBSTtRQUNsQixJQUFJVyxJQUFJLE9BQU87ZUFBSUY7WUFBS0U7U0FBRztRQUMzQixPQUFPRjtJQUNSLEdBQUcsRUFBRSxFQUFFRCxNQUFNLENBQUMsT0FBT0MsS0FBS0U7UUFDekIsT0FBTztlQUFJLE1BQU1GO1lBQUssTUFBTUUsR0FBR1Y7U0FBSztJQUNyQyxHQUFHVyxRQUFRQyxPQUFPLENBQUMsRUFBRTtJQUNyQixNQUFNQyxNQUFNLENBQUM7SUFDYixLQUFLLE1BQU1DLFFBQVFSLGdCQUFpQjtRQUNuQyxNQUFNUyxXQUFXQyxPQUFPQyxJQUFJLENBQUNIO1FBQzdCLEtBQUssTUFBTUksU0FBU0gsU0FBVTtZQUM3QixJQUFJSSxNQUFNO2dCQUFDTCxJQUFJLENBQUNJLE1BQU07YUFBQztZQUN2QixNQUFNRSxvQkFBb0JQLEdBQUcsQ0FBQ0ssTUFBTTtZQUNwQyxJQUFJRSxtQkFBbUIsSUFBSWxCLFFBQVEsQ0FBQ2dCLE1BQU0sS0FBSyxXQUFXQyxNQUFNO2dCQUFDQztnQkFBbUJOLElBQUksQ0FBQ0ksTUFBTTthQUFDO2lCQUMzRkMsTUFBTTtnQkFBQ0wsSUFBSSxDQUFDSSxNQUFNO2dCQUFFRTthQUFrQjtZQUMzQyxNQUFNQyxZQUFZcEIsVUFBVSxDQUFDaUIsTUFBTTtZQUNuQ0wsR0FBRyxDQUFDSyxNQUFNLEdBQUc5QixnRUFBU0EsQ0FBQytCLEtBQUtFO1FBQzdCO0lBQ0Q7SUFDQSxLQUFLLE1BQU1DLEtBQUtOLE9BQU9DLElBQUksQ0FBQ0osS0FBTTtRQUNqQyxNQUFNSyxRQUFRSTtRQUNkVCxHQUFHLENBQUNLLE1BQU0sR0FBRy9CLDhEQUFPQSxDQUFDMEIsR0FBRyxDQUFDSyxNQUFNO0lBQ2hDO0lBQ0EsT0FBT0w7QUFDUjtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNVixpQkFBaUI7SUFDdEJvQixlQUFlO1FBQ2RDLGdCQUFnQjtRQUNoQkMsbUJBQW1CO1FBQ25CQyxrQkFBa0I7UUFDbEJDLGlCQUFpQjtRQUNqQkMsZ0JBQWdCO1FBQ2hCQyxpQkFBaUI7UUFDakJDLGdCQUFnQjtRQUNoQkMsVUFBVTtJQUNYO0lBQ0FDLGFBQWE7UUFDWlIsZ0JBQWdCO1FBQ2hCSyxpQkFBaUI7SUFDbEI7QUFDRDtBQUVBLFlBQVk7QUFDK0IsQ0FDM0MsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdE1pZGRsZXdhcmUuanM/NzBkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWNoZUZuLCB3YXRlcmZhbGwgfSBmcm9tIFwiLi4vaGVscGVycy9mdW5jdGlvbnMuanNcIjtcblxuLy8jcmVnaW9uIHNyYy9jb21wb25lbnRzL0lubmdlc3RNaWRkbGV3YXJlLnRzXG4vKipcbiogQSBtaWRkbGV3YXJlIHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgd2l0aCBJbm5nZXN0IHRvIGhvb2sgaW50byB2YXJpb3VzXG4qIGxpZmVjeWNsZXMgb2YgdGhlIFNESyBhbmQgYWZmZWN0IGlucHV0IGFuZCBvdXRwdXQgb2YgSW5uZ2VzdCBmdW5jdGlvbmFsaXR5LlxuKlxuKiBTZWUge0BsaW5rIGh0dHBzOi8vaW5uZ2Uuc3QvbWlkZGxld2FyZX1cbipcbiogQGV4YW1wbGVcbipcbiogYGBgdHNcbiogZXhwb3J0IGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4qICAgbWlkZGxld2FyZTogW1xuKiAgICAgbmV3IElubmdlc3RNaWRkbGV3YXJlKHtcbiogICAgICAgbmFtZTogXCJNeSBNaWRkbGV3YXJlXCIsXG4qICAgICAgIGluaXQ6ICgpID0+IHtcbiogICAgICAgICAvLyAuLi5cbiogICAgICAgfVxuKiAgICAgfSlcbiogICBdXG4qIH0pO1xuKiBgYGBcbipcbiogQHB1YmxpY1xuKi9cbnZhciBJbm5nZXN0TWlkZGxld2FyZSA9IGNsYXNzIElubmdlc3RNaWRkbGV3YXJlIHtcblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiBJbm5nZXN0TWlkZGxld2FyZS5UYWc7XG5cdH1cblx0LyoqXG5cdCogVGhlIG5hbWUgb2YgdGhpcyBtaWRkbGV3YXJlLiBVc2VkIHByaW1hcmlseSBmb3IgZGVidWdnaW5nIGFuZCBsb2dnaW5nXG5cdCogcHVycG9zZXMuXG5cdCovXG5cdG5hbWU7XG5cdC8qKlxuXHQqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBpbml0aWFsaXplIHlvdXIgbWlkZGxld2FyZSBhbmQgcmVnaXN0ZXIgYW55IGhvb2tzXG5cdCogeW91IHdhbnQgdG8gdXNlLiBJdCB3aWxsIGJlIGNhbGxlZCBvbmNlIHdoZW4gdGhlIFNESyBpcyBpbml0aWFsaXplZCwgYW5kXG5cdCogc2hvdWxkIGJlIHVzZWQgdG8gc3RvcmUgYW55IHN0YXRlIHlvdSB3YW50IHRvIHVzZSBpbiBvdGhlciBwYXJ0cyBvZiB5b3VyXG5cdCogbWlkZGxld2FyZS5cblx0KlxuXHQqIEl0IGNhbiBiZSBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMsIGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCB3aWxsIHdhaXRcblx0KiBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZyB0byBpbml0aWFsaXplIHRoZSBuZXh0IG1pZGRsZXdhcmUuXG5cdCpcblx0KiBNdWx0aXBsZSBjbGllbnRzIGNvdWxkIGJlIHVzZWQgaW4gdGhlIHNhbWUgYXBwbGljYXRpb24gd2l0aCBkaWZmZXJpbmdcblx0KiBtaWRkbGV3YXJlLCBzbyBkbyBub3Qgc3RvcmUgc3RhdGUgaW4gZ2xvYmFsIHZhcmlhYmxlcyBvciBhc3N1bWUgdGhhdCB5b3VyXG5cdCogbWlkZGxld2FyZSB3aWxsIG9ubHkgYmUgdXNlZCBvbmNlLlxuXHQqXG5cdCogTXVzdCByZXR1cm4gYW4gb2JqZWN0IGRldGFpbGluZyB0aGUgaG9va3MgeW91IHdhbnQgdG8gcmVnaXN0ZXIuXG5cdCovXG5cdGluaXQ7XG5cdGNvbnN0cnVjdG9yKHsgbmFtZSwgaW5pdCB9KSB7XG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHR0aGlzLmluaXQgPSBpbml0O1xuXHR9XG59O1xuKGZ1bmN0aW9uKF9Jbm5nZXN0TWlkZGxld2FyZSkge1xuXHRfSW5uZ2VzdE1pZGRsZXdhcmUuVGFnID0gXCJJbm5nZXN0Lk1pZGRsZXdhcmVcIjtcbn0pKElubmdlc3RNaWRkbGV3YXJlIHx8IChJbm5nZXN0TWlkZGxld2FyZSA9IHt9KSk7XG4vKipcbiogR2l2ZW4gc29tZSBtaWRkbGV3YXJlIGFuZCBhbiBlbnRyeXBvaW50LCBydW5zIHRoZSBpbml0aWFsaXplciBmb3IgdGhlIGdpdmVuXG4qIGBrZXlgIGFuZCByZXR1cm5zIGZ1bmN0aW9ucyB0aGF0IHdpbGwgcGFzcyBhcmd1bWVudHMgdGhyb3VnaCBhIHN0YWNrIG9mIGVhY2hcbiogZ2l2ZW4gaG9vayBpbiBhIG1pZGRsZXdhcmUncyBsaWZlY3ljbGUuXG4qXG4qIExldHMgdGhlIG1pZGRsZXdhcmUgaW5pdGlhbGl6ZSBiZWZvcmUgc3RhcnRpbmcuXG4qL1xuY29uc3QgZ2V0SG9va1N0YWNrID0gYXN5bmMgKG1pZGRsZXdhcmUsIGtleSwgYXJnLCB0cmFuc2Zvcm1zKSA9PiB7XG5cdGNvbnN0IGhvb2tEaXJzID0gaG9va0RpcmVjdGlvbnNba2V5XTtcblx0aWYgKCFob29rRGlycykgdGhyb3cgbmV3IEVycm9yKGBObyBob29rIGRpcmVjdGlvbnMgZm91bmQgZm9yIGtleSBcIiR7U3RyaW5nKGtleSl9XCIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIHRoZSBJbm5nZXN0IFNESy5gKTtcblx0Y29uc3QgaG9va3NSZWdpc3RlcmVkID0gYXdhaXQgKGF3YWl0IG1pZGRsZXdhcmUpLnJlZHVjZSgoYWNjLCBtdykgPT4ge1xuXHRcdGNvbnN0IGZuID0gbXdba2V5XTtcblx0XHRpZiAoZm4pIHJldHVybiBbLi4uYWNjLCBmbl07XG5cdFx0cmV0dXJuIGFjYztcblx0fSwgW10pLnJlZHVjZShhc3luYyAoYWNjLCBmbikgPT4ge1xuXHRcdHJldHVybiBbLi4uYXdhaXQgYWNjLCBhd2FpdCBmbihhcmcpXTtcblx0fSwgUHJvbWlzZS5yZXNvbHZlKFtdKSk7XG5cdGNvbnN0IHJldCA9IHt9O1xuXHRmb3IgKGNvbnN0IGhvb2sgb2YgaG9va3NSZWdpc3RlcmVkKSB7XG5cdFx0Y29uc3QgaG9va0tleXMgPSBPYmplY3Qua2V5cyhob29rKTtcblx0XHRmb3IgKGNvbnN0IGtleSQxIG9mIGhvb2tLZXlzKSB7XG5cdFx0XHRsZXQgZm5zID0gW2hvb2tba2V5JDFdXTtcblx0XHRcdGNvbnN0IGV4aXN0aW5nV2F0ZXJmYWxsID0gcmV0W2tleSQxXTtcblx0XHRcdGlmIChleGlzdGluZ1dhdGVyZmFsbCkgaWYgKGhvb2tEaXJzW2tleSQxXSA9PT0gXCJmb3J3YXJkXCIpIGZucyA9IFtleGlzdGluZ1dhdGVyZmFsbCwgaG9va1trZXkkMV1dO1xuXHRcdFx0ZWxzZSBmbnMgPSBbaG9va1trZXkkMV0sIGV4aXN0aW5nV2F0ZXJmYWxsXTtcblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNba2V5JDFdO1xuXHRcdFx0cmV0W2tleSQxXSA9IHdhdGVyZmFsbChmbnMsIHRyYW5zZm9ybSk7XG5cdFx0fVxuXHR9XG5cdGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhyZXQpKSB7XG5cdFx0Y29uc3Qga2V5JDEgPSBrO1xuXHRcdHJldFtrZXkkMV0gPSBjYWNoZUZuKHJldFtrZXkkMV0pO1xuXHR9XG5cdHJldHVybiByZXQ7XG59O1xuLyoqXG4qIFRoZSBkaXJlY3Rpb24gb2YgZWFjaCBob29rIHRoYXQgZXhpc3RzIGluIHRoZSBtaWRkbGV3YXJlIGxpZmVjeWNsZS5cbiogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGhvb2tzIGZvdW5kIGluIGEgc3RhY2sgcnVuIGZvcndhcmRzIG9yXG4qIGJhY2t3YXJkcywgY3JlYXRpbmcgb25pb24tbGlrZSBiZWhhdmlvdXIuXG4qL1xuY29uc3QgaG9va0RpcmVjdGlvbnMgPSB7XG5cdG9uRnVuY3Rpb25SdW46IHtcblx0XHR0cmFuc2Zvcm1JbnB1dDogXCJmb3J3YXJkXCIsXG5cdFx0YmVmb3JlTWVtb2l6YXRpb246IFwiZm9yd2FyZFwiLFxuXHRcdGFmdGVyTWVtb2l6YXRpb246IFwiYmFja3dhcmRcIixcblx0XHRiZWZvcmVFeGVjdXRpb246IFwiZm9yd2FyZFwiLFxuXHRcdGFmdGVyRXhlY3V0aW9uOiBcImJhY2t3YXJkXCIsXG5cdFx0dHJhbnNmb3JtT3V0cHV0OiBcImJhY2t3YXJkXCIsXG5cdFx0YmVmb3JlUmVzcG9uc2U6IFwiZm9yd2FyZFwiLFxuXHRcdGZpbmlzaGVkOiBcImZvcndhcmRcIlxuXHR9LFxuXHRvblNlbmRFdmVudDoge1xuXHRcdHRyYW5zZm9ybUlucHV0OiBcImZvcndhcmRcIixcblx0XHR0cmFuc2Zvcm1PdXRwdXQ6IFwiYmFja3dhcmRcIlxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IElubmdlc3RNaWRkbGV3YXJlLCBnZXRIb29rU3RhY2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RNaWRkbGV3YXJlLmpzLm1hcCJdLCJuYW1lcyI6WyJjYWNoZUZuIiwid2F0ZXJmYWxsIiwiSW5uZ2VzdE1pZGRsZXdhcmUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIlRhZyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImluaXQiLCJfSW5uZ2VzdE1pZGRsZXdhcmUiLCJnZXRIb29rU3RhY2siLCJtaWRkbGV3YXJlIiwia2V5IiwiYXJnIiwidHJhbnNmb3JtcyIsImhvb2tEaXJzIiwiaG9va0RpcmVjdGlvbnMiLCJFcnJvciIsIlN0cmluZyIsImhvb2tzUmVnaXN0ZXJlZCIsInJlZHVjZSIsImFjYyIsIm13IiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJldCIsImhvb2siLCJob29rS2V5cyIsIk9iamVjdCIsImtleXMiLCJrZXkkMSIsImZucyIsImV4aXN0aW5nV2F0ZXJmYWxsIiwidHJhbnNmb3JtIiwiayIsIm9uRnVuY3Rpb25SdW4iLCJ0cmFuc2Zvcm1JbnB1dCIsImJlZm9yZU1lbW9pemF0aW9uIiwiYWZ0ZXJNZW1vaXphdGlvbiIsImJlZm9yZUV4ZWN1dGlvbiIsImFmdGVyRXhlY3V0aW9uIiwidHJhbnNmb3JtT3V0cHV0IiwiYmVmb3JlUmVzcG9uc2UiLCJmaW5pc2hlZCIsIm9uU2VuZEV2ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestMiddleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestStepTools.js":
/*!*************************************************************!*\
  !*** ./node_modules/inngest/components/InngestStepTools.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   STEP_INDEXING_SUFFIX: () => (/* binding */ STEP_INDEXING_SUFFIX),\n/* harmony export */   createStepTools: () => (/* binding */ createStepTools),\n/* harmony export */   gatewaySymbol: () => (/* binding */ gatewaySymbol),\n/* harmony export */   getStepOptions: () => (/* binding */ getStepOptions),\n/* harmony export */   invokePayloadSchema: () => (/* binding */ invokePayloadSchema),\n/* harmony export */   step: () => (/* binding */ step)\n/* harmony export */ });\n/* harmony import */ var _execution_als_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _helpers_strings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/* harmony import */ var _helpers_temporal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/temporal.js */ \"(rsc)/./node_modules/inngest/helpers/temporal.js\");\n/* harmony import */ var _Fetch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\n/* harmony import */ var _InngestFunction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\n/* harmony import */ var _InngestFunctionReference_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _inngest_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n//#region src/components/InngestStepTools.ts\nconst getStepOptions = (options)=>{\n    if (typeof options === \"string\") return {\n        id: options\n    };\n    return options;\n};\n/**\n* Suffix used to namespace steps that are automatically indexed.\n*/ const STEP_INDEXING_SUFFIX = \":\";\n/**\n* Create a new set of step function tools ready to be used in a step function.\n* This function should be run and a fresh set of tools provided every time a\n* function is run.\n*\n* An op stack (function state) is passed in as well as some mutable properties\n* that the tools can use to submit a new op.\n*/ const createStepTools = (client, execution, stepHandler)=>{\n    /**\n\t* A local helper used to create tools that can be used to submit an op.\n\t*\n\t* When using this function, a generic type should be provided which is the\n\t* function signature exposed to the user.\n\t*/ const createTool = (matchOp, opts)=>{\n        return async (...args)=>{\n            return stepHandler({\n                args,\n                matchOp,\n                opts\n            });\n        };\n    };\n    /**\n\t* Create a new step run tool that can be used to run a step function using\n\t* `step.run()` as a shim.\n\t*/ const createStepRun = (type)=>{\n        return createTool(({ id, name }, _fn, ...input)=>{\n            const opts = {\n                ...input.length ? {\n                    input\n                } : {},\n                ...type ? {\n                    type\n                } : {}\n            };\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Sync,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.StepPlanned,\n                name: id,\n                displayName: name ?? id,\n                ...Object.keys(opts).length ? {\n                    opts\n                } : {},\n                userland: {\n                    id\n                }\n            };\n        }, {\n            fn: (_, fn, ...input)=>fn(...input)\n        });\n    };\n    /**\n\t* Define the set of tools the user has access to for their step functions.\n\t*\n\t* Each key is the function name and is expected to run `createTool` and pass\n\t* a generic type for that function as it will appear in the user's code.\n\t*/ const tools = {\n        sendEvent: createTool(({ id, name })=>{\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Sync,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.StepPlanned,\n                name: \"sendEvent\",\n                displayName: name ?? id,\n                opts: {\n                    type: \"step.sendEvent\"\n                },\n                userland: {\n                    id\n                }\n            };\n        }, {\n            fn: (_idOrOptions, payload)=>{\n                return client[\"_send\"]({\n                    payload,\n                    headers: execution[\"options\"][\"headers\"]\n                });\n            }\n        }),\n        waitForSignal: createTool(({ id, name }, opts)=>{\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.WaitForSignal,\n                name: opts.signal,\n                displayName: name ?? id,\n                opts: {\n                    signal: opts.signal,\n                    timeout: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_2__.timeStr)(opts.timeout),\n                    conflict: opts.onConflict\n                },\n                userland: {\n                    id\n                }\n            };\n        }),\n        sendSignal: createTool(({ id, name }, opts)=>{\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Sync,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.StepPlanned,\n                name: \"sendSignal\",\n                displayName: name ?? id,\n                opts: {\n                    type: \"step.sendSignal\",\n                    signal: opts.signal\n                },\n                userland: {\n                    id\n                }\n            };\n        }, {\n            fn: (_idOrOptions, opts)=>{\n                return client[\"_sendSignal\"]({\n                    signal: opts.signal,\n                    data: opts.data,\n                    headers: execution[\"options\"][\"headers\"]\n                });\n            }\n        }),\n        waitForEvent: createTool(({ id, name }, opts)=>{\n            const matchOpts = {\n                timeout: (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_2__.timeStr)(typeof opts === \"string\" ? opts : opts.timeout)\n            };\n            if (typeof opts !== \"string\") {\n                if (opts?.match) matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n                else if (opts?.if) matchOpts.if = opts.if;\n            }\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.WaitForEvent,\n                name: opts.event,\n                opts: matchOpts,\n                displayName: name ?? id,\n                userland: {\n                    id\n                }\n            };\n        }),\n        run: createStepRun(),\n        ai: {\n            infer: createTool(({ id, name }, options)=>{\n                const { model, body, ...rest } = options;\n                const modelCopy = {\n                    ...model\n                };\n                options.model.onCall?.(modelCopy, options.body);\n                return {\n                    id,\n                    mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n                    op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.AiGateway,\n                    displayName: name ?? id,\n                    opts: {\n                        type: \"step.ai.infer\",\n                        url: modelCopy.url,\n                        headers: modelCopy.headers,\n                        auth_key: modelCopy.authKey,\n                        format: modelCopy.format,\n                        body,\n                        ...rest\n                    },\n                    userland: {\n                        id\n                    }\n                };\n            }),\n            wrap: createStepRun(\"step.ai.wrap\"),\n            models: {\n                ..._inngest_ai__WEBPACK_IMPORTED_MODULE_0__.models\n            }\n        },\n        sleep: createTool(({ id, name }, time)=>{\n            /**\n\t\t\t* The presence of this operation in the returned stack indicates that the\n\t\t\t* sleep is over and we should continue execution.\n\t\t\t*/ const msTimeStr = (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_2__.timeStr)((0,_helpers_temporal_js__WEBPACK_IMPORTED_MODULE_3__.isTemporalDuration)(time) ? time.total({\n                unit: \"milliseconds\"\n            }) : time);\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.Sleep,\n                name: msTimeStr,\n                displayName: name ?? id,\n                userland: {\n                    id\n                }\n            };\n        }),\n        sleepUntil: createTool(({ id, name }, time)=>{\n            try {\n                const iso = (0,_helpers_temporal_js__WEBPACK_IMPORTED_MODULE_3__.getISOString)(time);\n                /**\n\t\t\t\t* The presence of this operation in the returned stack indicates that the\n\t\t\t\t* sleep is over and we should continue execution.\n\t\t\t\t*/ return {\n                    id,\n                    mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n                    op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.Sleep,\n                    name: iso,\n                    displayName: name ?? id,\n                    userland: {\n                        id\n                    }\n                };\n            } catch (err) {\n                /**\n\t\t\t\t* If we're here, it's because the date is invalid. We'll throw a custom\n\t\t\t\t* error here to standardise this response.\n\t\t\t\t*/ console.warn(\"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\", err);\n                throw new Error(`Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${time}`);\n            }\n        }),\n        invoke: createTool(({ id, name }, invokeOpts)=>{\n            const optsSchema = invokePayloadSchema.extend({\n                timeout: zod_v3__WEBPACK_IMPORTED_MODULE_4__.union([\n                    zod_v3__WEBPACK_IMPORTED_MODULE_4__.number(),\n                    zod_v3__WEBPACK_IMPORTED_MODULE_4__.string(),\n                    zod_v3__WEBPACK_IMPORTED_MODULE_4__.date()\n                ]).optional()\n            });\n            const parsedFnOpts = optsSchema.extend({\n                _type: zod_v3__WEBPACK_IMPORTED_MODULE_4__.literal(\"fullId\").optional().default(\"fullId\"),\n                function: zod_v3__WEBPACK_IMPORTED_MODULE_4__.string().min(1)\n            }).or(optsSchema.extend({\n                _type: zod_v3__WEBPACK_IMPORTED_MODULE_4__.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n                function: zod_v3__WEBPACK_IMPORTED_MODULE_4__[\"instanceof\"](_InngestFunction_js__WEBPACK_IMPORTED_MODULE_5__.InngestFunction)\n            })).or(optsSchema.extend({\n                _type: zod_v3__WEBPACK_IMPORTED_MODULE_4__.literal(\"refInstance\").optional().default(\"refInstance\"),\n                function: zod_v3__WEBPACK_IMPORTED_MODULE_4__[\"instanceof\"](_InngestFunctionReference_js__WEBPACK_IMPORTED_MODULE_6__.InngestFunctionReference)\n            })).safeParse(invokeOpts);\n            if (!parsedFnOpts.success) throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);\n            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n            const opts = {\n                payload: {\n                    data,\n                    user,\n                    v\n                },\n                function_id: \"\",\n                timeout: typeof timeout === \"undefined\" ? void 0 : (0,_helpers_strings_js__WEBPACK_IMPORTED_MODULE_2__.timeStr)(timeout)\n            };\n            switch(_type){\n                case \"fnInstance\":\n                    opts.function_id = fn.id(fn[\"client\"].id);\n                    break;\n                case \"fullId\":\n                    console.warn(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_7__.logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`);\n                    opts.function_id = fn;\n                    break;\n                case \"refInstance\":\n                    opts.function_id = [\n                        fn.opts.appId || client.id,\n                        fn.opts.functionId\n                    ].filter(Boolean).join(\"-\");\n                    break;\n            }\n            return {\n                id,\n                mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.InvokeFunction,\n                displayName: name ?? id,\n                opts,\n                userland: {\n                    id\n                }\n            };\n        }),\n        fetch: _Fetch_js__WEBPACK_IMPORTED_MODULE_8__.fetch\n    };\n    tools[gatewaySymbol] = createTool(({ id, name }, input, init)=>{\n        const url = input instanceof Request ? input.url : input.toString();\n        const headers = {};\n        if (input instanceof Request) input.headers.forEach((value, key)=>{\n            headers[key] = value;\n        });\n        else if (init?.headers) new Headers(init.headers).forEach((value, key)=>{\n            headers[key] = value;\n        });\n        return {\n            id,\n            mode: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepMode.Async,\n            op: _types_js__WEBPACK_IMPORTED_MODULE_1__.StepOpCode.Gateway,\n            displayName: name ?? id,\n            opts: {\n                url,\n                method: init?.method ?? \"GET\",\n                headers,\n                body: init?.body\n            },\n            userland: {\n                id\n            }\n        };\n    });\n    return tools;\n};\nconst gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n/**\n* A generic set of step tools that can be used without typing information about\n* the client used to create them.\n*\n* These tools use AsyncLocalStorage to track the context in which they are\n* used, and will throw an error if used outside of an Inngest context.\n*\n* The intention of these high-level tools is to allow usage of Inngest step\n* tools within API endpoints, though they can still be used within regular\n* Inngest functions as well.\n*/ const step = {\n    fetch: null,\n    ai: {\n        infer: (...args)=>getDeferredStepTooling().then((tools)=>tools.ai.infer(...args)),\n        wrap: (...args)=>getDeferredStepTooling().then((tools)=>tools.ai.wrap(...args)),\n        models: {\n            ..._inngest_ai__WEBPACK_IMPORTED_MODULE_0__.models\n        }\n    },\n    invoke: (...args)=>getDeferredStepTooling().then((tools)=>tools.invoke(...args)),\n    run: (...args)=>getDeferredStepTooling().then((tools)=>tools.run(...args)),\n    sendEvent: (...args)=>getDeferredStepTooling().then((tools)=>tools.sendEvent(...args)),\n    sendSignal: (...args)=>getDeferredStepTooling().then((tools)=>tools.sendSignal(...args)),\n    sleep: (...args)=>getDeferredStepTooling().then((tools)=>tools.sleep(...args)),\n    sleepUntil: (...args)=>getDeferredStepTooling().then((tools)=>tools.sleepUntil(...args)),\n    waitForEvent: (...args)=>getDeferredStepTooling().then((tools)=>tools.waitForEvent(...args)),\n    waitForSignal: (...args)=>getDeferredStepTooling().then((tools)=>tools.waitForSignal(...args))\n};\n/**\n* An internal function used to retrieve or create step tooling for the current\n* execution context.\n*\n* Note that this requires an existing context to create the step tooling;\n* something must declare the Inngest execution context before this can be used.\n*/ const getDeferredStepTooling = async ()=>{\n    const ctx = await (0,_execution_als_js__WEBPACK_IMPORTED_MODULE_9__.getAsyncCtx)();\n    if (!ctx) throw new Error(\"`step` tools can only be used within Inngest function executions; no context was found\");\n    if (!ctx.app) throw new Error(\"`step` tools can only be used within Inngest function executions; no Inngest client was found in the execution context\");\n    if (!ctx.execution) throw new Error(\"`step` tools can only be used within Inngest function executions; no execution context was found\");\n    return ctx.execution.ctx.step;\n};\n/**\n* The event payload portion of the options for `step.invoke()`. This does not\n* include non-payload options like `timeout` or the function to invoke.\n*/ const invokePayloadSchema = zod_v3__WEBPACK_IMPORTED_MODULE_4__.object({\n    data: zod_v3__WEBPACK_IMPORTED_MODULE_4__.record(zod_v3__WEBPACK_IMPORTED_MODULE_4__.any()).optional(),\n    user: zod_v3__WEBPACK_IMPORTED_MODULE_4__.record(zod_v3__WEBPACK_IMPORTED_MODULE_4__.any()).optional(),\n    v: zod_v3__WEBPACK_IMPORTED_MODULE_4__.string().optional()\n});\n//#endregion\n //# sourceMappingURL=InngestStepTools.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RTdGVwVG9vbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNBO0FBQ0U7QUFDSDtBQUMwQjtBQUN2QztBQUNvQjtBQUNrQjtBQUM5QztBQUNVO0FBRXJDLDRDQUE0QztBQUM1QyxNQUFNWSxpQkFBaUIsQ0FBQ0M7SUFDdkIsSUFBSSxPQUFPQSxZQUFZLFVBQVUsT0FBTztRQUFFQyxJQUFJRDtJQUFRO0lBQ3RELE9BQU9BO0FBQ1I7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLHVCQUF1QjtBQUM3Qjs7Ozs7OztBQU9BLEdBQ0EsTUFBTUMsa0JBQWtCLENBQUNDLFFBQVFDLFdBQVdDO0lBQzNDOzs7OztDQUtBLEdBQ0EsTUFBTUMsYUFBYSxDQUFDQyxTQUFTQztRQUM1QixPQUFRLE9BQU8sR0FBR0M7WUFDakIsT0FBT0osWUFBWTtnQkFDbEJJO2dCQUNBRjtnQkFDQUM7WUFDRDtRQUNEO0lBQ0Q7SUFDQTs7O0NBR0EsR0FDQSxNQUFNRSxnQkFBZ0IsQ0FBQ0M7UUFDdEIsT0FBT0wsV0FBVyxDQUFDLEVBQUVOLEVBQUUsRUFBRVksSUFBSSxFQUFFLEVBQUVDLEtBQUssR0FBR0M7WUFDeEMsTUFBTU4sT0FBTztnQkFDWixHQUFHTSxNQUFNQyxNQUFNLEdBQUc7b0JBQUVEO2dCQUFNLElBQUksQ0FBQyxDQUFDO2dCQUNoQyxHQUFHSCxPQUFPO29CQUFFQTtnQkFBSyxJQUFJLENBQUMsQ0FBQztZQUN4QjtZQUNBLE9BQU87Z0JBQ05YO2dCQUNBZ0IsTUFBTTVCLCtDQUFRQSxDQUFDNkIsSUFBSTtnQkFDbkJDLElBQUk3QixpREFBVUEsQ0FBQzhCLFdBQVc7Z0JBQzFCUCxNQUFNWjtnQkFDTm9CLGFBQWFSLFFBQVFaO2dCQUNyQixHQUFHcUIsT0FBT0MsSUFBSSxDQUFDZCxNQUFNTyxNQUFNLEdBQUc7b0JBQUVQO2dCQUFLLElBQUksQ0FBQyxDQUFDO2dCQUMz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TTtJQUMxQixJQUFJLENBQUM2QyxJQUFJQyxHQUFHLEVBQUUsTUFBTSxJQUFJOUMsTUFBTTtJQUM5QixJQUFJLENBQUM2QyxJQUFJaEgsU0FBUyxFQUFFLE1BQU0sSUFBSW1FLE1BQU07SUFDcEMsT0FBTzZDLElBQUloSCxTQUFTLENBQUNnSCxHQUFHLENBQUNILElBQUk7QUFDOUI7QUFDQTs7O0FBR0EsR0FDQSxNQUFNdEMsc0JBQXNCL0UsMENBQVEsQ0FBQztJQUNwQzJDLE1BQU0zQywwQ0FBUSxDQUFDQSx1Q0FBSyxJQUFJcUYsUUFBUTtJQUNoQ1csTUFBTWhHLDBDQUFRLENBQUNBLHVDQUFLLElBQUlxRixRQUFRO0lBQ2hDWSxHQUFHakcsMENBQVEsR0FBR3FGLFFBQVE7QUFDdkI7QUFFQSxZQUFZO0FBQytGLENBQzNHLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RTdGVwVG9vbHMuanM/NTY2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRBc3luY0N0eCB9IGZyb20gXCIuL2V4ZWN1dGlvbi9hbHMuanNcIjtcbmltcG9ydCB7IGxvZ1ByZWZpeCB9IGZyb20gXCIuLi9oZWxwZXJzL2NvbnN0cy5qc1wiO1xuaW1wb3J0IHsgU3RlcE1vZGUsIFN0ZXBPcENvZGUgfSBmcm9tIFwiLi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IHRpbWVTdHIgfSBmcm9tIFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCI7XG5pbXBvcnQgeyBnZXRJU09TdHJpbmcsIGlzVGVtcG9yYWxEdXJhdGlvbiB9IGZyb20gXCIuLi9oZWxwZXJzL3RlbXBvcmFsLmpzXCI7XG5pbXBvcnQgeyBmZXRjaCB9IGZyb20gXCIuL0ZldGNoLmpzXCI7XG5pbXBvcnQgeyBJbm5nZXN0RnVuY3Rpb24gfSBmcm9tIFwiLi9Jbm5nZXN0RnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSB9IGZyb20gXCIuL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qc1wiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjNcIjtcbmltcG9ydCB7IG1vZGVscyB9IGZyb20gXCJAaW5uZ2VzdC9haVwiO1xuXG4vLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvSW5uZ2VzdFN0ZXBUb29scy50c1xuY29uc3QgZ2V0U3RlcE9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHJldHVybiB7IGlkOiBvcHRpb25zIH07XG5cdHJldHVybiBvcHRpb25zO1xufTtcbi8qKlxuKiBTdWZmaXggdXNlZCB0byBuYW1lc3BhY2Ugc3RlcHMgdGhhdCBhcmUgYXV0b21hdGljYWxseSBpbmRleGVkLlxuKi9cbmNvbnN0IFNURVBfSU5ERVhJTkdfU1VGRklYID0gXCI6XCI7XG4vKipcbiogQ3JlYXRlIGEgbmV3IHNldCBvZiBzdGVwIGZ1bmN0aW9uIHRvb2xzIHJlYWR5IHRvIGJlIHVzZWQgaW4gYSBzdGVwIGZ1bmN0aW9uLlxuKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBydW4gYW5kIGEgZnJlc2ggc2V0IG9mIHRvb2xzIHByb3ZpZGVkIGV2ZXJ5IHRpbWUgYVxuKiBmdW5jdGlvbiBpcyBydW4uXG4qXG4qIEFuIG9wIHN0YWNrIChmdW5jdGlvbiBzdGF0ZSkgaXMgcGFzc2VkIGluIGFzIHdlbGwgYXMgc29tZSBtdXRhYmxlIHByb3BlcnRpZXNcbiogdGhhdCB0aGUgdG9vbHMgY2FuIHVzZSB0byBzdWJtaXQgYSBuZXcgb3AuXG4qL1xuY29uc3QgY3JlYXRlU3RlcFRvb2xzID0gKGNsaWVudCwgZXhlY3V0aW9uLCBzdGVwSGFuZGxlcikgPT4ge1xuXHQvKipcblx0KiBBIGxvY2FsIGhlbHBlciB1c2VkIHRvIGNyZWF0ZSB0b29scyB0aGF0IGNhbiBiZSB1c2VkIHRvIHN1Ym1pdCBhbiBvcC5cblx0KlxuXHQqIFdoZW4gdXNpbmcgdGhpcyBmdW5jdGlvbiwgYSBnZW5lcmljIHR5cGUgc2hvdWxkIGJlIHByb3ZpZGVkIHdoaWNoIGlzIHRoZVxuXHQqIGZ1bmN0aW9uIHNpZ25hdHVyZSBleHBvc2VkIHRvIHRoZSB1c2VyLlxuXHQqL1xuXHRjb25zdCBjcmVhdGVUb29sID0gKG1hdGNoT3AsIG9wdHMpID0+IHtcblx0XHRyZXR1cm4gKGFzeW5jICguLi5hcmdzKSA9PiB7XG5cdFx0XHRyZXR1cm4gc3RlcEhhbmRsZXIoe1xuXHRcdFx0XHRhcmdzLFxuXHRcdFx0XHRtYXRjaE9wLFxuXHRcdFx0XHRvcHRzXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcblx0LyoqXG5cdCogQ3JlYXRlIGEgbmV3IHN0ZXAgcnVuIHRvb2wgdGhhdCBjYW4gYmUgdXNlZCB0byBydW4gYSBzdGVwIGZ1bmN0aW9uIHVzaW5nXG5cdCogYHN0ZXAucnVuKClgIGFzIGEgc2hpbS5cblx0Ki9cblx0Y29uc3QgY3JlYXRlU3RlcFJ1biA9ICh0eXBlKSA9PiB7XG5cdFx0cmV0dXJuIGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgX2ZuLCAuLi5pbnB1dCkgPT4ge1xuXHRcdFx0Y29uc3Qgb3B0cyA9IHtcblx0XHRcdFx0Li4uaW5wdXQubGVuZ3RoID8geyBpbnB1dCB9IDoge30sXG5cdFx0XHRcdC4uLnR5cGUgPyB7IHR5cGUgfSA6IHt9XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLlN5bmMsXG5cdFx0XHRcdG9wOiBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkLFxuXHRcdFx0XHRuYW1lOiBpZCxcblx0XHRcdFx0ZGlzcGxheU5hbWU6IG5hbWUgPz8gaWQsXG5cdFx0XHRcdC4uLk9iamVjdC5rZXlzKG9wdHMpLmxlbmd0aCA/IHsgb3B0cyB9IDoge30sXG5cdFx0XHRcdHVzZXJsYW5kOiB7IGlkIH1cblx0XHRcdH07XG5cdFx0fSwgeyBmbjogKF8sIGZuLCAuLi5pbnB1dCkgPT4gZm4oLi4uaW5wdXQpIH0pO1xuXHR9O1xuXHQvKipcblx0KiBEZWZpbmUgdGhlIHNldCBvZiB0b29scyB0aGUgdXNlciBoYXMgYWNjZXNzIHRvIGZvciB0aGVpciBzdGVwIGZ1bmN0aW9ucy5cblx0KlxuXHQqIEVhY2gga2V5IGlzIHRoZSBmdW5jdGlvbiBuYW1lIGFuZCBpcyBleHBlY3RlZCB0byBydW4gYGNyZWF0ZVRvb2xgIGFuZCBwYXNzXG5cdCogYSBnZW5lcmljIHR5cGUgZm9yIHRoYXQgZnVuY3Rpb24gYXMgaXQgd2lsbCBhcHBlYXIgaW4gdGhlIHVzZXIncyBjb2RlLlxuXHQqL1xuXHRjb25zdCB0b29scyA9IHtcblx0XHRzZW5kRXZlbnQ6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSkgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLlN5bmMsXG5cdFx0XHRcdG9wOiBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkLFxuXHRcdFx0XHRuYW1lOiBcInNlbmRFdmVudFwiLFxuXHRcdFx0XHRkaXNwbGF5TmFtZTogbmFtZSA/PyBpZCxcblx0XHRcdFx0b3B0czogeyB0eXBlOiBcInN0ZXAuc2VuZEV2ZW50XCIgfSxcblx0XHRcdFx0dXNlcmxhbmQ6IHsgaWQgfVxuXHRcdFx0fTtcblx0XHR9LCB7IGZuOiAoX2lkT3JPcHRpb25zLCBwYXlsb2FkKSA9PiB7XG5cdFx0XHRyZXR1cm4gY2xpZW50W1wiX3NlbmRcIl0oe1xuXHRcdFx0XHRwYXlsb2FkLFxuXHRcdFx0XHRoZWFkZXJzOiBleGVjdXRpb25bXCJvcHRpb25zXCJdW1wiaGVhZGVyc1wiXVxuXHRcdFx0fSk7XG5cdFx0fSB9KSxcblx0XHR3YWl0Rm9yU2lnbmFsOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIG9wdHMpID0+IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkLFxuXHRcdFx0XHRtb2RlOiBTdGVwTW9kZS5Bc3luYyxcblx0XHRcdFx0b3A6IFN0ZXBPcENvZGUuV2FpdEZvclNpZ25hbCxcblx0XHRcdFx0bmFtZTogb3B0cy5zaWduYWwsXG5cdFx0XHRcdGRpc3BsYXlOYW1lOiBuYW1lID8/IGlkLFxuXHRcdFx0XHRvcHRzOiB7XG5cdFx0XHRcdFx0c2lnbmFsOiBvcHRzLnNpZ25hbCxcblx0XHRcdFx0XHR0aW1lb3V0OiB0aW1lU3RyKG9wdHMudGltZW91dCksXG5cdFx0XHRcdFx0Y29uZmxpY3Q6IG9wdHMub25Db25mbGljdFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR1c2VybGFuZDogeyBpZCB9XG5cdFx0XHR9O1xuXHRcdH0pLFxuXHRcdHNlbmRTaWduYWw6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgb3B0cykgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLlN5bmMsXG5cdFx0XHRcdG9wOiBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkLFxuXHRcdFx0XHRuYW1lOiBcInNlbmRTaWduYWxcIixcblx0XHRcdFx0ZGlzcGxheU5hbWU6IG5hbWUgPz8gaWQsXG5cdFx0XHRcdG9wdHM6IHtcblx0XHRcdFx0XHR0eXBlOiBcInN0ZXAuc2VuZFNpZ25hbFwiLFxuXHRcdFx0XHRcdHNpZ25hbDogb3B0cy5zaWduYWxcblx0XHRcdFx0fSxcblx0XHRcdFx0dXNlcmxhbmQ6IHsgaWQgfVxuXHRcdFx0fTtcblx0XHR9LCB7IGZuOiAoX2lkT3JPcHRpb25zLCBvcHRzKSA9PiB7XG5cdFx0XHRyZXR1cm4gY2xpZW50W1wiX3NlbmRTaWduYWxcIl0oe1xuXHRcdFx0XHRzaWduYWw6IG9wdHMuc2lnbmFsLFxuXHRcdFx0XHRkYXRhOiBvcHRzLmRhdGEsXG5cdFx0XHRcdGhlYWRlcnM6IGV4ZWN1dGlvbltcIm9wdGlvbnNcIl1bXCJoZWFkZXJzXCJdXG5cdFx0XHR9KTtcblx0XHR9IH0pLFxuXHRcdHdhaXRGb3JFdmVudDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBvcHRzKSA9PiB7XG5cdFx0XHRjb25zdCBtYXRjaE9wdHMgPSB7IHRpbWVvdXQ6IHRpbWVTdHIodHlwZW9mIG9wdHMgPT09IFwic3RyaW5nXCIgPyBvcHRzIDogb3B0cy50aW1lb3V0KSB9O1xuXHRcdFx0aWYgKHR5cGVvZiBvcHRzICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmIChvcHRzPy5tYXRjaCkgbWF0Y2hPcHRzLmlmID0gYGV2ZW50LiR7b3B0cy5tYXRjaH0gPT0gYXN5bmMuJHtvcHRzLm1hdGNofWA7XG5cdFx0XHRcdGVsc2UgaWYgKG9wdHM/LmlmKSBtYXRjaE9wdHMuaWYgPSBvcHRzLmlmO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLkFzeW5jLFxuXHRcdFx0XHRvcDogU3RlcE9wQ29kZS5XYWl0Rm9yRXZlbnQsXG5cdFx0XHRcdG5hbWU6IG9wdHMuZXZlbnQsXG5cdFx0XHRcdG9wdHM6IG1hdGNoT3B0cyxcblx0XHRcdFx0ZGlzcGxheU5hbWU6IG5hbWUgPz8gaWQsXG5cdFx0XHRcdHVzZXJsYW5kOiB7IGlkIH1cblx0XHRcdH07XG5cdFx0fSksXG5cdFx0cnVuOiBjcmVhdGVTdGVwUnVuKCksXG5cdFx0YWk6IHtcblx0XHRcdGluZmVyOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIG9wdGlvbnMpID0+IHtcblx0XHRcdFx0Y29uc3QgeyBtb2RlbCwgYm9keSwuLi5yZXN0IH0gPSBvcHRpb25zO1xuXHRcdFx0XHRjb25zdCBtb2RlbENvcHkgPSB7IC4uLm1vZGVsIH07XG5cdFx0XHRcdG9wdGlvbnMubW9kZWwub25DYWxsPy4obW9kZWxDb3B5LCBvcHRpb25zLmJvZHkpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLkFzeW5jLFxuXHRcdFx0XHRcdG9wOiBTdGVwT3BDb2RlLkFpR2F0ZXdheSxcblx0XHRcdFx0XHRkaXNwbGF5TmFtZTogbmFtZSA/PyBpZCxcblx0XHRcdFx0XHRvcHRzOiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0ZXAuYWkuaW5mZXJcIixcblx0XHRcdFx0XHRcdHVybDogbW9kZWxDb3B5LnVybCxcblx0XHRcdFx0XHRcdGhlYWRlcnM6IG1vZGVsQ29weS5oZWFkZXJzLFxuXHRcdFx0XHRcdFx0YXV0aF9rZXk6IG1vZGVsQ29weS5hdXRoS2V5LFxuXHRcdFx0XHRcdFx0Zm9ybWF0OiBtb2RlbENvcHkuZm9ybWF0LFxuXHRcdFx0XHRcdFx0Ym9keSxcblx0XHRcdFx0XHRcdC4uLnJlc3Rcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHVzZXJsYW5kOiB7IGlkIH1cblx0XHRcdFx0fTtcblx0XHRcdH0pLFxuXHRcdFx0d3JhcDogY3JlYXRlU3RlcFJ1bihcInN0ZXAuYWkud3JhcFwiKSxcblx0XHRcdG1vZGVsczogeyAuLi5tb2RlbHMgfVxuXHRcdH0sXG5cdFx0c2xlZXA6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgdGltZSkgPT4ge1xuXHRcdFx0LyoqXG5cdFx0XHQqIFRoZSBwcmVzZW5jZSBvZiB0aGlzIG9wZXJhdGlvbiBpbiB0aGUgcmV0dXJuZWQgc3RhY2sgaW5kaWNhdGVzIHRoYXQgdGhlXG5cdFx0XHQqIHNsZWVwIGlzIG92ZXIgYW5kIHdlIHNob3VsZCBjb250aW51ZSBleGVjdXRpb24uXG5cdFx0XHQqL1xuXHRcdFx0Y29uc3QgbXNUaW1lU3RyID0gdGltZVN0cihpc1RlbXBvcmFsRHVyYXRpb24odGltZSkgPyB0aW1lLnRvdGFsKHsgdW5pdDogXCJtaWxsaXNlY29uZHNcIiB9KSA6IHRpbWUpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0aWQsXG5cdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLkFzeW5jLFxuXHRcdFx0XHRvcDogU3RlcE9wQ29kZS5TbGVlcCxcblx0XHRcdFx0bmFtZTogbXNUaW1lU3RyLFxuXHRcdFx0XHRkaXNwbGF5TmFtZTogbmFtZSA/PyBpZCxcblx0XHRcdFx0dXNlcmxhbmQ6IHsgaWQgfVxuXHRcdFx0fTtcblx0XHR9KSxcblx0XHRzbGVlcFVudGlsOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIHRpbWUpID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGlzbyA9IGdldElTT1N0cmluZyh0aW1lKTtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCogVGhlIHByZXNlbmNlIG9mIHRoaXMgb3BlcmF0aW9uIGluIHRoZSByZXR1cm5lZCBzdGFjayBpbmRpY2F0ZXMgdGhhdCB0aGVcblx0XHRcdFx0KiBzbGVlcCBpcyBvdmVyIGFuZCB3ZSBzaG91bGQgY29udGludWUgZXhlY3V0aW9uLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdG1vZGU6IFN0ZXBNb2RlLkFzeW5jLFxuXHRcdFx0XHRcdG9wOiBTdGVwT3BDb2RlLlNsZWVwLFxuXHRcdFx0XHRcdG5hbWU6IGlzbyxcblx0XHRcdFx0XHRkaXNwbGF5TmFtZTogbmFtZSA/PyBpZCxcblx0XHRcdFx0XHR1c2VybGFuZDogeyBpZCB9XG5cdFx0XHRcdH07XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCogSWYgd2UncmUgaGVyZSwgaXQncyBiZWNhdXNlIHRoZSBkYXRlIGlzIGludmFsaWQuIFdlJ2xsIHRocm93IGEgY3VzdG9tXG5cdFx0XHRcdCogZXJyb3IgaGVyZSB0byBzdGFuZGFyZGlzZSB0aGlzIHJlc3BvbnNlLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJJbnZhbGlkIGBEYXRlYCwgZGF0ZSBzdHJpbmcsIGBUZW1wb3JhbC5JbnN0YW50YCwgb3IgYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVgIHBhc3NlZCB0byBzbGVlcFVudGlsO1wiLCBlcnIpO1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXFxgRGF0ZVxcYCwgZGF0ZSBzdHJpbmcsIFxcYFRlbXBvcmFsLkluc3RhbnRcXGAsIG9yIFxcYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVcXGAgcGFzc2VkIHRvIHNsZWVwVW50aWw6ICR7dGltZX1gKTtcblx0XHRcdH1cblx0XHR9KSxcblx0XHRpbnZva2U6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgaW52b2tlT3B0cykgPT4ge1xuXHRcdFx0Y29uc3Qgb3B0c1NjaGVtYSA9IGludm9rZVBheWxvYWRTY2hlbWEuZXh0ZW5kKHsgdGltZW91dDogei51bmlvbihbXG5cdFx0XHRcdHoubnVtYmVyKCksXG5cdFx0XHRcdHouc3RyaW5nKCksXG5cdFx0XHRcdHouZGF0ZSgpXG5cdFx0XHRdKS5vcHRpb25hbCgpIH0pO1xuXHRcdFx0Y29uc3QgcGFyc2VkRm5PcHRzID0gb3B0c1NjaGVtYS5leHRlbmQoe1xuXHRcdFx0XHRfdHlwZTogei5saXRlcmFsKFwiZnVsbElkXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImZ1bGxJZFwiKSxcblx0XHRcdFx0ZnVuY3Rpb246IHouc3RyaW5nKCkubWluKDEpXG5cdFx0XHR9KS5vcihvcHRzU2NoZW1hLmV4dGVuZCh7XG5cdFx0XHRcdF90eXBlOiB6LmxpdGVyYWwoXCJmbkluc3RhbmNlXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcImZuSW5zdGFuY2VcIiksXG5cdFx0XHRcdGZ1bmN0aW9uOiB6Lmluc3RhbmNlb2YoSW5uZ2VzdEZ1bmN0aW9uKVxuXHRcdFx0fSkpLm9yKG9wdHNTY2hlbWEuZXh0ZW5kKHtcblx0XHRcdFx0X3R5cGU6IHoubGl0ZXJhbChcInJlZkluc3RhbmNlXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcInJlZkluc3RhbmNlXCIpLFxuXHRcdFx0XHRmdW5jdGlvbjogei5pbnN0YW5jZW9mKElubmdlc3RGdW5jdGlvblJlZmVyZW5jZSlcblx0XHRcdH0pKS5zYWZlUGFyc2UoaW52b2tlT3B0cyk7XG5cdFx0XHRpZiAoIXBhcnNlZEZuT3B0cy5zdWNjZXNzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW52b2NhdGlvbiBvcHRpb25zIHBhc3NlZCB0byBpbnZva2U7IG11c3QgaW5jbHVkZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBmdW5jdGlvbklkLmApO1xuXHRcdFx0Y29uc3QgeyBfdHlwZSwgZnVuY3Rpb246IGZuLCBkYXRhLCB1c2VyLCB2LCB0aW1lb3V0IH0gPSBwYXJzZWRGbk9wdHMuZGF0YTtcblx0XHRcdGNvbnN0IG9wdHMgPSB7XG5cdFx0XHRcdHBheWxvYWQ6IHtcblx0XHRcdFx0XHRkYXRhLFxuXHRcdFx0XHRcdHVzZXIsXG5cdFx0XHRcdFx0dlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbl9pZDogXCJcIixcblx0XHRcdFx0dGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiB0aW1lU3RyKHRpbWVvdXQpXG5cdFx0XHR9O1xuXHRcdFx0c3dpdGNoIChfdHlwZSkge1xuXHRcdFx0XHRjYXNlIFwiZm5JbnN0YW5jZVwiOlxuXHRcdFx0XHRcdG9wdHMuZnVuY3Rpb25faWQgPSBmbi5pZChmbltcImNsaWVudFwiXS5pZCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmdWxsSWRcIjpcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oYCR7bG9nUHJlZml4fSBJbnZva2luZyBmdW5jdGlvbiB3aXRoIFxcYGZ1bmN0aW9uOiBzdHJpbmdcXGAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY0LjAuMDsgdXNlIGFuIGltcG9ydGVkIGZ1bmN0aW9uIG9yIFxcYHJlZmVyZW5jZUZ1bmN0aW9uKClcXGAgaW5zdGVhZC4gU2VlIGh0dHBzOi8vaW5uZ2Uuc3QvdHMtcmVmZXJlbmNpbmctZnVuY3Rpb25zYCk7XG5cdFx0XHRcdFx0b3B0cy5mdW5jdGlvbl9pZCA9IGZuO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicmVmSW5zdGFuY2VcIjpcblx0XHRcdFx0XHRvcHRzLmZ1bmN0aW9uX2lkID0gW2ZuLm9wdHMuYXBwSWQgfHwgY2xpZW50LmlkLCBmbi5vcHRzLmZ1bmN0aW9uSWRdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkLFxuXHRcdFx0XHRtb2RlOiBTdGVwTW9kZS5Bc3luYyxcblx0XHRcdFx0b3A6IFN0ZXBPcENvZGUuSW52b2tlRnVuY3Rpb24sXG5cdFx0XHRcdGRpc3BsYXlOYW1lOiBuYW1lID8/IGlkLFxuXHRcdFx0XHRvcHRzLFxuXHRcdFx0XHR1c2VybGFuZDogeyBpZCB9XG5cdFx0XHR9O1xuXHRcdH0pLFxuXHRcdGZldGNoXG5cdH07XG5cdHRvb2xzW2dhdGV3YXlTeW1ib2xdID0gY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBpbnB1dCwgaW5pdCkgPT4ge1xuXHRcdGNvbnN0IHVybCA9IGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGlucHV0LnVybCA6IGlucHV0LnRvU3RyaW5nKCk7XG5cdFx0Y29uc3QgaGVhZGVycyA9IHt9O1xuXHRcdGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIGlucHV0LmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuXHRcdFx0aGVhZGVyc1trZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0ZWxzZSBpZiAoaW5pdD8uaGVhZGVycykgbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG5cdFx0XHRoZWFkZXJzW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aWQsXG5cdFx0XHRtb2RlOiBTdGVwTW9kZS5Bc3luYyxcblx0XHRcdG9wOiBTdGVwT3BDb2RlLkdhdGV3YXksXG5cdFx0XHRkaXNwbGF5TmFtZTogbmFtZSA/PyBpZCxcblx0XHRcdG9wdHM6IHtcblx0XHRcdFx0dXJsLFxuXHRcdFx0XHRtZXRob2Q6IGluaXQ/Lm1ldGhvZCA/PyBcIkdFVFwiLFxuXHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRib2R5OiBpbml0Py5ib2R5XG5cdFx0XHR9LFxuXHRcdFx0dXNlcmxhbmQ6IHsgaWQgfVxuXHRcdH07XG5cdH0pO1xuXHRyZXR1cm4gdG9vbHM7XG59O1xuY29uc3QgZ2F0ZXdheVN5bWJvbCA9IFN5bWJvbC5mb3IoXCJpbm5nZXN0LnN0ZXAuZ2F0ZXdheVwiKTtcbi8qKlxuKiBBIGdlbmVyaWMgc2V0IG9mIHN0ZXAgdG9vbHMgdGhhdCBjYW4gYmUgdXNlZCB3aXRob3V0IHR5cGluZyBpbmZvcm1hdGlvbiBhYm91dFxuKiB0aGUgY2xpZW50IHVzZWQgdG8gY3JlYXRlIHRoZW0uXG4qXG4qIFRoZXNlIHRvb2xzIHVzZSBBc3luY0xvY2FsU3RvcmFnZSB0byB0cmFjayB0aGUgY29udGV4dCBpbiB3aGljaCB0aGV5IGFyZVxuKiB1c2VkLCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB1c2VkIG91dHNpZGUgb2YgYW4gSW5uZ2VzdCBjb250ZXh0LlxuKlxuKiBUaGUgaW50ZW50aW9uIG9mIHRoZXNlIGhpZ2gtbGV2ZWwgdG9vbHMgaXMgdG8gYWxsb3cgdXNhZ2Ugb2YgSW5uZ2VzdCBzdGVwXG4qIHRvb2xzIHdpdGhpbiBBUEkgZW5kcG9pbnRzLCB0aG91Z2ggdGhleSBjYW4gc3RpbGwgYmUgdXNlZCB3aXRoaW4gcmVndWxhclxuKiBJbm5nZXN0IGZ1bmN0aW9ucyBhcyB3ZWxsLlxuKi9cbmNvbnN0IHN0ZXAgPSB7XG5cdGZldGNoOiBudWxsLFxuXHRhaToge1xuXHRcdGluZmVyOiAoLi4uYXJncykgPT4gZ2V0RGVmZXJyZWRTdGVwVG9vbGluZygpLnRoZW4oKHRvb2xzKSA9PiB0b29scy5haS5pbmZlciguLi5hcmdzKSksXG5cdFx0d3JhcDogKC4uLmFyZ3MpID0+IGdldERlZmVycmVkU3RlcFRvb2xpbmcoKS50aGVuKCh0b29scykgPT4gdG9vbHMuYWkud3JhcCguLi5hcmdzKSksXG5cdFx0bW9kZWxzOiB7IC4uLm1vZGVscyB9XG5cdH0sXG5cdGludm9rZTogKC4uLmFyZ3MpID0+IGdldERlZmVycmVkU3RlcFRvb2xpbmcoKS50aGVuKCh0b29scykgPT4gdG9vbHMuaW52b2tlKC4uLmFyZ3MpKSxcblx0cnVuOiAoLi4uYXJncykgPT4gZ2V0RGVmZXJyZWRTdGVwVG9vbGluZygpLnRoZW4oKHRvb2xzKSA9PiB0b29scy5ydW4oLi4uYXJncykpLFxuXHRzZW5kRXZlbnQ6ICguLi5hcmdzKSA9PiBnZXREZWZlcnJlZFN0ZXBUb29saW5nKCkudGhlbigodG9vbHMpID0+IHRvb2xzLnNlbmRFdmVudCguLi5hcmdzKSksXG5cdHNlbmRTaWduYWw6ICguLi5hcmdzKSA9PiBnZXREZWZlcnJlZFN0ZXBUb29saW5nKCkudGhlbigodG9vbHMpID0+IHRvb2xzLnNlbmRTaWduYWwoLi4uYXJncykpLFxuXHRzbGVlcDogKC4uLmFyZ3MpID0+IGdldERlZmVycmVkU3RlcFRvb2xpbmcoKS50aGVuKCh0b29scykgPT4gdG9vbHMuc2xlZXAoLi4uYXJncykpLFxuXHRzbGVlcFVudGlsOiAoLi4uYXJncykgPT4gZ2V0RGVmZXJyZWRTdGVwVG9vbGluZygpLnRoZW4oKHRvb2xzKSA9PiB0b29scy5zbGVlcFVudGlsKC4uLmFyZ3MpKSxcblx0d2FpdEZvckV2ZW50OiAoLi4uYXJncykgPT4gZ2V0RGVmZXJyZWRTdGVwVG9vbGluZygpLnRoZW4oKHRvb2xzKSA9PiB0b29scy53YWl0Rm9yRXZlbnQoLi4uYXJncykpLFxuXHR3YWl0Rm9yU2lnbmFsOiAoLi4uYXJncykgPT4gZ2V0RGVmZXJyZWRTdGVwVG9vbGluZygpLnRoZW4oKHRvb2xzKSA9PiB0b29scy53YWl0Rm9yU2lnbmFsKC4uLmFyZ3MpKVxufTtcbi8qKlxuKiBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHJldHJpZXZlIG9yIGNyZWF0ZSBzdGVwIHRvb2xpbmcgZm9yIHRoZSBjdXJyZW50XG4qIGV4ZWN1dGlvbiBjb250ZXh0LlxuKlxuKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyBhbiBleGlzdGluZyBjb250ZXh0IHRvIGNyZWF0ZSB0aGUgc3RlcCB0b29saW5nO1xuKiBzb21ldGhpbmcgbXVzdCBkZWNsYXJlIHRoZSBJbm5nZXN0IGV4ZWN1dGlvbiBjb250ZXh0IGJlZm9yZSB0aGlzIGNhbiBiZSB1c2VkLlxuKi9cbmNvbnN0IGdldERlZmVycmVkU3RlcFRvb2xpbmcgPSBhc3luYyAoKSA9PiB7XG5cdGNvbnN0IGN0eCA9IGF3YWl0IGdldEFzeW5jQ3R4KCk7XG5cdGlmICghY3R4KSB0aHJvdyBuZXcgRXJyb3IoXCJgc3RlcGAgdG9vbHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gSW5uZ2VzdCBmdW5jdGlvbiBleGVjdXRpb25zOyBubyBjb250ZXh0IHdhcyBmb3VuZFwiKTtcblx0aWYgKCFjdHguYXBwKSB0aHJvdyBuZXcgRXJyb3IoXCJgc3RlcGAgdG9vbHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gSW5uZ2VzdCBmdW5jdGlvbiBleGVjdXRpb25zOyBubyBJbm5nZXN0IGNsaWVudCB3YXMgZm91bmQgaW4gdGhlIGV4ZWN1dGlvbiBjb250ZXh0XCIpO1xuXHRpZiAoIWN0eC5leGVjdXRpb24pIHRocm93IG5ldyBFcnJvcihcImBzdGVwYCB0b29scyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiBJbm5nZXN0IGZ1bmN0aW9uIGV4ZWN1dGlvbnM7IG5vIGV4ZWN1dGlvbiBjb250ZXh0IHdhcyBmb3VuZFwiKTtcblx0cmV0dXJuIGN0eC5leGVjdXRpb24uY3R4LnN0ZXA7XG59O1xuLyoqXG4qIFRoZSBldmVudCBwYXlsb2FkIHBvcnRpb24gb2YgdGhlIG9wdGlvbnMgZm9yIGBzdGVwLmludm9rZSgpYC4gVGhpcyBkb2VzIG5vdFxuKiBpbmNsdWRlIG5vbi1wYXlsb2FkIG9wdGlvbnMgbGlrZSBgdGltZW91dGAgb3IgdGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiovXG5jb25zdCBpbnZva2VQYXlsb2FkU2NoZW1hID0gei5vYmplY3Qoe1xuXHRkYXRhOiB6LnJlY29yZCh6LmFueSgpKS5vcHRpb25hbCgpLFxuXHR1c2VyOiB6LnJlY29yZCh6LmFueSgpKS5vcHRpb25hbCgpLFxuXHR2OiB6LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFNURVBfSU5ERVhJTkdfU1VGRklYLCBjcmVhdGVTdGVwVG9vbHMsIGdhdGV3YXlTeW1ib2wsIGdldFN0ZXBPcHRpb25zLCBpbnZva2VQYXlsb2FkU2NoZW1hLCBzdGVwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0U3RlcFRvb2xzLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBc3luY0N0eCIsImxvZ1ByZWZpeCIsIlN0ZXBNb2RlIiwiU3RlcE9wQ29kZSIsInRpbWVTdHIiLCJnZXRJU09TdHJpbmciLCJpc1RlbXBvcmFsRHVyYXRpb24iLCJmZXRjaCIsIklubmdlc3RGdW5jdGlvbiIsIklubmdlc3RGdW5jdGlvblJlZmVyZW5jZSIsInoiLCJtb2RlbHMiLCJnZXRTdGVwT3B0aW9ucyIsIm9wdGlvbnMiLCJpZCIsIlNURVBfSU5ERVhJTkdfU1VGRklYIiwiY3JlYXRlU3RlcFRvb2xzIiwiY2xpZW50IiwiZXhlY3V0aW9uIiwic3RlcEhhbmRsZXIiLCJjcmVhdGVUb29sIiwibWF0Y2hPcCIsIm9wdHMiLCJhcmdzIiwiY3JlYXRlU3RlcFJ1biIsInR5cGUiLCJuYW1lIiwiX2ZuIiwiaW5wdXQiLCJsZW5ndGgiLCJtb2RlIiwiU3luYyIsIm9wIiwiU3RlcFBsYW5uZWQiLCJkaXNwbGF5TmFtZSIsIk9iamVjdCIsImtleXMiLCJ1c2VybGFuZCIsImZuIiwiXyIsInRvb2xzIiwic2VuZEV2ZW50IiwiX2lkT3JPcHRpb25zIiwicGF5bG9hZCIsImhlYWRlcnMiLCJ3YWl0Rm9yU2lnbmFsIiwiQXN5bmMiLCJXYWl0Rm9yU2lnbmFsIiwic2lnbmFsIiwidGltZW91dCIsImNvbmZsaWN0Iiwib25Db25mbGljdCIsInNlbmRTaWduYWwiLCJkYXRhIiwid2FpdEZvckV2ZW50IiwibWF0Y2hPcHRzIiwibWF0Y2giLCJpZiIsIldhaXRGb3JFdmVudCIsImV2ZW50IiwicnVuIiwiYWkiLCJpbmZlciIsIm1vZGVsIiwiYm9keSIsInJlc3QiLCJtb2RlbENvcHkiLCJvbkNhbGwiLCJBaUdhdGV3YXkiLCJ1cmwiLCJhdXRoX2tleSIsImF1dGhLZXkiLCJmb3JtYXQiLCJ3cmFwIiwic2xlZXAiLCJ0aW1lIiwibXNUaW1lU3RyIiwidG90YWwiLCJ1bml0IiwiU2xlZXAiLCJzbGVlcFVudGlsIiwiaXNvIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsImludm9rZSIsImludm9rZU9wdHMiLCJvcHRzU2NoZW1hIiwiaW52b2tlUGF5bG9hZFNjaGVtYSIsImV4dGVuZCIsInVuaW9uIiwibnVtYmVyIiwic3RyaW5nIiwiZGF0ZSIsIm9wdGlvbmFsIiwicGFyc2VkRm5PcHRzIiwiX3R5cGUiLCJsaXRlcmFsIiwiZGVmYXVsdCIsImZ1bmN0aW9uIiwibWluIiwib3IiLCJpbnN0YW5jZW9mIiwic2FmZVBhcnNlIiwic3VjY2VzcyIsInVzZXIiLCJ2IiwiZnVuY3Rpb25faWQiLCJhcHBJZCIsImZ1bmN0aW9uSWQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIkludm9rZUZ1bmN0aW9uIiwiZ2F0ZXdheVN5bWJvbCIsImluaXQiLCJSZXF1ZXN0IiwidG9TdHJpbmciLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJIZWFkZXJzIiwiR2F0ZXdheSIsIm1ldGhvZCIsIlN5bWJvbCIsImZvciIsInN0ZXAiLCJnZXREZWZlcnJlZFN0ZXBUb29saW5nIiwidGhlbiIsImN0eCIsImFwcCIsIm9iamVjdCIsInJlY29yZCIsImFueSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestStepTools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/NonRetriableError.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/NonRetriableError.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NonRetriableError: () => (/* binding */ NonRetriableError)\n/* harmony export */ });\n//#region src/components/NonRetriableError.ts\n/**\n* An error that, when thrown, indicates to Inngest that the function should\n* cease all execution and not retry.\n*\n* A `message` must be provided, and an optional `cause` can be provided to\n* provide more context to the error.\n*\n* @public\n*/ var NonRetriableError = class extends Error {\n    constructor(message, options){\n        super(message);\n        this.cause = options?.cause;\n        this.name = \"NonRetriableError\";\n    }\n};\n//#endregion\n //# sourceMappingURL=NonRetriableError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2Q0FBNkM7QUFDN0M7Ozs7Ozs7O0FBUUEsR0FDQSxJQUFJQSxvQkFBb0IsY0FBY0M7SUFPckNDLFlBQVlDLE9BQU8sRUFBRUMsT0FBTyxDQUFFO1FBQzdCLEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNFLEtBQUssR0FBR0QsU0FBU0M7UUFDdEIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDYjtBQUNEO0FBRUEsWUFBWTtBQUNpQixDQUM3Qiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Ob25SZXRyaWFibGVFcnJvci5qcz82Mzc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvY29tcG9uZW50cy9Ob25SZXRyaWFibGVFcnJvci50c1xuLyoqXG4qIEFuIGVycm9yIHRoYXQsIHdoZW4gdGhyb3duLCBpbmRpY2F0ZXMgdG8gSW5uZ2VzdCB0aGF0IHRoZSBmdW5jdGlvbiBzaG91bGRcbiogY2Vhc2UgYWxsIGV4ZWN1dGlvbiBhbmQgbm90IHJldHJ5LlxuKlxuKiBBIGBtZXNzYWdlYCBtdXN0IGJlIHByb3ZpZGVkLCBhbmQgYW4gb3B0aW9uYWwgYGNhdXNlYCBjYW4gYmUgcHJvdmlkZWQgdG9cbiogcHJvdmlkZSBtb3JlIGNvbnRleHQgdG8gdGhlIGVycm9yLlxuKlxuKiBAcHVibGljXG4qL1xudmFyIE5vblJldHJpYWJsZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdC8qKlxuXHQqIFRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBlcnJvciwgaWYgYW55LlxuXHQqXG5cdCogVGhpcyB3aWxsIGJlIHNlcmlhbGl6ZWQgYW5kIHNlbnQgdG8gSW5uZ2VzdC5cblx0Ki9cblx0Y2F1c2U7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLmNhdXNlID0gb3B0aW9ucz8uY2F1c2U7XG5cdFx0dGhpcy5uYW1lID0gXCJOb25SZXRyaWFibGVFcnJvclwiO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IE5vblJldHJpYWJsZUVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob25SZXRyaWFibGVFcnJvci5qcy5tYXAiXSwibmFtZXMiOlsiTm9uUmV0cmlhYmxlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm9wdGlvbnMiLCJjYXVzZSIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/NonRetriableError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/RetryAfterError.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/RetryAfterError.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RetryAfterError: () => (/* binding */ RetryAfterError)\n/* harmony export */ });\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n\n//#region src/components/RetryAfterError.ts\n/**\n* An error that, when thrown, indicates to Inngest that the function should be\n* retried after a given amount of time.\n*\n* A `message` must be provided, as well as a `retryAfter` parameter, which can\n* be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.\n*\n* An optional `cause` can be provided to provide more context to the error.\n*\n* @public\n*/ var RetryAfterError = class extends Error {\n    constructor(message, retryAfter, options){\n        super(message);\n        if (retryAfter instanceof Date) this.retryAfter = retryAfter.toISOString();\n        else {\n            const seconds = `${Math.ceil((typeof retryAfter === \"string\" ? ms__WEBPACK_IMPORTED_MODULE_0__(retryAfter) : retryAfter) / 1e3)}`;\n            if (!isFinite(Number(seconds))) throw new Error(\"retryAfter must be a number of milliseconds, a ms-compatible string, or a Date\");\n            this.retryAfter = seconds;\n        }\n        this.cause = options?.cause;\n    }\n};\n//#endregion\n //# sourceMappingURL=RetryAfterError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1JldHJ5QWZ0ZXJFcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQjtBQUVwQiwyQ0FBMkM7QUFDM0M7Ozs7Ozs7Ozs7QUFVQSxHQUNBLElBQUlDLGtCQUFrQixjQUFjQztJQVluQ0MsWUFBWUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sQ0FBRTtRQUN6QyxLQUFLLENBQUNGO1FBQ04sSUFBSUMsc0JBQXNCRSxNQUFNLElBQUksQ0FBQ0YsVUFBVSxHQUFHQSxXQUFXRyxXQUFXO2FBQ25FO1lBQ0osTUFBTUMsVUFBVSxDQUFDLEVBQUVDLEtBQUtDLElBQUksQ0FBQyxDQUFDLE9BQU9OLGVBQWUsV0FBV0wsK0JBQUVBLENBQUNLLGNBQWNBLFVBQVMsSUFBSyxLQUFLLENBQUM7WUFDcEcsSUFBSSxDQUFDTyxTQUFTQyxPQUFPSixXQUFXLE1BQU0sSUFBSVAsTUFBTTtZQUNoRCxJQUFJLENBQUNHLFVBQVUsR0FBR0k7UUFDbkI7UUFDQSxJQUFJLENBQUNLLEtBQUssR0FBR1IsU0FBU1E7SUFDdkI7QUFDRDtBQUVBLFlBQVk7QUFDZSxDQUMzQiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9SZXRyeUFmdGVyRXJyb3IuanM/NTVmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbXMgZnJvbSBcIm1zXCI7XG5cbi8vI3JlZ2lvbiBzcmMvY29tcG9uZW50cy9SZXRyeUFmdGVyRXJyb3IudHNcbi8qKlxuKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIHRvIElubmdlc3QgdGhhdCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlXG4qIHJldHJpZWQgYWZ0ZXIgYSBnaXZlbiBhbW91bnQgb2YgdGltZS5cbipcbiogQSBgbWVzc2FnZWAgbXVzdCBiZSBwcm92aWRlZCwgYXMgd2VsbCBhcyBhIGByZXRyeUFmdGVyYCBwYXJhbWV0ZXIsIHdoaWNoIGNhblxuKiBiZSBhIGBudW1iZXJgIG9mIG1pbGxpc2Vjb25kcywgYW4gYG1zYC1jb21wYXRpYmxlIHRpbWUgc3RyaW5nLCBvciBhIGBEYXRlYC5cbipcbiogQW4gb3B0aW9uYWwgYGNhdXNlYCBjYW4gYmUgcHJvdmlkZWQgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQgdG8gdGhlIGVycm9yLlxuKlxuKiBAcHVibGljXG4qL1xudmFyIFJldHJ5QWZ0ZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHQvKipcblx0KiBUaGUgdW5kZXJseWluZyBjYXVzZSBvZiB0aGUgZXJyb3IsIGlmIGFueS5cblx0KlxuXHQqIFRoaXMgd2lsbCBiZSBzZXJpYWxpemVkIGFuZCBzZW50IHRvIElubmdlc3QuXG5cdCovXG5cdGNhdXNlO1xuXHQvKipcblx0KiBUaGUgdGltZSBhZnRlciB3aGljaCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlIHJldHJpZWQuIFJlcHJlc2VudHMgZWl0aGVyIGFcblx0KiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIGEgUkZDMzMzOSBkYXRlLlxuXHQqL1xuXHRyZXRyeUFmdGVyO1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXRyeUFmdGVyLCBvcHRpb25zKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0aWYgKHJldHJ5QWZ0ZXIgaW5zdGFuY2VvZiBEYXRlKSB0aGlzLnJldHJ5QWZ0ZXIgPSByZXRyeUFmdGVyLnRvSVNPU3RyaW5nKCk7XG5cdFx0ZWxzZSB7XG5cdFx0XHRjb25zdCBzZWNvbmRzID0gYCR7TWF0aC5jZWlsKCh0eXBlb2YgcmV0cnlBZnRlciA9PT0gXCJzdHJpbmdcIiA/IG1zKHJldHJ5QWZ0ZXIpIDogcmV0cnlBZnRlcikgLyAxZTMpfWA7XG5cdFx0XHRpZiAoIWlzRmluaXRlKE51bWJlcihzZWNvbmRzKSkpIHRocm93IG5ldyBFcnJvcihcInJldHJ5QWZ0ZXIgbXVzdCBiZSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGEgbXMtY29tcGF0aWJsZSBzdHJpbmcsIG9yIGEgRGF0ZVwiKTtcblx0XHRcdHRoaXMucmV0cnlBZnRlciA9IHNlY29uZHM7XG5cdFx0fVxuXHRcdHRoaXMuY2F1c2UgPSBvcHRpb25zPy5jYXVzZTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBSZXRyeUFmdGVyRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJldHJ5QWZ0ZXJFcnJvci5qcy5tYXAiXSwibmFtZXMiOlsibXMiLCJSZXRyeUFmdGVyRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInJldHJ5QWZ0ZXIiLCJvcHRpb25zIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2Vjb25kcyIsIk1hdGgiLCJjZWlsIiwiaXNGaW5pdGUiLCJOdW1iZXIiLCJjYXVzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/RetryAfterError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/StepError.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/components/StepError.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StepError: () => (/* binding */ StepError)\n/* harmony export */ });\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n\n\n//#region src/components/StepError.ts\n/**\n* An error that represents a step exhausting all retries and failing. This is\n* thrown by an Inngest step if it fails.\n*\n* It's synonymous with an `Error`, with the addition of the `stepId` that\n* failed.\n*\n* @public\n*/ var StepError = class extends Error {\n    constructor(stepId, err){\n        const parsedErr = _types_js__WEBPACK_IMPORTED_MODULE_0__.jsonErrorSchema.parse(err);\n        super(parsedErr.message);\n        this.stepId = stepId;\n        this.name = parsedErr.name;\n        this.stepId = stepId;\n        this.stack = parsedErr.stack ?? void 0;\n        this.cause = parsedErr.cause ? (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_1__.deserializeError)(parsedErr.cause, true) : void 0;\n    }\n};\n//#endregion\n //# sourceMappingURL=StepError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1N0ZXBFcnJvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDVTtBQUV4RCxxQ0FBcUM7QUFDckM7Ozs7Ozs7O0FBUUEsR0FDQSxJQUFJRSxZQUFZLGNBQWNDO0lBRTdCQyxZQUFZQyxNQUFNLEVBQUVDLEdBQUcsQ0FBRTtRQUN4QixNQUFNQyxZQUFZUCxzREFBZUEsQ0FBQ1EsS0FBSyxDQUFDRjtRQUN4QyxLQUFLLENBQUNDLFVBQVVFLE9BQU87UUFDdkIsSUFBSSxDQUFDSixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDSyxJQUFJLEdBQUdILFVBQVVHLElBQUk7UUFDMUIsSUFBSSxDQUFDTCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDTSxLQUFLLEdBQUdKLFVBQVVJLEtBQUssSUFBSSxLQUFLO1FBQ3JDLElBQUksQ0FBQ0MsS0FBSyxHQUFHTCxVQUFVSyxLQUFLLEdBQUdYLG9FQUFnQkEsQ0FBQ00sVUFBVUssS0FBSyxFQUFFLFFBQVEsS0FBSztJQUMvRTtBQUNEO0FBRUEsWUFBWTtBQUNTLENBQ3JCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1N0ZXBFcnJvci5qcz8yZWU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpzb25FcnJvclNjaGVtYSB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVFcnJvciB9IGZyb20gXCIuLi9oZWxwZXJzL2Vycm9ycy5qc1wiO1xuXG4vLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvU3RlcEVycm9yLnRzXG4vKipcbiogQW4gZXJyb3IgdGhhdCByZXByZXNlbnRzIGEgc3RlcCBleGhhdXN0aW5nIGFsbCByZXRyaWVzIGFuZCBmYWlsaW5nLiBUaGlzIGlzXG4qIHRocm93biBieSBhbiBJbm5nZXN0IHN0ZXAgaWYgaXQgZmFpbHMuXG4qXG4qIEl0J3Mgc3lub255bW91cyB3aXRoIGFuIGBFcnJvcmAsIHdpdGggdGhlIGFkZGl0aW9uIG9mIHRoZSBgc3RlcElkYCB0aGF0XG4qIGZhaWxlZC5cbipcbiogQHB1YmxpY1xuKi9cbnZhciBTdGVwRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y2F1c2U7XG5cdGNvbnN0cnVjdG9yKHN0ZXBJZCwgZXJyKSB7XG5cdFx0Y29uc3QgcGFyc2VkRXJyID0ganNvbkVycm9yU2NoZW1hLnBhcnNlKGVycik7XG5cdFx0c3VwZXIocGFyc2VkRXJyLm1lc3NhZ2UpO1xuXHRcdHRoaXMuc3RlcElkID0gc3RlcElkO1xuXHRcdHRoaXMubmFtZSA9IHBhcnNlZEVyci5uYW1lO1xuXHRcdHRoaXMuc3RlcElkID0gc3RlcElkO1xuXHRcdHRoaXMuc3RhY2sgPSBwYXJzZWRFcnIuc3RhY2sgPz8gdm9pZCAwO1xuXHRcdHRoaXMuY2F1c2UgPSBwYXJzZWRFcnIuY2F1c2UgPyBkZXNlcmlhbGl6ZUVycm9yKHBhcnNlZEVyci5jYXVzZSwgdHJ1ZSkgOiB2b2lkIDA7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgU3RlcEVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGVwRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbImpzb25FcnJvclNjaGVtYSIsImRlc2VyaWFsaXplRXJyb3IiLCJTdGVwRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwic3RlcElkIiwiZXJyIiwicGFyc2VkRXJyIiwicGFyc2UiLCJtZXNzYWdlIiwibmFtZSIsInN0YWNrIiwiY2F1c2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/StepError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/InngestExecution.js":
/*!***********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/InngestExecution.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InngestExecution: () => (/* binding */ InngestExecution),\n/* harmony export */   InngestExecution_exports: () => (/* binding */ InngestExecution_exports),\n/* harmony export */   PREFERRED_EXECUTION_VERSION: () => (/* binding */ PREFERRED_EXECUTION_VERSION)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n\n\n\n//#region src/components/execution/InngestExecution.ts\nvar InngestExecution_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_1__.__export)({\n    ExecutionVersion: ()=>_helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion,\n    InngestExecution: ()=>InngestExecution,\n    PREFERRED_EXECUTION_VERSION: ()=>PREFERRED_EXECUTION_VERSION\n});\n/**\n* The preferred execution version that will be used by the SDK when handling\n* brand new runs where the Executor is allowing us to choose.\n*\n* Changing this should not ever be a breaking change, as this will only change\n* new runs, not existing ones.\n*/ const PREFERRED_EXECUTION_VERSION = _helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V1;\nvar InngestExecution = class {\n    constructor(options){\n        this.options = options;\n        this.debug = debug__WEBPACK_IMPORTED_MODULE_0__(`${_helpers_consts_js__WEBPACK_IMPORTED_MODULE_2__.debugPrefix}:${this.options.runId}`);\n    }\n};\n//#endregion\n //# sourceMappingURL=InngestExecution.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4RDtBQUNVO0FBQzlDO0FBRTFCLHNEQUFzRDtBQUN0RCxJQUFJSSwyQkFBMkIsYUFBYSxHQUFHSixzRUFBUUEsQ0FBQztJQUN2REMsa0JBQWtCLElBQU1BLGdFQUFnQkE7SUFDeENJLGtCQUFrQixJQUFNQTtJQUN4QkMsNkJBQTZCLElBQU1BO0FBQ3BDO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTUEsOEJBQThCTCxnRUFBZ0JBLENBQUNNLEVBQUU7QUFDdkQsSUFBSUYsbUJBQW1CO0lBRXRCRyxZQUFZQyxPQUFPLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDTixLQUFLLEdBQUdBLGtDQUFLQSxDQUFDLENBQUMsRUFBRUQsMkRBQVdBLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ08sT0FBTyxDQUFDQyxLQUFLLENBQUMsQ0FBQztJQUMxRDtBQUNEO0FBRUEsWUFBWTtBQUN1RSxDQUNuRiw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi5qcz8xMTUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXhwb3J0IH0gZnJvbSBcIi4uLy4uL192aXJ0dWFsL3JvbGxkb3duX3J1bnRpbWUuanNcIjtcbmltcG9ydCB7IEV4ZWN1dGlvblZlcnNpb24sIGRlYnVnUHJlZml4IH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvY29uc3RzLmpzXCI7XG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5cbi8vI3JlZ2lvbiBzcmMvY29tcG9uZW50cy9leGVjdXRpb24vSW5uZ2VzdEV4ZWN1dGlvbi50c1xudmFyIElubmdlc3RFeGVjdXRpb25fZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBfX2V4cG9ydCh7XG5cdEV4ZWN1dGlvblZlcnNpb246ICgpID0+IEV4ZWN1dGlvblZlcnNpb24sXG5cdElubmdlc3RFeGVjdXRpb246ICgpID0+IElubmdlc3RFeGVjdXRpb24sXG5cdFBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTjogKCkgPT4gUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OXG59KTtcbi8qKlxuKiBUaGUgcHJlZmVycmVkIGV4ZWN1dGlvbiB2ZXJzaW9uIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRoZSBTREsgd2hlbiBoYW5kbGluZ1xuKiBicmFuZCBuZXcgcnVucyB3aGVyZSB0aGUgRXhlY3V0b3IgaXMgYWxsb3dpbmcgdXMgdG8gY2hvb3NlLlxuKlxuKiBDaGFuZ2luZyB0aGlzIHNob3VsZCBub3QgZXZlciBiZSBhIGJyZWFraW5nIGNoYW5nZSwgYXMgdGhpcyB3aWxsIG9ubHkgY2hhbmdlXG4qIG5ldyBydW5zLCBub3QgZXhpc3Rpbmcgb25lcy5cbiovXG5jb25zdCBQUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gPSBFeGVjdXRpb25WZXJzaW9uLlYxO1xudmFyIElubmdlc3RFeGVjdXRpb24gPSBjbGFzcyB7XG5cdGRlYnVnO1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmRlYnVnID0gZGVidWcoYCR7ZGVidWdQcmVmaXh9OiR7dGhpcy5vcHRpb25zLnJ1bklkfWApO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IElubmdlc3RFeGVjdXRpb24sIElubmdlc3RFeGVjdXRpb25fZXhwb3J0cywgUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0RXhlY3V0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4cG9ydCIsIkV4ZWN1dGlvblZlcnNpb24iLCJkZWJ1Z1ByZWZpeCIsImRlYnVnIiwiSW5uZ2VzdEV4ZWN1dGlvbl9leHBvcnRzIiwiSW5uZ2VzdEV4ZWN1dGlvbiIsIlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTiIsIlYxIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwicnVuSWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/als.js":
/*!**********************************************************!*\
  !*** ./node_modules/inngest/components/execution/als.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAsyncCtx: () => (/* binding */ getAsyncCtx),\n/* harmony export */   getAsyncLocalStorage: () => (/* binding */ getAsyncLocalStorage)\n/* harmony export */ });\n//#region src/components/execution/als.ts\n/**\n* A local-only symbol used as a key in global state to store the async local\n* storage instance.\n*/ const alsSymbol = Symbol.for(\"inngest:als\");\n/**\n* Retrieve the async context for the current execution.\n*/ const getAsyncCtx = async ()=>{\n    return getAsyncLocalStorage().then((als)=>als.getStore());\n};\n/**\n* Get a singleton instance of `AsyncLocalStorage` used to store and retrieve\n* async context for the current execution.\n*/ const getAsyncLocalStorage = async ()=>{\n    globalThis[alsSymbol] ??= new Promise(async (resolve)=>{\n        try {\n            const { AsyncLocalStorage } = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! node:async_hooks */ \"node:async_hooks\", 19));\n            resolve(new AsyncLocalStorage());\n        } catch (_err) {\n            console.warn(\"node:async_hooks is not supported in this runtime. Experimental async context is disabled.\");\n            resolve({\n                getStore: ()=>void 0,\n                run: (_, fn)=>fn()\n            });\n        }\n    });\n    return globalThis[alsSymbol];\n};\n//#endregion\n //# sourceMappingURL=als.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9hbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx5Q0FBeUM7QUFDekM7OztBQUdBLEdBQ0EsTUFBTUEsWUFBWUMsT0FBT0MsR0FBRyxDQUFDO0FBQzdCOztBQUVBLEdBQ0EsTUFBTUMsY0FBYztJQUNuQixPQUFPQyx1QkFBdUJDLElBQUksQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxRQUFRO0FBQ3pEO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTUgsdUJBQXVCO0lBQzVCSSxVQUFVLENBQUNSLFVBQVUsS0FBSyxJQUFJUyxRQUFRLE9BQU9DO1FBQzVDLElBQUk7WUFDSCxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUcsTUFBTSxzSUFBMEI7WUFDOURELFFBQVEsSUFBSUM7UUFDYixFQUFFLE9BQU9DLE1BQU07WUFDZEMsUUFBUUMsSUFBSSxDQUFDO1lBQ2JKLFFBQVE7Z0JBQ1BILFVBQVUsSUFBTSxLQUFLO2dCQUNyQlEsS0FBSyxDQUFDQyxHQUFHQyxLQUFPQTtZQUNqQjtRQUNEO0lBQ0Q7SUFDQSxPQUFPVCxVQUFVLENBQUNSLFVBQVU7QUFDN0I7QUFFQSxZQUFZO0FBQ2lDLENBQzdDLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9hbHMuanM/OTk5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvZXhlY3V0aW9uL2Fscy50c1xuLyoqXG4qIEEgbG9jYWwtb25seSBzeW1ib2wgdXNlZCBhcyBhIGtleSBpbiBnbG9iYWwgc3RhdGUgdG8gc3RvcmUgdGhlIGFzeW5jIGxvY2FsXG4qIHN0b3JhZ2UgaW5zdGFuY2UuXG4qL1xuY29uc3QgYWxzU3ltYm9sID0gU3ltYm9sLmZvcihcImlubmdlc3Q6YWxzXCIpO1xuLyoqXG4qIFJldHJpZXZlIHRoZSBhc3luYyBjb250ZXh0IGZvciB0aGUgY3VycmVudCBleGVjdXRpb24uXG4qL1xuY29uc3QgZ2V0QXN5bmNDdHggPSBhc3luYyAoKSA9PiB7XG5cdHJldHVybiBnZXRBc3luY0xvY2FsU3RvcmFnZSgpLnRoZW4oKGFscykgPT4gYWxzLmdldFN0b3JlKCkpO1xufTtcbi8qKlxuKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYEFzeW5jTG9jYWxTdG9yYWdlYCB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuKiBhc3luYyBjb250ZXh0IGZvciB0aGUgY3VycmVudCBleGVjdXRpb24uXG4qL1xuY29uc3QgZ2V0QXN5bmNMb2NhbFN0b3JhZ2UgPSBhc3luYyAoKSA9PiB7XG5cdGdsb2JhbFRoaXNbYWxzU3ltYm9sXSA/Pz0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgeyBBc3luY0xvY2FsU3RvcmFnZSB9ID0gYXdhaXQgaW1wb3J0KFwibm9kZTphc3luY19ob29rc1wiKTtcblx0XHRcdHJlc29sdmUobmV3IEFzeW5jTG9jYWxTdG9yYWdlKCkpO1xuXHRcdH0gY2F0Y2ggKF9lcnIpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIm5vZGU6YXN5bmNfaG9va3MgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIHJ1bnRpbWUuIEV4cGVyaW1lbnRhbCBhc3luYyBjb250ZXh0IGlzIGRpc2FibGVkLlwiKTtcblx0XHRcdHJlc29sdmUoe1xuXHRcdFx0XHRnZXRTdG9yZTogKCkgPT4gdm9pZCAwLFxuXHRcdFx0XHRydW46IChfLCBmbikgPT4gZm4oKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGdsb2JhbFRoaXNbYWxzU3ltYm9sXTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgZ2V0QXN5bmNDdHgsIGdldEFzeW5jTG9jYWxTdG9yYWdlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbHMuanMubWFwIl0sIm5hbWVzIjpbImFsc1N5bWJvbCIsIlN5bWJvbCIsImZvciIsImdldEFzeW5jQ3R4IiwiZ2V0QXN5bmNMb2NhbFN0b3JhZ2UiLCJ0aGVuIiwiYWxzIiwiZ2V0U3RvcmUiLCJnbG9iYWxUaGlzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJBc3luY0xvY2FsU3RvcmFnZSIsIl9lcnIiLCJjb25zb2xlIiwid2FybiIsInJ1biIsIl8iLCJmbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/als.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/access.js":
/*!******************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/access.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clientProcessorMap: () => (/* binding */ clientProcessorMap)\n/* harmony export */ });\n//#region src/components/execution/otel/access.ts\n/**\n* A map of Inngest clients to their OTel span processors. This is used to\n* ensure that we only create one span processor per client, and that we can\n* access the span processor from the client without exposing the OTel\n* libraries to the user.\n*/ const clientProcessorMap = /* @__PURE__ */ new WeakMap();\n//#endregion\n //# sourceMappingURL=access.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2FjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaURBQWlEO0FBQ2pEOzs7OztBQUtBLEdBQ0EsTUFBTUEscUJBQXFCLGFBQWEsR0FBRyxJQUFJQztBQUUvQyxZQUFZO0FBQ2tCLENBQzlCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2FjY2Vzcy5qcz9hYjc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvY29tcG9uZW50cy9leGVjdXRpb24vb3RlbC9hY2Nlc3MudHNcbi8qKlxuKiBBIG1hcCBvZiBJbm5nZXN0IGNsaWVudHMgdG8gdGhlaXIgT1RlbCBzcGFuIHByb2Nlc3NvcnMuIFRoaXMgaXMgdXNlZCB0b1xuKiBlbnN1cmUgdGhhdCB3ZSBvbmx5IGNyZWF0ZSBvbmUgc3BhbiBwcm9jZXNzb3IgcGVyIGNsaWVudCwgYW5kIHRoYXQgd2UgY2FuXG4qIGFjY2VzcyB0aGUgc3BhbiBwcm9jZXNzb3IgZnJvbSB0aGUgY2xpZW50IHdpdGhvdXQgZXhwb3NpbmcgdGhlIE9UZWxcbiogbGlicmFyaWVzIHRvIHRoZSB1c2VyLlxuKi9cbmNvbnN0IGNsaWVudFByb2Nlc3Nvck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGNsaWVudFByb2Nlc3Nvck1hcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzLmpzLm1hcCJdLCJuYW1lcyI6WyJjbGllbnRQcm9jZXNzb3JNYXAiLCJXZWFrTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/access.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v0.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v0.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createV0InngestExecution: () => (/* binding */ createV0InngestExecution),\n/* harmony export */   v0_exports: () => (/* binding */ v0_exports)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _InngestExecution_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/* harmony import */ var _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var _helpers_functions_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/* harmony import */ var _InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/* harmony import */ var _helpers_promises_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/* harmony import */ var _RetryAfterError_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\n/* harmony import */ var _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var canonicalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//#region src/components/execution/v0.ts\nvar v0_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_2__.__export)({\n    V0InngestExecution: ()=>V0InngestExecution,\n    _internals: ()=>_internals,\n    createV0InngestExecution: ()=>createV0InngestExecution\n});\nconst { sha1 } = hash_js__WEBPACK_IMPORTED_MODULE_0__;\nconst createV0InngestExecution = (options)=>{\n    return new V0InngestExecution(options);\n};\nvar V0InngestExecution = class extends _InngestExecution_js__WEBPACK_IMPORTED_MODULE_3__.InngestExecution {\n    constructor(options){\n        super(options);\n        this.version = _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V0;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n    }\n    start() {\n        this.debug(\"starting V0 execution\");\n        return this.execution ??= this._start().then((result)=>{\n            this.debug(\"result:\", result);\n            return result;\n        });\n    }\n    async _start() {\n        this.state.hooks = await this.initializeMiddleware();\n        try {\n            await this.transformInput();\n            await this.state.hooks.beforeMemoization?.();\n            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n                await this.state.hooks.afterMemoization?.();\n                await this.state.hooks.beforeExecution?.();\n            }\n            const userFnPromise = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_5__.runAsPromise)(()=>this.userFnToRun(this.fnArg));\n            let pos = -1;\n            do {\n                if (pos >= 0) {\n                    if (!this.options.requestedRunStep && pos === this.state.opStack.length - 1) {\n                        await this.state.hooks.afterMemoization?.();\n                        await this.state.hooks.beforeExecution?.();\n                    }\n                    this.state.tickOps = {};\n                    const incomingOp = this.state.opStack[pos];\n                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n                    if (!this.state.currentOp) /**\n\t\t\t\t\t* We're trying to resume the function, but we can't find where to go.\n\t\t\t\t\t*\n\t\t\t\t\t* This means that either the function has changed or there are async\n\t\t\t\t\t* actions in-between steps that we haven't noticed in previous\n\t\t\t\t\t* executions.\n\t\t\t\t\t*\n\t\t\t\t\t* Whichever the case, this is bad and we can't continue in this\n\t\t\t\t\t* undefined state.\n\t\t\t\t\t*/ throw new _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_6__.NonRetriableError((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.prettyError)({\n                        whatHappened: \" Your function was stopped from running\",\n                        why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                        consequences: \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                        toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                        otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                        stack: true,\n                        code: _helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.ErrCode.NON_DETERMINISTIC_FUNCTION\n                    }));\n                    this.state.currentOp.fulfilled = true;\n                    if (typeof incomingOp.data !== \"undefined\") this.state.currentOp.resolve(incomingOp.data);\n                    else this.state.currentOp.reject(incomingOp.error);\n                }\n                await (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_5__.resolveAfterPending)();\n                this.state.reset();\n                pos++;\n            }while (pos < this.state.opStack.length);\n            await this.state.hooks.afterMemoization?.();\n            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);\n            const runStep = this.options.requestedRunStep || this.getEarlyExecRunStep(discoveredOps);\n            if (runStep) {\n                const userFnOp = this.state.allFoundOps[runStep];\n                const stepToRun = userFnOp?.fn;\n                if (!stepToRun) throw new Error(`Bad stack; executor requesting to run unknown step \"${runStep}\"`);\n                const outgoingUserFnOp = {\n                    ...tickOpToOutgoing(userFnOp),\n                    op: _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.Step\n                };\n                await this.state.hooks.beforeExecution?.();\n                this.state.executingStep = true;\n                const { type: _type, ...rest } = await (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_5__.runAsPromise)(stepToRun).finally(()=>{\n                    this.state.executingStep = false;\n                }).catch(async (error)=>{\n                    return await this.transformOutput({\n                        error\n                    }, outgoingUserFnOp);\n                }).then(async (data)=>{\n                    await this.state.hooks?.afterExecution?.();\n                    return await this.transformOutput({\n                        data\n                    }, outgoingUserFnOp);\n                });\n                return {\n                    type: \"step-ran\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    step: {\n                        ...outgoingUserFnOp,\n                        ...rest\n                    }\n                };\n            }\n            if (!discoveredOps.length) {\n                const fnRet = await Promise.race([\n                    userFnPromise.then((data)=>({\n                            type: \"complete\",\n                            data\n                        })),\n                    (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_5__.resolveNextTick)().then(()=>({\n                            type: \"incomplete\"\n                        }))\n                ]);\n                if (fnRet.type === \"complete\") {\n                    await this.state.hooks.afterExecution?.();\n                    if (Object.values(this.state.allFoundOps).every((op)=>{\n                        return op.fulfilled;\n                    })) return await this.transformOutput({\n                        data: fnRet.data\n                    });\n                } else if (!this.state.hasUsedTools) {\n                    this.state.nonStepFnDetected = true;\n                    const data = await userFnPromise;\n                    await this.state.hooks.afterExecution?.();\n                    return await this.transformOutput({\n                        data\n                    });\n                } else if (!Object.values(this.state.allFoundOps).some((op)=>{\n                    return op.fulfilled === false;\n                })) throw new _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_6__.NonRetriableError((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.functionStoppedRunningErr)(_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));\n            }\n            await this.state.hooks.afterExecution?.();\n            return {\n                type: \"steps-found\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                steps: discoveredOps\n            };\n        } catch (error) {\n            return await this.transformOutput({\n                error\n            });\n        } finally{\n            await this.state.hooks.beforeResponse?.();\n        }\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        return await (0,_InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_9__.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs\n        }, {\n            transformInput: (prev, output)=>{\n                return {\n                    ctx: {\n                        ...prev.ctx,\n                        ...output?.ctx\n                    },\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i)=>({\n                            ...step,\n                            ...output?.steps?.[i]\n                        })),\n                    reqArgs: prev.reqArgs\n                };\n            },\n            transformOutput: (prev, output)=>{\n                return {\n                    result: {\n                        ...prev.result,\n                        ...output?.result\n                    },\n                    step: prev.step\n                };\n            }\n        });\n    }\n    createExecutionState() {\n        const state = {\n            allFoundOps: {},\n            tickOps: {},\n            tickOpHashes: {},\n            currentOp: void 0,\n            hasUsedTools: false,\n            reset: ()=>{\n                state.tickOpHashes = {};\n                state.allFoundOps = {\n                    ...state.allFoundOps,\n                    ...state.tickOps\n                };\n            },\n            nonStepFnDetected: false,\n            executingStep: false,\n            opStack: this.options.stepCompletionOrder.reduce((acc, stepId)=>{\n                const stepState = this.options.stepState[stepId];\n                if (!stepState) return acc;\n                return [\n                    ...acc,\n                    stepState\n                ];\n            }, [])\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op])=>[\n                id,\n                {\n                    id: op.id,\n                    rawArgs: op.rawArgs,\n                    data: op.data,\n                    error: op.error,\n                    fulfilled: op.fulfilled,\n                    seen: true\n                }\n            ]));\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) return this.options.fn[\"fn\"];\n        if (!this.options.fn[\"onFailureFn\"]) /**\n\t\t* Somehow, we've ended up detecting that this is a failure handler but\n\t\t* doesn't have an `onFailure` function. This should never happen.\n\t\t*/ throw new Error(\"Cannot find function `onFailure` handler\");\n        return this.options.fn[\"onFailureFn\"];\n    }\n    createFnArg() {\n        this.state.tickOps = this.state.allFoundOps;\n        /**\n\t\t* Create a unique hash of an operation using only a subset of the operation's\n\t\t* properties; will never use `data` and will guarantee the order of the\n\t\t* object so we don't rely on individual tools for that.\n\t\t*\n\t\t* If the operation already contains an ID, the current ID will be used\n\t\t* instead, so that users can provide their own IDs.\n\t\t*/ const hashOp = (op)=>{\n            /**\n\t\t\t* It's difficult for v0 to understand whether or not an op has\n\t\t\t* historically contained a custom ID, as all step usage now require them.\n\t\t\t*\n\t\t\t* For this reason, we make the assumption that steps in v0 do not have a\n\t\t\t* custom ID and generate one for them as we would in all recommendations\n\t\t\t* and examples.\n\t\t\t*/ const obj = {\n                parent: this.state.currentOp?.id ?? null,\n                op: op.op,\n                name: op.name,\n                opts: op.op === _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepPlanned ? null : op.opts ?? null\n            };\n            const collisionHash = _internals.hashData(obj);\n            const pos = this.state.tickOpHashes[collisionHash] = (this.state.tickOpHashes[collisionHash] ?? -1) + 1;\n            return {\n                ...op,\n                id: _internals.hashData({\n                    pos,\n                    ...obj\n                })\n            };\n        };\n        const stepHandler = ({ args, matchOp, opts })=>{\n            if (this.state.nonStepFnDetected) throw new _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_6__.NonRetriableError((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.functionStoppedRunningErr)(_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.ErrCode.STEP_USED_AFTER_ASYNC));\n            if (this.state.executingStep) throw new _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_6__.NonRetriableError((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.prettyError)({\n                whatHappened: \"Your function was stopped from running\",\n                why: \"We detected that you have nested `step.*` tooling.\",\n                consequences: \"Nesting `step.*` tooling is not supported.\",\n                stack: true,\n                toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                otherwise: \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n                code: _helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.ErrCode.NESTING_STEPS\n            }));\n            this.state.hasUsedTools = true;\n            const opId = hashOp(matchOp((0,_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_10__.getStepOptions)(args[0]), ...args.slice(1)));\n            return new Promise((resolve, reject)=>{\n                this.state.tickOps[opId.id] = {\n                    ...opId,\n                    ...opts?.fn ? {\n                        fn: ()=>opts.fn?.(...args)\n                    } : {},\n                    rawArgs: args,\n                    resolve,\n                    reject,\n                    fulfilled: false\n                };\n            });\n        };\n        const step = (0,_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_10__.createStepTools)(this.options.client, this, stepHandler);\n        let fnArg = {\n            ...this.options.data,\n            step\n        };\n        if (this.options.isFailureHandler) {\n            const eventData = zod_v3__WEBPACK_IMPORTED_MODULE_11__.object({\n                error: _types_js__WEBPACK_IMPORTED_MODULE_8__.jsonErrorSchema\n            }).parse(fnArg.event?.data);\n            fnArg = {\n                ...fnArg,\n                error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.deserializeError)(eventData.error)\n            };\n        }\n        return this.options.transformCtx?.(fnArg) ?? fnArg;\n    }\n    /**\n\t* Using middleware, transform input before running.\n\t*/ async transformInput() {\n        const inputMutations = await this.state.hooks?.transformInput?.({\n            ctx: {\n                ...this.fnArg\n            },\n            steps: Object.values(this.options.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs\n        });\n        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;\n        if (inputMutations?.steps) this.state.opStack = [\n            ...inputMutations.steps\n        ];\n    }\n    getEarlyExecRunStep(ops) {\n        if (ops.length !== 1) return;\n        const op = ops[0];\n        if (op && op.op === _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepPlanned) return op.id;\n    }\n    /**\n\t* Using middleware, transform output before returning.\n\t*/ async transformOutput(dataOrError, step) {\n        const output = {\n            ...dataOrError\n        };\n        if (typeof output.error !== \"undefined\") output.data = (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.serializeError)(output.error);\n        const transformedOutput = await this.state.hooks?.transformOutput?.({\n            result: {\n                ...output\n            },\n            step\n        });\n        const { data, error } = {\n            ...output,\n            ...transformedOutput?.result\n        };\n        if (!step) await this.state.hooks?.finished?.({\n            result: {\n                ...typeof error !== \"undefined\" ? {\n                    error\n                } : {\n                    data\n                }\n            }\n        });\n        if (typeof error !== \"undefined\") {\n            /**\n\t\t\t* Ensure we give middleware the chance to decide on retriable behaviour\n\t\t\t* by looking at the error returned from output transformation.\n\t\t\t*/ let retriable = !(error instanceof _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_6__.NonRetriableError);\n            if (retriable && error instanceof _RetryAfterError_js__WEBPACK_IMPORTED_MODULE_12__.RetryAfterError) retriable = error.retryAfter;\n            const serializedError = (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_7__.serializeError)(error);\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_13__.undefinedToNull)(data)\n        };\n    }\n};\nconst tickOpToOutgoing = (op)=>{\n    return {\n        op: op.op,\n        id: op.id,\n        name: op.name,\n        opts: op.opts\n    };\n};\nconst hashData = (op)=>{\n    return sha1().update(canonicalize__WEBPACK_IMPORTED_MODULE_1__(op)).digest(\"hex\");\n};\n/**\n* Exported for testing.\n*/ const _internals = {\n    hashData\n};\n//#endregion\n //# sourceMappingURL=v0.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ0g7QUFDRTtBQUNKO0FBQ0c7QUFDZ0U7QUFDL0Q7QUFDTjtBQUN3QztBQUN2QztBQUNpQjtBQUM5QztBQUNFO0FBQ1c7QUFFeEMsd0NBQXdDO0FBQ3hDLElBQUlzQixhQUFhLGFBQWEsR0FBR3RCLHNFQUFRQSxDQUFDO0lBQ3pDdUIsb0JBQW9CLElBQU1BO0lBQzFCQyxZQUFZLElBQU1BO0lBQ2xCQywwQkFBMEIsSUFBTUE7QUFDakM7QUFDQSxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHTixvQ0FBTUE7QUFDdkIsTUFBTUssMkJBQTJCLENBQUNFO0lBQ2pDLE9BQU8sSUFBSUosbUJBQW1CSTtBQUMvQjtBQUNBLElBQUlKLHFCQUFxQixjQUFjbkIsa0VBQWdCQTtJQU10RHdCLFlBQVlELE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO2FBTlBFLFVBQVU1QixnRUFBZ0JBLENBQUM2QixFQUFFO1FBTzVCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUksQ0FBQ0MsY0FBYztRQUN0QyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLENBQUNDLG9CQUFvQjtRQUN0QyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLENBQUNDLFdBQVc7SUFDOUI7SUFDQUMsUUFBUTtRQUNQLElBQUksQ0FBQ0MsS0FBSyxDQUFDO1FBQ1gsT0FBTyxJQUFJLENBQUNDLFNBQVMsS0FBSyxJQUFJLENBQUNDLE1BQU0sR0FBR0MsSUFBSSxDQUFDLENBQUNDO1lBQzdDLElBQUksQ0FBQ0osS0FBSyxDQUFDLFdBQVdJO1lBQ3RCLE9BQU9BO1FBQ1I7SUFDRDtJQUNBLE1BQU1GLFNBQVM7UUFDZCxJQUFJLENBQUNQLEtBQUssQ0FBQ1UsS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDQyxvQkFBb0I7UUFDbEQsSUFBSTtZQUNILE1B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LE1BQU1HLFdBQVcsQ0FBQzdDO0lBQ2pCLE9BQU8zRCxPQUFPNkgsTUFBTSxDQUFDbEkseUNBQVlBLENBQUNnRSxLQUFLbUUsTUFBTSxDQUFDO0FBQy9DO0FBQ0E7O0FBRUEsR0FDQSxNQUFNaEksYUFBYTtJQUFFMEc7QUFBUztBQUU5QixZQUFZO0FBQ29DLENBQ2hELDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC5qcz8yOTJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXhwb3J0IH0gZnJvbSBcIi4uLy4uL192aXJ0dWFsL3JvbGxkb3duX3J1bnRpbWUuanNcIjtcbmltcG9ydCB7IEV4ZWN1dGlvblZlcnNpb24gfSBmcm9tIFwiLi4vLi4vaGVscGVycy9jb25zdHMuanNcIjtcbmltcG9ydCB7IFN0ZXBPcENvZGUsIGpzb25FcnJvclNjaGVtYSB9IGZyb20gXCIuLi8uLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgSW5uZ2VzdEV4ZWN1dGlvbiB9IGZyb20gXCIuL0lubmdlc3RFeGVjdXRpb24uanNcIjtcbmltcG9ydCB7IE5vblJldHJpYWJsZUVycm9yIH0gZnJvbSBcIi4uL05vblJldHJpYWJsZUVycm9yLmpzXCI7XG5pbXBvcnQgeyBFcnJDb2RlLCBkZXNlcmlhbGl6ZUVycm9yLCBmdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyLCBwcmV0dHlFcnJvciwgc2VyaWFsaXplRXJyb3IgfSBmcm9tIFwiLi4vLi4vaGVscGVycy9lcnJvcnMuanNcIjtcbmltcG9ydCB7IHVuZGVmaW5lZFRvTnVsbCB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL2Z1bmN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgZ2V0SG9va1N0YWNrIH0gZnJvbSBcIi4uL0lubmdlc3RNaWRkbGV3YXJlLmpzXCI7XG5pbXBvcnQgeyByZXNvbHZlQWZ0ZXJQZW5kaW5nLCByZXNvbHZlTmV4dFRpY2ssIHJ1bkFzUHJvbWlzZSB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VzLmpzXCI7XG5pbXBvcnQgeyBSZXRyeUFmdGVyRXJyb3IgfSBmcm9tIFwiLi4vUmV0cnlBZnRlckVycm9yLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdGVwVG9vbHMsIGdldFN0ZXBPcHRpb25zIH0gZnJvbSBcIi4uL0lubmdlc3RTdGVwVG9vbHMuanNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kL3YzXCI7XG5pbXBvcnQgaGFzaGpzIGZyb20gXCJoYXNoLmpzXCI7XG5pbXBvcnQgY2Fub25pY2FsaXplIGZyb20gXCJjYW5vbmljYWxpemVcIjtcblxuLy8jcmVnaW9uIHNyYy9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC50c1xudmFyIHYwX2V4cG9ydHMgPSAvKiBAX19QVVJFX18gKi8gX19leHBvcnQoe1xuXHRWMElubmdlc3RFeGVjdXRpb246ICgpID0+IFYwSW5uZ2VzdEV4ZWN1dGlvbixcblx0X2ludGVybmFsczogKCkgPT4gX2ludGVybmFscyxcblx0Y3JlYXRlVjBJbm5nZXN0RXhlY3V0aW9uOiAoKSA9PiBjcmVhdGVWMElubmdlc3RFeGVjdXRpb25cbn0pO1xuY29uc3QgeyBzaGExIH0gPSBoYXNoanM7XG5jb25zdCBjcmVhdGVWMElubmdlc3RFeGVjdXRpb24gPSAob3B0aW9ucykgPT4ge1xuXHRyZXR1cm4gbmV3IFYwSW5uZ2VzdEV4ZWN1dGlvbihvcHRpb25zKTtcbn07XG52YXIgVjBJbm5nZXN0RXhlY3V0aW9uID0gY2xhc3MgZXh0ZW5kcyBJbm5nZXN0RXhlY3V0aW9uIHtcblx0dmVyc2lvbiA9IEV4ZWN1dGlvblZlcnNpb24uVjA7XG5cdHN0YXRlO1xuXHRleGVjdXRpb247XG5cdHVzZXJGblRvUnVuO1xuXHRmbkFyZztcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdHRoaXMudXNlckZuVG9SdW4gPSB0aGlzLmdldFVzZXJGblRvUnVuKCk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlRXhlY3V0aW9uU3RhdGUoKTtcblx0XHR0aGlzLmZuQXJnID0gdGhpcy5jcmVhdGVGbkFyZygpO1xuXHR9XG5cdHN0YXJ0KCkge1xuXHRcdHRoaXMuZGVidWcoXCJzdGFydGluZyBWMCBleGVjdXRpb25cIik7XG5cdFx0cmV0dXJuIHRoaXMuZXhlY3V0aW9uID8/PSB0aGlzLl9zdGFydCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuXHRcdFx0dGhpcy5kZWJ1ZyhcInJlc3VsdDpcIiwgcmVzdWx0KTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSk7XG5cdH1cblx0YXN5bmMgX3N0YXJ0KCkge1xuXHRcdHRoaXMuc3RhdGUuaG9va3MgPSBhd2FpdCB0aGlzLmluaXRpYWxpemVNaWRkbGV3YXJlKCk7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXMudHJhbnNmb3JtSW5wdXQoKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3MuYmVmb3JlTWVtb2l6YXRpb24/LigpO1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUub3BTdGFjay5sZW5ndGggPT09IDAgJiYgIXRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3MuYWZ0ZXJNZW1vaXphdGlvbj8uKCk7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3MuYmVmb3JlRXhlY3V0aW9uPy4oKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHVzZXJGblByb21pc2UgPSBydW5Bc1Byb21pc2UoKCkgPT4gdGhpcy51c2VyRm5Ub1J1bih0aGlzLmZuQXJnKSk7XG5cdFx0XHRsZXQgcG9zID0gLTE7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwb3MgPj0gMCkge1xuXHRcdFx0XHRcdGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAgJiYgcG9zID09PSB0aGlzLnN0YXRlLm9wU3RhY2subGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcy5hZnRlck1lbW9pemF0aW9uPy4oKTtcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3MuYmVmb3JlRXhlY3V0aW9uPy4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS50aWNrT3BzID0ge307XG5cdFx0XHRcdFx0Y29uc3QgaW5jb21pbmdPcCA9IHRoaXMuc3RhdGUub3BTdGFja1twb3NdO1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudE9wID0gdGhpcy5zdGF0ZS5hbGxGb3VuZE9wc1tpbmNvbWluZ09wLmlkXTtcblx0XHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUuY3VycmVudE9wKVxuIC8qKlxuXHRcdFx0XHRcdCogV2UncmUgdHJ5aW5nIHRvIHJlc3VtZSB0aGUgZnVuY3Rpb24sIGJ1dCB3ZSBjYW4ndCBmaW5kIHdoZXJlIHRvIGdvLlxuXHRcdFx0XHRcdCpcblx0XHRcdFx0XHQqIFRoaXMgbWVhbnMgdGhhdCBlaXRoZXIgdGhlIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkIG9yIHRoZXJlIGFyZSBhc3luY1xuXHRcdFx0XHRcdCogYWN0aW9ucyBpbi1iZXR3ZWVuIHN0ZXBzIHRoYXQgd2UgaGF2ZW4ndCBub3RpY2VkIGluIHByZXZpb3VzXG5cdFx0XHRcdFx0KiBleGVjdXRpb25zLlxuXHRcdFx0XHRcdCpcblx0XHRcdFx0XHQqIFdoaWNoZXZlciB0aGUgY2FzZSwgdGhpcyBpcyBiYWQgYW5kIHdlIGNhbid0IGNvbnRpbnVlIGluIHRoaXNcblx0XHRcdFx0XHQqIHVuZGVmaW5lZCBzdGF0ZS5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcihwcmV0dHlFcnJvcih7XG5cdFx0XHRcdFx0XHR3aGF0SGFwcGVuZWQ6IFwiIFlvdXIgZnVuY3Rpb24gd2FzIHN0b3BwZWQgZnJvbSBydW5uaW5nXCIsXG5cdFx0XHRcdFx0XHR3aHk6IFwiV2UgY291bGRuJ3QgcmVzdW1lIHlvdXIgZnVuY3Rpb24ncyBzdGF0ZSBiZWNhdXNlIGl0IG1heSBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIHJ1biBzdGFydGVkIG9yIHRoZXJlIGFyZSBhc3luYyBhY3Rpb25zIGluLWJldHdlZW4gc3RlcHMgdGhhdCB3ZSBoYXZlbid0IG5vdGljZWQgaW4gcHJldmlvdXMgZXhlY3V0aW9ucy5cIixcblx0XHRcdFx0XHRcdGNvbnNlcXVlbmNlczogXCJDb250aW51aW5nIHRvIHJ1biB0aGUgZnVuY3Rpb24gbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ciwgc28gd2UndmUgc3RvcHBlZCB5b3VyIGZ1bmN0aW9uIHRvIGVuc3VyZSBub3RoaW5nIHVuZXhwZWN0ZWQgaGFwcGVuZWQhXCIsXG5cdFx0XHRcdFx0XHR0b0ZpeE5vdzogXCJFbnN1cmUgdGhhdCB5b3VyIGZ1bmN0aW9uIGlzIGVpdGhlciBlbnRpcmVseSBzdGVwLWJhc2VkIG9yIGVudGlyZWx5IG5vbi1zdGVwLWJhc2VkLCBieSBlaXRoZXIgd3JhcHBpbmcgYWxsIGFzeW5jaHJvbm91cyBsb2dpYyBpbiBgc3RlcC5ydW4oKWAgY2FsbHMgb3IgYnkgcmVtb3ZpbmcgYWxsIGBzdGVwLiooKWAgY2FsbHMuXCIsXG5cdFx0XHRcdFx0XHRvdGhlcndpc2U6IFwiRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2h5IHN0ZXAgZnVuY3Rpb25zIHdvcmsgaW4gdGhpcyBtYW5uZXIsIHNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL2Z1bmN0aW9ucy9tdWx0aS1zdGVwI2dvdGNoYXNcIixcblx0XHRcdFx0XHRcdHN0YWNrOiB0cnVlLFxuXHRcdFx0XHRcdFx0Y29kZTogRXJyQ29kZS5OT05fREVURVJNSU5JU1RJQ19GVU5DVElPTlxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnRPcC5mdWxmaWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgaW5jb21pbmdPcC5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB0aGlzLnN0YXRlLmN1cnJlbnRPcC5yZXNvbHZlKGluY29taW5nT3AuZGF0YSk7XG5cdFx0XHRcdFx0ZWxzZSB0aGlzLnN0YXRlLmN1cnJlbnRPcC5yZWplY3QoaW5jb21pbmdPcC5lcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXdhaXQgcmVzb2x2ZUFmdGVyUGVuZGluZygpO1xuXHRcdFx0XHR0aGlzLnN0YXRlLnJlc2V0KCk7XG5cdFx0XHRcdHBvcysrO1xuXHRcdFx0fSB3aGlsZSAocG9zIDwgdGhpcy5zdGF0ZS5vcFN0YWNrLmxlbmd0aCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzLmFmdGVyTWVtb2l6YXRpb24/LigpO1xuXHRcdFx0Y29uc3QgZGlzY292ZXJlZE9wcyA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS50aWNrT3BzKS5tYXAodGlja09wVG9PdXRnb2luZyk7XG5cdFx0XHRjb25zdCBydW5TdGVwID0gdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAgfHwgdGhpcy5nZXRFYXJseUV4ZWNSdW5TdGVwKGRpc2NvdmVyZWRPcHMpO1xuXHRcdFx0aWYgKHJ1blN0ZXApIHtcblx0XHRcdFx0Y29uc3QgdXNlckZuT3AgPSB0aGlzLnN0YXRlLmFsbEZvdW5kT3BzW3J1blN0ZXBdO1xuXHRcdFx0XHRjb25zdCBzdGVwVG9SdW4gPSB1c2VyRm5PcD8uZm47XG5cdFx0XHRcdGlmICghc3RlcFRvUnVuKSB0aHJvdyBuZXcgRXJyb3IoYEJhZCBzdGFjazsgZXhlY3V0b3IgcmVxdWVzdGluZyB0byBydW4gdW5rbm93biBzdGVwIFwiJHtydW5TdGVwfVwiYCk7XG5cdFx0XHRcdGNvbnN0IG91dGdvaW5nVXNlckZuT3AgPSB7XG5cdFx0XHRcdFx0Li4udGlja09wVG9PdXRnb2luZyh1c2VyRm5PcCksXG5cdFx0XHRcdFx0b3A6IFN0ZXBPcENvZGUuU3RlcFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzLmJlZm9yZUV4ZWN1dGlvbj8uKCk7XG5cdFx0XHRcdHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCA9IHRydWU7XG5cdFx0XHRcdGNvbnN0IHsgdHlwZTogX3R5cGUsLi4ucmVzdCB9ID0gYXdhaXQgcnVuQXNQcm9taXNlKHN0ZXBUb1J1bikuZmluYWxseSgoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwID0gZmFsc2U7XG5cdFx0XHRcdH0pLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0sIG91dGdvaW5nVXNlckZuT3ApO1xuXHRcdFx0XHR9KS50aGVuKGFzeW5jIChkYXRhKSA9PiB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJFeGVjdXRpb24/LigpO1xuXHRcdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGEgfSwgb3V0Z29pbmdVc2VyRm5PcCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwic3RlcC1yYW5cIixcblx0XHRcdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRcdFx0b3BzOiB0aGlzLm9wcyxcblx0XHRcdFx0XHRzdGVwOiB7XG5cdFx0XHRcdFx0XHQuLi5vdXRnb2luZ1VzZXJGbk9wLFxuXHRcdFx0XHRcdFx0Li4ucmVzdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICghZGlzY292ZXJlZE9wcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29uc3QgZm5SZXQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3VzZXJGblByb21pc2UudGhlbigoZGF0YSkgPT4gKHtcblx0XHRcdFx0XHR0eXBlOiBcImNvbXBsZXRlXCIsXG5cdFx0XHRcdFx0ZGF0YVxuXHRcdFx0XHR9KSksIHJlc29sdmVOZXh0VGljaygpLnRoZW4oKCkgPT4gKHsgdHlwZTogXCJpbmNvbXBsZXRlXCIgfSkpXSk7XG5cdFx0XHRcdGlmIChmblJldC50eXBlID09PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzLmFmdGVyRXhlY3V0aW9uPy4oKTtcblx0XHRcdFx0XHRpZiAoT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5ldmVyeSgob3ApID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiBvcC5mdWxmaWxsZWQ7XG5cdFx0XHRcdFx0fSkpIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGE6IGZuUmV0LmRhdGEgfSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUuaGFzVXNlZFRvb2xzKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5ub25TdGVwRm5EZXRlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHVzZXJGblByb21pc2U7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcy5hZnRlckV4ZWN1dGlvbj8uKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZGF0YSB9KTtcblx0XHRcdFx0fSBlbHNlIGlmICghT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5zb21lKChvcCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBvcC5mdWxmaWxsZWQgPT09IGZhbHNlO1xuXHRcdFx0XHR9KSkgdGhyb3cgbmV3IE5vblJldHJpYWJsZUVycm9yKGZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIoRXJyQ29kZS5BU1lOQ19ERVRFQ1RFRF9BRlRFUl9NRU1PSVpBVElPTikpO1xuXHRcdFx0fVxuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcy5hZnRlckV4ZWN1dGlvbj8uKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG5cdFx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdFx0b3BzOiB0aGlzLm9wcyxcblx0XHRcdFx0c3RlcHM6IGRpc2NvdmVyZWRPcHNcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0pO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzLmJlZm9yZVJlc3BvbnNlPy4oKTtcblx0XHR9XG5cdH1cblx0YXN5bmMgaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKSB7XG5cdFx0Y29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG5cdFx0cmV0dXJuIGF3YWl0IGdldEhvb2tTdGFjayh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuXHRcdFx0Y3R4LFxuXHRcdFx0Zm46IHRoaXMub3B0aW9ucy5mbixcblx0XHRcdHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuXHRcdFx0cmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3Ncblx0XHR9LCB7XG5cdFx0XHR0cmFuc2Zvcm1JbnB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGN0eDoge1xuXHRcdFx0XHRcdFx0Li4ucHJldi5jdHgsXG5cdFx0XHRcdFx0XHQuLi5vdXRwdXQ/LmN0eFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Zm46IHRoaXMub3B0aW9ucy5mbixcblx0XHRcdFx0XHRzdGVwczogcHJldi5zdGVwcy5tYXAoKHN0ZXAsIGkpID0+ICh7XG5cdFx0XHRcdFx0XHQuLi5zdGVwLFxuXHRcdFx0XHRcdFx0Li4ub3V0cHV0Py5zdGVwcz8uW2ldXG5cdFx0XHRcdFx0fSkpLFxuXHRcdFx0XHRcdHJlcUFyZ3M6IHByZXYucmVxQXJnc1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHRyYW5zZm9ybU91dHB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHJlc3VsdDoge1xuXHRcdFx0XHRcdFx0Li4ucHJldi5yZXN1bHQsXG5cdFx0XHRcdFx0XHQuLi5vdXRwdXQ/LnJlc3VsdFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3RlcDogcHJldi5zdGVwXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblx0Y3JlYXRlRXhlY3V0aW9uU3RhdGUoKSB7XG5cdFx0Y29uc3Qgc3RhdGUgPSB7XG5cdFx0XHRhbGxGb3VuZE9wczoge30sXG5cdFx0XHR0aWNrT3BzOiB7fSxcblx0XHRcdHRpY2tPcEhhc2hlczoge30sXG5cdFx0XHRjdXJyZW50T3A6IHZvaWQgMCxcblx0XHRcdGhhc1VzZWRUb29sczogZmFsc2UsXG5cdFx0XHRyZXNldDogKCkgPT4ge1xuXHRcdFx0XHRzdGF0ZS50aWNrT3BIYXNoZXMgPSB7fTtcblx0XHRcdFx0c3RhdGUuYWxsRm91bmRPcHMgPSB7XG5cdFx0XHRcdFx0Li4uc3RhdGUuYWxsRm91bmRPcHMsXG5cdFx0XHRcdFx0Li4uc3RhdGUudGlja09wc1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdG5vblN0ZXBGbkRldGVjdGVkOiBmYWxzZSxcblx0XHRcdGV4ZWN1dGluZ1N0ZXA6IGZhbHNlLFxuXHRcdFx0b3BTdGFjazogdGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXIucmVkdWNlKChhY2MsIHN0ZXBJZCkgPT4ge1xuXHRcdFx0XHRjb25zdCBzdGVwU3RhdGUgPSB0aGlzLm9wdGlvbnMuc3RlcFN0YXRlW3N0ZXBJZF07XG5cdFx0XHRcdGlmICghc3RlcFN0YXRlKSByZXR1cm4gYWNjO1xuXHRcdFx0XHRyZXR1cm4gWy4uLmFjYywgc3RlcFN0YXRlXTtcblx0XHRcdH0sIFtdKVxuXHRcdH07XG5cdFx0cmV0dXJuIHN0YXRlO1xuXHR9XG5cdGdldCBvcHMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5tYXAoKFtpZCwgb3BdKSA9PiBbaWQsIHtcblx0XHRcdGlkOiBvcC5pZCxcblx0XHRcdHJhd0FyZ3M6IG9wLnJhd0FyZ3MsXG5cdFx0XHRkYXRhOiBvcC5kYXRhLFxuXHRcdFx0ZXJyb3I6IG9wLmVycm9yLFxuXHRcdFx0ZnVsZmlsbGVkOiBvcC5mdWxmaWxsZWQsXG5cdFx0XHRzZWVuOiB0cnVlXG5cdFx0fV0pKTtcblx0fVxuXHRnZXRVc2VyRm5Ub1J1bigpIHtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wiZm5cIl07XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXSlcbiAvKipcblx0XHQqIFNvbWVob3csIHdlJ3ZlIGVuZGVkIHVwIGRldGVjdGluZyB0aGF0IHRoaXMgaXMgYSBmYWlsdXJlIGhhbmRsZXIgYnV0XG5cdFx0KiBkb2Vzbid0IGhhdmUgYW4gYG9uRmFpbHVyZWAgZnVuY3Rpb24uIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cblx0XHQqL1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZ1bmN0aW9uIGBvbkZhaWx1cmVgIGhhbmRsZXJcIik7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5mbltcIm9uRmFpbHVyZUZuXCJdO1xuXHR9XG5cdGNyZWF0ZUZuQXJnKCkge1xuXHRcdHRoaXMuc3RhdGUudGlja09wcyA9IHRoaXMuc3RhdGUuYWxsRm91bmRPcHM7XG5cdFx0LyoqXG5cdFx0KiBDcmVhdGUgYSB1bmlxdWUgaGFzaCBvZiBhbiBvcGVyYXRpb24gdXNpbmcgb25seSBhIHN1YnNldCBvZiB0aGUgb3BlcmF0aW9uJ3Ncblx0XHQqIHByb3BlcnRpZXM7IHdpbGwgbmV2ZXIgdXNlIGBkYXRhYCBhbmQgd2lsbCBndWFyYW50ZWUgdGhlIG9yZGVyIG9mIHRoZVxuXHRcdCogb2JqZWN0IHNvIHdlIGRvbid0IHJlbHkgb24gaW5kaXZpZHVhbCB0b29scyBmb3IgdGhhdC5cblx0XHQqXG5cdFx0KiBJZiB0aGUgb3BlcmF0aW9uIGFscmVhZHkgY29udGFpbnMgYW4gSUQsIHRoZSBjdXJyZW50IElEIHdpbGwgYmUgdXNlZFxuXHRcdCogaW5zdGVhZCwgc28gdGhhdCB1c2VycyBjYW4gcHJvdmlkZSB0aGVpciBvd24gSURzLlxuXHRcdCovXG5cdFx0Y29uc3QgaGFzaE9wID0gKG9wKSA9PiB7XG5cdFx0XHQvKipcblx0XHRcdCogSXQncyBkaWZmaWN1bHQgZm9yIHYwIHRvIHVuZGVyc3RhbmQgd2hldGhlciBvciBub3QgYW4gb3AgaGFzXG5cdFx0XHQqIGhpc3RvcmljYWxseSBjb250YWluZWQgYSBjdXN0b20gSUQsIGFzIGFsbCBzdGVwIHVzYWdlIG5vdyByZXF1aXJlIHRoZW0uXG5cdFx0XHQqXG5cdFx0XHQqIEZvciB0aGlzIHJlYXNvbiwgd2UgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHN0ZXBzIGluIHYwIGRvIG5vdCBoYXZlIGFcblx0XHRcdCogY3VzdG9tIElEIGFuZCBnZW5lcmF0ZSBvbmUgZm9yIHRoZW0gYXMgd2Ugd291bGQgaW4gYWxsIHJlY29tbWVuZGF0aW9uc1xuXHRcdFx0KiBhbmQgZXhhbXBsZXMuXG5cdFx0XHQqL1xuXHRcdFx0Y29uc3Qgb2JqID0ge1xuXHRcdFx0XHRwYXJlbnQ6IHRoaXMuc3RhdGUuY3VycmVudE9wPy5pZCA/PyBudWxsLFxuXHRcdFx0XHRvcDogb3Aub3AsXG5cdFx0XHRcdG5hbWU6IG9wLm5hbWUsXG5cdFx0XHRcdG9wdHM6IG9wLm9wID09PSBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkID8gbnVsbCA6IG9wLm9wdHMgPz8gbnVsbFxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IGNvbGxpc2lvbkhhc2ggPSBfaW50ZXJuYWxzLmhhc2hEYXRhKG9iaik7XG5cdFx0XHRjb25zdCBwb3MgPSB0aGlzLnN0YXRlLnRpY2tPcEhhc2hlc1tjb2xsaXNpb25IYXNoXSA9ICh0aGlzLnN0YXRlLnRpY2tPcEhhc2hlc1tjb2xsaXNpb25IYXNoXSA/PyAtMSkgKyAxO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4ub3AsXG5cdFx0XHRcdGlkOiBfaW50ZXJuYWxzLmhhc2hEYXRhKHtcblx0XHRcdFx0XHRwb3MsXG5cdFx0XHRcdFx0Li4ub2JqXG5cdFx0XHRcdH0pXG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Y29uc3Qgc3RlcEhhbmRsZXIgPSAoeyBhcmdzLCBtYXRjaE9wLCBvcHRzIH0pID0+IHtcblx0XHRcdGlmICh0aGlzLnN0YXRlLm5vblN0ZXBGbkRldGVjdGVkKSB0aHJvdyBuZXcgTm9uUmV0cmlhYmxlRXJyb3IoZnVuY3Rpb25TdG9wcGVkUnVubmluZ0VycihFcnJDb2RlLlNURVBfVVNFRF9BRlRFUl9BU1lOQykpO1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCkgdGhyb3cgbmV3IE5vblJldHJpYWJsZUVycm9yKHByZXR0eUVycm9yKHtcblx0XHRcdFx0d2hhdEhhcHBlbmVkOiBcIllvdXIgZnVuY3Rpb24gd2FzIHN0b3BwZWQgZnJvbSBydW5uaW5nXCIsXG5cdFx0XHRcdHdoeTogXCJXZSBkZXRlY3RlZCB0aGF0IHlvdSBoYXZlIG5lc3RlZCBgc3RlcC4qYCB0b29saW5nLlwiLFxuXHRcdFx0XHRjb25zZXF1ZW5jZXM6IFwiTmVzdGluZyBgc3RlcC4qYCB0b29saW5nIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG5cdFx0XHRcdHN0YWNrOiB0cnVlLFxuXHRcdFx0XHR0b0ZpeE5vdzogXCJNYWtlIHN1cmUgeW91J3JlIG5vdCB1c2luZyBgc3RlcC4qYCB0b29saW5nIGluc2lkZSBvZiBvdGhlciBgc3RlcC4qYCB0b29saW5nLiBJZiB5b3UgbmVlZCB0byBjb21wb3NlIHN0ZXBzIHRvZ2V0aGVyLCB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBhc3luYyBmdW5jdGlvbiBhbmQgY2FsbCBpdCBmcm9tIHdpdGhpbiB5b3VyIHN0ZXAgZnVuY3Rpb24sIG9yIHVzZSBwcm9taXNlIGNoYWluaW5nLlwiLFxuXHRcdFx0XHRvdGhlcndpc2U6IFwiRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3RlcCBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LCBzZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9mdW5jdGlvbnMvbXVsdGktc3RlcFwiLFxuXHRcdFx0XHRjb2RlOiBFcnJDb2RlLk5FU1RJTkdfU1RFUFNcblx0XHRcdH0pKTtcblx0XHRcdHRoaXMuc3RhdGUuaGFzVXNlZFRvb2xzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IG9wSWQgPSBoYXNoT3AobWF0Y2hPcChnZXRTdGVwT3B0aW9ucyhhcmdzWzBdKSwgLi4uYXJncy5zbGljZSgxKSkpO1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0dGhpcy5zdGF0ZS50aWNrT3BzW29wSWQuaWRdID0ge1xuXHRcdFx0XHRcdC4uLm9wSWQsXG5cdFx0XHRcdFx0Li4ub3B0cz8uZm4gPyB7IGZuOiAoKSA9PiBvcHRzLmZuPy4oLi4uYXJncykgfSA6IHt9LFxuXHRcdFx0XHRcdHJhd0FyZ3M6IGFyZ3MsXG5cdFx0XHRcdFx0cmVzb2x2ZSxcblx0XHRcdFx0XHRyZWplY3QsXG5cdFx0XHRcdFx0ZnVsZmlsbGVkOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0XHRjb25zdCBzdGVwID0gY3JlYXRlU3RlcFRvb2xzKHRoaXMub3B0aW9ucy5jbGllbnQsIHRoaXMsIHN0ZXBIYW5kbGVyKTtcblx0XHRsZXQgZm5BcmcgPSB7XG5cdFx0XHQuLi50aGlzLm9wdGlvbnMuZGF0YSxcblx0XHRcdHN0ZXBcblx0XHR9O1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuXHRcdFx0Y29uc3QgZXZlbnREYXRhID0gei5vYmplY3QoeyBlcnJvcjoganNvbkVycm9yU2NoZW1hIH0pLnBhcnNlKGZuQXJnLmV2ZW50Py5kYXRhKTtcblx0XHRcdGZuQXJnID0ge1xuXHRcdFx0XHQuLi5mbkFyZyxcblx0XHRcdFx0ZXJyb3I6IGRlc2VyaWFsaXplRXJyb3IoZXZlbnREYXRhLmVycm9yKVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy50cmFuc2Zvcm1DdHg/LihmbkFyZykgPz8gZm5Bcmc7XG5cdH1cblx0LyoqXG5cdCogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGlucHV0IGJlZm9yZSBydW5uaW5nLlxuXHQqL1xuXHRhc3luYyB0cmFuc2Zvcm1JbnB1dCgpIHtcblx0XHRjb25zdCBpbnB1dE11dGF0aW9ucyA9IGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LnRyYW5zZm9ybUlucHV0Py4oe1xuXHRcdFx0Y3R4OiB7IC4uLnRoaXMuZm5BcmcgfSxcblx0XHRcdHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuXHRcdFx0Zm46IHRoaXMub3B0aW9ucy5mbixcblx0XHRcdHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzXG5cdFx0fSk7XG5cdFx0aWYgKGlucHV0TXV0YXRpb25zPy5jdHgpIHRoaXMuZm5BcmcgPSBpbnB1dE11dGF0aW9ucy5jdHg7XG5cdFx0aWYgKGlucHV0TXV0YXRpb25zPy5zdGVwcykgdGhpcy5zdGF0ZS5vcFN0YWNrID0gWy4uLmlucHV0TXV0YXRpb25zLnN0ZXBzXTtcblx0fVxuXHRnZXRFYXJseUV4ZWNSdW5TdGVwKG9wcykge1xuXHRcdGlmIChvcHMubGVuZ3RoICE9PSAxKSByZXR1cm47XG5cdFx0Y29uc3Qgb3AgPSBvcHNbMF07XG5cdFx0aWYgKG9wICYmIG9wLm9wID09PSBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkKSByZXR1cm4gb3AuaWQ7XG5cdH1cblx0LyoqXG5cdCogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIG91dHB1dCBiZWZvcmUgcmV0dXJuaW5nLlxuXHQqL1xuXHRhc3luYyB0cmFuc2Zvcm1PdXRwdXQoZGF0YU9yRXJyb3IsIHN0ZXApIHtcblx0XHRjb25zdCBvdXRwdXQgPSB7IC4uLmRhdGFPckVycm9yIH07XG5cdFx0aWYgKHR5cGVvZiBvdXRwdXQuZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIG91dHB1dC5kYXRhID0gc2VyaWFsaXplRXJyb3Iob3V0cHV0LmVycm9yKTtcblx0XHRjb25zdCB0cmFuc2Zvcm1lZE91dHB1dCA9IGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LnRyYW5zZm9ybU91dHB1dD8uKHtcblx0XHRcdHJlc3VsdDogeyAuLi5vdXRwdXQgfSxcblx0XHRcdHN0ZXBcblx0XHR9KTtcblx0XHRjb25zdCB7IGRhdGEsIGVycm9yIH0gPSB7XG5cdFx0XHQuLi5vdXRwdXQsXG5cdFx0XHQuLi50cmFuc2Zvcm1lZE91dHB1dD8ucmVzdWx0XG5cdFx0fTtcblx0XHRpZiAoIXN0ZXApIGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmZpbmlzaGVkPy4oeyByZXN1bHQ6IHsgLi4udHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiID8geyBlcnJvciB9IDogeyBkYXRhIH0gfSB9KTtcblx0XHRpZiAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHQvKipcblx0XHRcdCogRW5zdXJlIHdlIGdpdmUgbWlkZGxld2FyZSB0aGUgY2hhbmNlIHRvIGRlY2lkZSBvbiByZXRyaWFibGUgYmVoYXZpb3VyXG5cdFx0XHQqIGJ5IGxvb2tpbmcgYXQgdGhlIGVycm9yIHJldHVybmVkIGZyb20gb3V0cHV0IHRyYW5zZm9ybWF0aW9uLlxuXHRcdFx0Ki9cblx0XHRcdGxldCByZXRyaWFibGUgPSAhKGVycm9yIGluc3RhbmNlb2YgTm9uUmV0cmlhYmxlRXJyb3IpO1xuXHRcdFx0aWYgKHJldHJpYWJsZSAmJiBlcnJvciBpbnN0YW5jZW9mIFJldHJ5QWZ0ZXJFcnJvcikgcmV0cmlhYmxlID0gZXJyb3IucmV0cnlBZnRlcjtcblx0XHRcdGNvbnN0IHNlcmlhbGl6ZWRFcnJvciA9IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIixcblx0XHRcdFx0Y3R4OiB0aGlzLmZuQXJnLFxuXHRcdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0XHRlcnJvcjogc2VyaWFsaXplZEVycm9yLFxuXHRcdFx0XHRyZXRyaWFibGVcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsXG5cdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0ZGF0YTogdW5kZWZpbmVkVG9OdWxsKGRhdGEpXG5cdFx0fTtcblx0fVxufTtcbmNvbnN0IHRpY2tPcFRvT3V0Z29pbmcgPSAob3ApID0+IHtcblx0cmV0dXJuIHtcblx0XHRvcDogb3Aub3AsXG5cdFx0aWQ6IG9wLmlkLFxuXHRcdG5hbWU6IG9wLm5hbWUsXG5cdFx0b3B0czogb3Aub3B0c1xuXHR9O1xufTtcbmNvbnN0IGhhc2hEYXRhID0gKG9wKSA9PiB7XG5cdHJldHVybiBzaGExKCkudXBkYXRlKGNhbm9uaWNhbGl6ZShvcCkpLmRpZ2VzdChcImhleFwiKTtcbn07XG4vKipcbiogRXhwb3J0ZWQgZm9yIHRlc3RpbmcuXG4qL1xuY29uc3QgX2ludGVybmFscyA9IHsgaGFzaERhdGEgfTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBjcmVhdGVWMElubmdlc3RFeGVjdXRpb24sIHYwX2V4cG9ydHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXYwLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4cG9ydCIsIkV4ZWN1dGlvblZlcnNpb24iLCJTdGVwT3BDb2RlIiwianNvbkVycm9yU2NoZW1hIiwiSW5uZ2VzdEV4ZWN1dGlvbiIsIk5vblJldHJpYWJsZUVycm9yIiwiRXJyQ29kZSIsImRlc2VyaWFsaXplRXJyb3IiLCJmdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyIiwicHJldHR5RXJyb3IiLCJzZXJpYWxpemVFcnJvciIsInVuZGVmaW5lZFRvTnVsbCIsImdldEhvb2tTdGFjayIsInJlc29sdmVBZnRlclBlbmRpbmciLCJyZXNvbHZlTmV4dFRpY2siLCJydW5Bc1Byb21pc2UiLCJSZXRyeUFmdGVyRXJyb3IiLCJjcmVhdGVTdGVwVG9vbHMiLCJnZXRTdGVwT3B0aW9ucyIsInoiLCJoYXNoanMiLCJjYW5vbmljYWxpemUiLCJ2MF9leHBvcnRzIiwiVjBJbm5nZXN0RXhlY3V0aW9uIiwiX2ludGVybmFscyIsImNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbiIsInNoYTEiLCJvcHRpb25zIiwiY29uc3RydWN0b3IiLCJ2ZXJzaW9uIiwiVjAiLCJ1c2VyRm5Ub1J1biIsImdldFVzZXJGblRvUnVuIiwic3RhdGUiLCJjcmVhdGVFeGVjdXRpb25TdGF0ZSIsImZuQXJnIiwiY3JlYXRlRm5BcmciLCJzdGFydCIsImRlYnVnIiwiZXhlY3V0aW9uIiwiX3N0YXJ0IiwidGhlbiIsInJlc3VsdCIsImhvb2tzIiwiaW5pdGlhbGl6ZU1pZGRsZXdhcmUiLCJ0cmFuc2Zvcm1JbnB1dCIsImJlZm9yZU1lbW9pemF0aW9uIiwib3BTdGFjayIsImxlbmd0aCIsInJlcXVlc3RlZFJ1blN0ZXAiLCJhZnRlck1lbW9pemF0aW9uIiwiYmVmb3JlRXhlY3V0aW9uIiwidXNlckZuUHJvbWlzZSIsInBvcyIsInRpY2tPcHMiLCJpbmNvbWluZ09wIiwiY3VycmVudE9wIiwiYWxsRm91bmRPcHMiLCJpZCIsIndoYXRIYXBwZW5lZCIsIndoeSIsImNvbnNlcXVlbmNlcyIsInRvRml4Tm93Iiwib3RoZXJ3aXNlIiwic3RhY2siLCJjb2RlIiwiTk9OX0RFVEVSTUlOSVNUSUNfRlVOQ1RJT04iLCJmdWxmaWxsZWQiLCJkYXRhIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yIiwicmVzZXQiLCJkaXNjb3ZlcmVkT3BzIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwidGlja09wVG9PdXRnb2luZyIsInJ1blN0ZXAiLCJnZXRFYXJseUV4ZWNSdW5TdGVwIiwidXNlckZuT3AiLCJzdGVwVG9SdW4iLCJmbiIsIkVycm9yIiwib3V0Z29pbmdVc2VyRm5PcCIsIm9wIiwiU3RlcCIsImV4ZWN1dGluZ1N0ZXAiLCJ0eXBlIiwiX3R5cGUiLCJyZXN0IiwiZmluYWxseSIsImNhdGNoIiwidHJhbnNmb3JtT3V0cHV0IiwiYWZ0ZXJFeGVjdXRpb24iLCJjdHgiLCJvcHMiLCJzdGVwIiwiZm5SZXQiLCJQcm9taXNlIiwicmFjZSIsImV2ZXJ5IiwiaGFzVXNlZFRvb2xzIiwibm9uU3RlcEZuRGV0ZWN0ZWQiLCJzb21lIiwiQVNZTkNfREVURUNURURfQUZURVJfTUVNT0laQVRJT04iLCJzdGVwcyIsImJlZm9yZVJlc3BvbnNlIiwic3RlcFN0YXRlIiwicmVxQXJncyIsInByZXYiLCJvdXRwdXQiLCJpIiwidGlja09wSGFzaGVzIiwic3RlcENvbXBsZXRpb25PcmRlciIsInJlZHVjZSIsImFjYyIsInN0ZXBJZCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsInJhd0FyZ3MiLCJzZWVuIiwiaXNGYWlsdXJlSGFuZGxlciIsImhhc2hPcCIsIm9iaiIsInBhcmVudCIsIm5hbWUiLCJvcHRzIiwiU3RlcFBsYW5uZWQiLCJjb2xsaXNpb25IYXNoIiwiaGFzaERhdGEiLCJzdGVwSGFuZGxlciIsImFyZ3MiLCJtYXRjaE9wIiwiU1RFUF9VU0VEX0FGVEVSX0FTWU5DIiwiTkVTVElOR19TVEVQUyIsIm9wSWQiLCJzbGljZSIsImNsaWVudCIsImV2ZW50RGF0YSIsIm9iamVjdCIsInBhcnNlIiwiZXZlbnQiLCJ0cmFuc2Zvcm1DdHgiLCJpbnB1dE11dGF0aW9ucyIsImRhdGFPckVycm9yIiwidHJhbnNmb3JtZWRPdXRwdXQiLCJmaW5pc2hlZCIsInJldHJpYWJsZSIsInJldHJ5QWZ0ZXIiLCJzZXJpYWxpemVkRXJyb3IiLCJ1cGRhdGUiLCJkaWdlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v0.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v1.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _internals: () => (/* binding */ _internals),\n/* harmony export */   createV1InngestExecution: () => (/* binding */ createV1InngestExecution),\n/* harmony export */   v1_exports: () => (/* binding */ v1_exports)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _als_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _InngestExecution_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/* harmony import */ var _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var _helpers_functions_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/* harmony import */ var _InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/* harmony import */ var _otel_access_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\n/* harmony import */ var _helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/* harmony import */ var _RetryAfterError_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\n/* harmony import */ var _StepError_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\n/* harmony import */ var _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//#region src/components/execution/v1.ts\nvar v1_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_2__.__export)({\n    _internals: ()=>_internals,\n    createV1InngestExecution: ()=>createV1InngestExecution\n});\nconst { sha1 } = hash_js__WEBPACK_IMPORTED_MODULE_1__;\nconst createV1InngestExecution = (options)=>{\n    return new V1InngestExecution(options);\n};\nvar V1InngestExecution = class extends _InngestExecution_js__WEBPACK_IMPORTED_MODULE_3__.InngestExecution {\n    constructor(options){\n        super(options);\n        this.version = _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V1;\n        this.timeoutDuration = 1e3 * 10;\n        /**\n\t\t* Check we have everything we need for checkpointing\n\t\t*/ if (this.options.stepMode === _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Sync) {\n            if (!this.options.createResponse) throw new Error(\"createResponse is required for sync step mode\");\n        }\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.options.stepMode === _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Sync ? this.createCheckpointingCheckpointHandlers() : this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V1 execution for run;\", this.options.requestedRunStep ? `wanting to run step \"${this.options.requestedRunStep}\"` : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n\t* Idempotently start the execution of the user's function.\n\t*/ start() {\n        if (!this.execution) {\n            this.debug(\"starting V1 execution\");\n            const tracer = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.trace.getTracer(\"inngest\", _version_js__WEBPACK_IMPORTED_MODULE_6__.version);\n            this.execution = (0,_als_js__WEBPACK_IMPORTED_MODULE_7__.getAsyncLocalStorage)().then((als)=>{\n                return als.run({\n                    app: this.options.client,\n                    execution: {\n                        ctx: this.fnArg,\n                        instance: this\n                    }\n                }, async ()=>{\n                    return tracer.startActiveSpan(\"inngest.execution\", (span)=>{\n                        _otel_access_js__WEBPACK_IMPORTED_MODULE_8__.clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.TraceParent],\n                            tracestate: this.options.headers[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.TraceState]\n                        });\n                        return this._start().then((result)=>{\n                            this.debug(\"result:\", result);\n                            return result;\n                        }).finally(()=>{\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n\t* Starts execution of the user's function and the core loop.\n\t*/ async _start() {\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            let i = 0;\n            for await (const checkpoint of this.state.loop){\n                await allCheckpointHandler(checkpoint, i);\n                const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint, i++);\n                if (result) return result;\n            }\n        } catch (error) {\n            return await this.transformOutput({\n                error\n            });\n        } finally{\n            this.state.loop.return();\n            await this.state.hooks?.beforeResponse?.();\n        }\n        /**\n\t\t* If we're here, the generator somehow finished without returning a value.\n\t\t* This should never happen.\n\t\t*/ throw new Error(\"Core loop finished without returning a value\");\n    }\n    async checkpoint(steps) {\n        if (!this.state.checkpointedRun) {\n            const res = await this.options.client[\"inngestApi\"].checkpointNewRun({\n                runId: this.fnArg.runId,\n                event: this.fnArg.event,\n                steps\n            });\n            this.state.checkpointedRun = {\n                appId: res.data.app_id,\n                fnId: res.data.fn_id,\n                token: res.data.token\n            };\n        } else await this.options.client[\"inngestApi\"].checkpointSteps({\n            appId: this.state.checkpointedRun.appId,\n            fnId: this.state.checkpointedRun.fnId,\n            runId: this.fnArg.runId,\n            steps\n        });\n    }\n    async checkpointAndSwitchToAsync(steps) {\n        await this.checkpoint(steps);\n        if (!this.state.checkpointedRun?.token) throw new Error(\"Failed to checkpoint and switch to async mode\");\n        return {\n            type: \"change-mode\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            to: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Async,\n            token: this.state.checkpointedRun?.token\n        };\n    }\n    /**\n\t* Returns whether we're in the final attempt of execution, or `null` if we\n\t* can't determine this in the SDK.\n\t*/ inFinalAttempt() {\n        if (typeof this.fnArg.maxAttempts !== \"number\") return null;\n        return this.fnArg.attempt + 1 >= this.fnArg.maxAttempts;\n    }\n    createCheckpointingCheckpointHandlers() {\n        return {\n            \"\": async (checkpoint, i)=>{\n                this.debug(\"sync checkpoint:\", checkpoint);\n            },\n            \"function-resolved\": async (checkpoint, i)=>{\n                await this.checkpoint([\n                    {\n                        op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.RunComplete,\n                        id: _internals.hashId(\"complete\"),\n                        data: await this.options.createResponse(checkpoint.data)\n                    }\n                ]);\n                return {\n                    type: \"function-resolved\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    data: checkpoint.data\n                };\n            },\n            \"function-rejected\": (checkpoint)=>{\n                if (this.inFinalAttempt()) return {\n                    type: \"function-rejected\",\n                    ctx: this.fnArg,\n                    error: checkpoint.error,\n                    ops: this.ops,\n                    retriable: false\n                };\n                return this.checkpointAndSwitchToAsync([\n                    {\n                        id: _internals.hashId(\"complete\"),\n                        displayName: \"complete\",\n                        op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepError,\n                        error: checkpoint.error\n                    }\n                ]);\n            },\n            \"step-not-found\": ({ step })=>{\n                return {\n                    type: \"function-rejected\",\n                    ctx: this.fnArg,\n                    error: /* @__PURE__ */ new Error(\"Step not found when checkpointing; this should never happen\"),\n                    ops: this.ops,\n                    retriable: false\n                };\n            },\n            \"steps-found\": async ({ steps })=>{\n                if (steps.length !== 1 || steps[0].mode !== _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Sync) return this.checkpointAndSwitchToAsync(steps.map((step$1)=>({\n                        ...step$1,\n                        id: step$1.hashedId\n                    })));\n                const step = this.state.steps.get(steps[0].id);\n                if (!step) throw new Error(\"Step not found in memoization state; this should never happen and is a bug in the Inngest SDK\");\n                const start = Date.now();\n                const result = await this.executeStep(step);\n                const interval = {\n                    a: start * 1e6,\n                    b: (Date.now() - start) * 1e6\n                };\n                if (result.error) {\n                    await this.checkpoint([\n                        {\n                            ...step,\n                            op: step.op === _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepPlanned ? _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepError : step.op,\n                            error: result.error\n                        }\n                    ]);\n                    if (!this.state.checkpointedRun?.token) throw new Error(\"Failed to checkpoint and switch to async mode as no token was returned from the API\");\n                    return {\n                        type: \"change-mode\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        to: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepMode.Async,\n                        token: this.state.checkpointedRun.token\n                    };\n                }\n                if (\"data\" in result) {\n                    step.data = result.data;\n                    this.state.stepState[steps[0].hashedId] = step;\n                    step.fulfilled = true;\n                    await this.checkpoint([\n                        {\n                            id: step.hashedId,\n                            data: step.data,\n                            op: step.op === _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepPlanned ? _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepRun : step.op,\n                            displayName: step.displayName,\n                            opts: step.opts,\n                            userland: step.userland,\n                            name: step.name,\n                            timing: interval\n                        }\n                    ]);\n                    step.handle();\n                    return;\n                }\n                throw new Error(\"A step was run and had no data or error; this is a bug in the Inngest SDK\");\n            }\n        };\n    }\n    /**\n\t* Creates a handler for every checkpoint type, defining what to do when we\n\t* reach that checkpoint in the core loop.\n\t*/ createCheckpointHandlers() {\n        return {\n            \"\": (checkpoint)=>{\n                this.debug(\"async checkpoint:\", checkpoint);\n            },\n            \"function-resolved\": async ({ data })=>{\n                if (this.options.createResponse) data = await this.options.createResponse(data);\n                return await this.transformOutput({\n                    data\n                });\n            },\n            \"function-rejected\": async (checkpoint)=>{\n                return await this.transformOutput({\n                    error: checkpoint.error\n                });\n            },\n            \"steps-found\": async ({ steps })=>{\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n\t\t\t\t\t* Transforming output will always return either function rejection or\n\t\t\t\t\t* resolution. In most cases, this can be immediately returned, but in\n\t\t\t\t\t* this particular case we want to handle it differently.\n\t\t\t\t\t*/ if (transformResult.type === \"function-resolved\") return {\n                        type: \"step-ran\",\n                        ctx: transformResult.ctx,\n                        ops: transformResult.ops,\n                        step: _internals.hashOp({\n                            ...stepResult,\n                            data: transformResult.data\n                        })\n                    };\n                    else if (transformResult.type === \"function-rejected\") {\n                        const stepForResponse = _internals.hashOp({\n                            ...stepResult,\n                            error: transformResult.error\n                        });\n                        if (stepResult.op === _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepFailed) {\n                            const ser = (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.serializeError)(transformResult.error);\n                            stepForResponse.data = {\n                                __serialized: true,\n                                name: ser.name,\n                                message: ser.message,\n                                stack: \"\"\n                            };\n                        }\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            retriable: transformResult.retriable,\n                            step: stepForResponse\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) return {\n                    type: \"steps-found\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    steps: newSteps\n                };\n            },\n            \"step-not-found\": ({ step })=>{\n                return {\n                    type: \"step-not-found\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    step\n                };\n            }\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) return;\n        const step = steps.find((step$1)=>step$1.hashedId === hashedStepIdToRun && step$1.fn);\n        if (step) return await this.executeStep(step);\n        this.timeout?.reset();\n    }\n    /**\n\t* Given a list of outgoing ops, decide if we can execute an op early and\n\t* return the ID of the step to execute if we can.\n\t*/ getEarlyExecRunStep(steps) {\n        /**\n\t\t* We may have been disabled due to parallelism, in which case we can't\n\t\t* immediately execute unless explicitly requested.\n\t\t*/ if (this.options.disableImmediateExecution) return;\n        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);\n        if (unfulfilledSteps.length !== 1) return;\n        const op = unfulfilledSteps[0];\n        if (op && op.op === _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepPlanned) return op.hashedId;\n    }\n    async filterNewSteps(foundSteps) {\n        if (this.options.requestedRunStep) return;\n        /**\n\t\t* Gather any steps that aren't memoized and report them.\n\t\t*/ const newSteps = foundSteps.filter((step)=>!step.fulfilled);\n        if (!newSteps.length) return;\n        /**\n\t\t* Warn if we've found new steps but haven't yet seen all previous\n\t\t* steps. This may indicate that step presence isn't determinate.\n\t\t*/ let knownSteps = 0;\n        for (const step of foundSteps)if (step.fulfilled) knownSteps++;\n        if (!(this.state.stepsToFulfill === knownSteps)) console.warn((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyError)({\n            type: \"warn\",\n            whatHappened: \"Function may be indeterminate\",\n            why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n            consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n            reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\"\n        }));\n        /**\n\t\t* We're finishing up; let's trigger the last of the hooks.\n\t\t*/ await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n        const stepList = newSteps.map((step)=>({\n                displayName: step.displayName,\n                op: step.op,\n                id: step.hashedId,\n                name: step.name,\n                opts: step.opts,\n                userland: step.userland\n            }));\n        /**\n\t\t* We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n\t\t* to ensure that their `data` is transformed correctly.\n\t\t*/ return await this.transformNewSteps(stepList);\n    }\n    /**\n\t* Using middleware, transform any newly-found steps before returning them to\n\t* an Inngest Server.\n\t*/ async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step)=>{\n            if (step.op !== _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.InvokeFunction) return step;\n            /**\n\t\t\t* For each event being sent, create a new `onSendEvent` hook stack to\n\t\t\t* process it. We do this as middleware hooks are intended to run once\n\t\t\t* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n\t\t\t* is run for every single event.\n\t\t\t*\n\t\t\t* This is done because a developer can use this hook to filter out\n\t\t\t* events entirely; if we batch all of the events together, we can't\n\t\t\t* tell which ones were filtered out if we're processing >1 invocation\n\t\t\t* here.\n\t\t\t*/ const transformedPayload = await (await (0,_InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_10__.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", void 0, {\n                transformInput: (prev, output)=>{\n                    return {\n                        ...prev,\n                        ...output\n                    };\n                },\n                transformOutput: (prev, output)=>{\n                    return {\n                        result: {\n                            ...prev.result,\n                            ...output?.result\n                        }\n                    };\n                }\n            })).transformInput?.({\n                payloads: [\n                    {\n                        ...step.opts?.payload ?? {},\n                        name: _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.internalEvents.FunctionInvoked\n                    }\n                ]\n            });\n            const newPayload = _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.invokePayloadSchema.parse(transformedPayload?.payloads?.[0] ?? {});\n            return {\n                ...step,\n                opts: {\n                    ...step.opts,\n                    payload: {\n                        ...step.opts?.payload ?? {},\n                        ...newPayload\n                    }\n                }\n            };\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, userland }) {\n        this.timeout?.clear();\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        const outgoingOp = {\n            id,\n            op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n            userland\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0,_als_js__WEBPACK_IMPORTED_MODULE_7__.getAsyncCtx)();\n        if (store?.execution) store.execution.executingStep = {\n            id,\n            name: displayName\n        };\n        this.debug(`executing step \"${id}\"`);\n        return (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.runAsPromise)(fn).finally(async ()=>{\n            delete this.state.executingStep;\n            if (store?.execution) delete store.execution.executingStep;\n            await this.state.hooks?.afterExecution?.();\n        }).then((data)=>{\n            return {\n                ...outgoingOp,\n                data\n            };\n        }).catch((error)=>{\n            let errorIsRetriable = true;\n            if (error instanceof _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_13__.NonRetriableError) errorIsRetriable = false;\n            else if (this.fnArg.maxAttempts && this.fnArg?.maxAttempts - 1 === this.fnArg.attempt) errorIsRetriable = false;\n            if (errorIsRetriable) return {\n                ...outgoingOp,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepError,\n                error\n            };\n            else return {\n                ...outgoingOp,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepFailed,\n                error\n            };\n        });\n    }\n    /**\n\t* Starts execution of the user's function, including triggering checkpoints\n\t* and middleware hooks where appropriate.\n\t*/ async startExecution() {\n        /**\n\t\t* Mutate input as neccessary based on middleware.\n\t\t*/ await this.transformInput();\n        /**\n\t\t* Start the timer to time out the run if needed.\n\t\t*/ this.timeout?.start();\n        await this.state.hooks?.beforeMemoization?.();\n        /**\n\t\t* If we had no state to begin with, immediately end the memoization phase.\n\t\t*/ if (this.state.allStateUsed()) {\n            await this.state.hooks?.afterMemoization?.();\n            await this.state.hooks?.beforeExecution?.();\n        }\n        /**\n\t\t* Trigger the user's function.\n\t\t*/ (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.runAsPromise)(()=>this.userFnToRun(this.fnArg)).finally(async ()=>{\n            await this.state.hooks?.afterMemoization?.();\n            await this.state.hooks?.beforeExecution?.();\n            await this.state.hooks?.afterExecution?.();\n        }).then((data)=>{\n            this.state.setCheckpoint({\n                type: \"function-resolved\",\n                data\n            });\n        }).catch((error)=>{\n            this.state.setCheckpoint({\n                type: \"function-rejected\",\n                error\n            });\n        });\n    }\n    /**\n\t* Using middleware, transform input before running.\n\t*/ async transformInput() {\n        const inputMutations = await this.state.hooks?.transformInput?.({\n            ctx: {\n                ...this.fnArg\n            },\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs\n        });\n        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;\n        if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[\n                step.id,\n                step\n            ]));\n    }\n    /**\n\t* Using middleware, transform output before returning.\n\t*/ async transformOutput(dataOrError) {\n        const output = {\n            ...dataOrError\n        };\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await this.state.hooks?.transformOutput?.({\n            result: {\n                ...output\n            },\n            step: this.state.executingStep\n        });\n        const { data, error } = {\n            ...output,\n            ...transformedOutput?.result\n        };\n        if (!isStepExecution) await this.state.hooks?.finished?.({\n            result: {\n                ...typeof error !== \"undefined\" ? {\n                    error\n                } : {\n                    data\n                }\n            }\n        });\n        if (typeof error !== \"undefined\") {\n            /**\n\t\t\t* Ensure we give middleware the chance to decide on retriable behaviour\n\t\t\t* by looking at the error returned from output transformation.\n\t\t\t*/ let retriable = !(error instanceof _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_13__.NonRetriableError || error instanceof _StepError_js__WEBPACK_IMPORTED_MODULE_14__.StepError && error === this.state.recentlyRejectedStepError);\n            if (retriable && error instanceof _RetryAfterError_js__WEBPACK_IMPORTED_MODULE_15__.RetryAfterError) retriable = error.retryAfter;\n            const serializedError = (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.minifyPrettyError)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_16__.undefinedToNull)(data)\n        };\n    }\n    createExecutionState() {\n        const d = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = async function*(cleanUp) {\n            try {\n                while(true){\n                    const res = (await checkpointResults.next()).value;\n                    if (res) yield res;\n                }\n            } finally{\n                cleanUp?.();\n            }\n        }(()=>{\n            this.timeout?.clear();\n            checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        return {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: /* @__PURE__ */ new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [\n                ...this.options.stepCompletionOrder\n            ],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint)=>{\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: ()=>{\n                return this.state.remainingStepsToBeSeen.size === 0;\n            }\n        };\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        const step = this.createStepTools();\n        let fnArg = {\n            ...this.options.data,\n            step\n        };\n        /**\n\t\t* Handle use of the `onFailure` option by deserializing the error.\n\t\t*/ if (this.options.isFailureHandler) {\n            const eventData = zod_v3__WEBPACK_IMPORTED_MODULE_17__.object({\n                error: _types_js__WEBPACK_IMPORTED_MODULE_5__.jsonErrorSchema\n            }).parse(fnArg.event?.data);\n            fnArg = {\n                ...fnArg,\n                error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.deserializeError)(eventData.error)\n            };\n        }\n        return this.options.transformCtx?.(fnArg) ?? fnArg;\n    }\n    createStepTools() {\n        /**\n\t\t* A list of steps that have been found and are being rolled up before being\n\t\t* reported to the core loop.\n\t\t*/ const foundStepsToReport = /* @__PURE__ */ new Map();\n        /**\n\t\t* A map of the subset of found steps to report that have not yet been\n\t\t* handled. Used for fast access to steps that need to be handled in order.\n\t\t*/ const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();\n        /**\n\t\t* A map of the latest sequential step indexes found for each step ID. Used\n\t\t* to ensure that we don't index steps in parallel.\n\t\t*\n\t\t* Note that these must be sequential; if we've seen or assigned `a:1`,\n\t\t* `a:2` and `a:4`, the latest sequential step index is `2`.\n\t\t*\n\t\t*/ const expectedNextStepIndexes = /* @__PURE__ */ new Map();\n        /**\n\t\t* An ordered list of step IDs that have yet to be handled in this\n\t\t* execution. Used to ensure that we handle steps in the order they were\n\t\t* found and based on the `stepCompletionOrder` in this execution's state.\n\t\t*/ const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();\n        /**\n\t\t* A promise that's used to ensure that step reporting cannot be run more than\n\t\t* once in a given asynchronous time span.\n\t\t*/ let foundStepsReportPromise;\n        /**\n\t\t* A promise that's used to represent middleware hooks running before\n\t\t* execution.\n\t\t*/ let beforeExecHooksPromise;\n        /**\n\t\t* A flag used to ensure that we only warn about parallel indexing once per\n\t\t* execution to avoid spamming the console.\n\t\t*/ let warnOfParallelIndexing = false;\n        /**\n\t\t* Counts the number of times we've extended this tick.\n\t\t*/ let tickExtensionCount = 0;\n        /**\n\t\t* Given a colliding step ID, maybe warn the user about parallel indexing.\n\t\t*/ const maybeWarnOfParallelIndexing = (collisionId)=>{\n            if (warnOfParallelIndexing) return;\n            if (this.state.steps.has(collisionId)) {\n                if (!foundStepsToReport.has(collisionId)) {\n                    warnOfParallelIndexing = true;\n                    console.warn((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyError)({\n                        type: \"warn\",\n                        whatHappened: \"We detected that you have multiple steps with the same ID.\",\n                        code: _helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${collisionId}\".`,\n                        reassurance: \"Your function is still running, though it may exhibit unexpected behaviour.\",\n                        consequences: \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n                        toFixNow: \"We recommend using a unique ID for each step, especially those happening in parallel.\"\n                    }));\n                }\n            }\n        };\n        /**\n\t\t* A helper used to report steps to the core loop. Used after adding an item\n\t\t* to `foundStepsToReport`.\n\t\t*/ const reportNextTick = ()=>{\n            if (foundStepsReportPromise) return;\n            let extensionPromise;\n            if (++tickExtensionCount >= 10) {\n                tickExtensionCount = 0;\n                extensionPromise = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.resolveNextTick)();\n            } else extensionPromise = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.resolveAfterPending)();\n            foundStepsReportPromise = extensionPromise.then(()=>beforeExecHooksPromise).then(()=>{\n                foundStepsReportPromise = void 0;\n                for(let i = 0; i < remainingStepCompletionOrder.length; i++){\n                    const nextStepId = remainingStepCompletionOrder[i];\n                    if (!nextStepId) continue;\n                    if (unhandledFoundStepsToReport.get(nextStepId)?.handle()) {\n                        remainingStepCompletionOrder.splice(i, 1);\n                        unhandledFoundStepsToReport.delete(nextStepId);\n                        reportNextTick();\n                        return;\n                    }\n                }\n                const steps = [\n                    ...foundStepsToReport.values()\n                ];\n                foundStepsToReport.clear();\n                unhandledFoundStepsToReport.clear();\n                this.state.setCheckpoint({\n                    type: \"steps-found\",\n                    steps\n                });\n            });\n        };\n        /**\n\t\t* A helper used to push a step to the list of steps to report.\n\t\t*/ const pushStepToReport = (step)=>{\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts })=>{\n            await beforeExecHooksPromise;\n            const opId = matchOp((0,_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.getStepOptions)(args[0]), ...args.slice(1));\n            if (this.state.executingStep) /**\n\t\t\t* If a step is found after asynchronous actions during another step's\n\t\t\t* execution, everything is fine. The problem here is if we've found\n\t\t\t* that a step nested inside another a step, which is something we don't\n\t\t\t* support at the time of writing.\n\t\t\t*\n\t\t\t* In this case, we could use something like Async Hooks to understand\n\t\t\t* how the step is being triggered, though this isn't available in all\n\t\t\t* environments.\n\t\t\t*\n\t\t\t* Therefore, we'll only show a warning here to indicate that this is\n\t\t\t* potentially an issue.\n\t\t\t*/ console.warn((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyError)({\n                whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${opId.displayName ?? opId.id}\\``,\n                consequences: \"Nesting `step.*` tooling is not supported.\",\n                type: \"warn\",\n                reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                stack: true,\n                toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                code: _helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.ErrCode.NESTING_STEPS\n            }));\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                maybeWarnOfParallelIndexing(originalId);\n                const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n                for(let i = expectedNextIndex;; i++){\n                    const newId = originalId + _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        opId.userland.index = i;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.createDeferredPromise)();\n            const hashedId = _internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") isFulfilled = true;\n            }\n            let extraOpts;\n            let fnArgs = [\n                ...args\n            ];\n            if (typeof stepState?.input !== \"undefined\" && Array.isArray(stepState.input)) switch(opId.op){\n                case _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepPlanned:\n                    fnArgs = [\n                        ...args.slice(0, 2),\n                        ...stepState.input\n                    ];\n                    extraOpts = {\n                        input: [\n                            ...stepState.input\n                        ]\n                    };\n                    break;\n                case _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.AiGateway:\n                    extraOpts = {\n                        body: {\n                            ...typeof opId.opts?.body === \"object\" ? {\n                                ...opId.opts.body\n                            } : {},\n                            ...stepState.input[0]\n                        }\n                    };\n                    break;\n            }\n            const step = {\n                ...opId,\n                opts: {\n                    ...opId.opts,\n                    ...extraOpts\n                },\n                rawArgs: fnArgs,\n                hashedId,\n                input: stepState?.input,\n                fn: opts?.fn ? ()=>opts.fn?.(...fnArgs) : void 0,\n                promise,\n                fulfilled: isFulfilled,\n                hasStepState: Boolean(stepState),\n                displayName: opId.displayName ?? opId.id,\n                handled: false,\n                handle: ()=>{\n                    if (step.handled) return false;\n                    step.handled = true;\n                    const result = this.state.stepState[hashedId];\n                    if (step.fulfilled && result) {\n                        result.fulfilled = true;\n                        Promise.all([\n                            result.data,\n                            result.error,\n                            result.input\n                        ]).then(()=>{\n                            if (typeof result.data !== \"undefined\") resolve(result.data);\n                            else {\n                                this.state.recentlyRejectedStepError = new _StepError_js__WEBPACK_IMPORTED_MODULE_14__.StepError(opId.id, result.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                }\n            };\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n\t\t\t* If this is the last piece of state we had, we've now finished\n\t\t\t* memoizing.\n\t\t\t*/ if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async ()=>{\n                await this.state.hooks?.afterMemoization?.();\n                await this.state.hooks?.beforeExecution?.();\n            })());\n            return promise;\n        };\n        return (0,_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) return this.options.fn[\"fn\"];\n        if (!this.options.fn[\"onFailureFn\"]) /**\n\t\t* Somehow, we've ended up detecting that this is a failure handler but\n\t\t* doesn't have an `onFailure` function. This should never happen.\n\t\t*/ throw new Error(\"Cannot find function `onFailure` handler\");\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) return;\n        this.timeout = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.createTimeoutPromise)(this.timeoutDuration);\n        this.timeout.then(async ()=>{\n            await this.state.hooks?.afterMemoization?.();\n            await this.state.hooks?.beforeExecution?.();\n            await this.state.hooks?.afterExecution?.();\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: _types_js__WEBPACK_IMPORTED_MODULE_5__.StepOpCode.StepNotFound\n                }\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        return await (0,_InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_10__.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs\n        }, {\n            transformInput: (prev, output)=>{\n                return {\n                    ctx: {\n                        ...prev.ctx,\n                        ...output?.ctx\n                    },\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i)=>({\n                            ...step,\n                            ...output?.steps?.[i]\n                        })),\n                    reqArgs: prev.reqArgs\n                };\n            },\n            transformOutput: (prev, output)=>{\n                return {\n                    result: {\n                        ...prev.result,\n                        ...output?.result\n                    },\n                    step: prev.step\n                };\n            }\n        });\n    }\n};\nconst hashId = (id)=>{\n    return sha1().update(id).digest(\"hex\");\n};\nconst hashOp = (op)=>{\n    return {\n        ...op,\n        id: hashId(op.id)\n    };\n};\n/**\n* Exported for testing.\n*/ const _internals = {\n    hashOp,\n    hashId\n};\n//#endregion\n //# sourceMappingURL=v1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEQ7QUFDRDtBQUNsQjtBQUM0QztBQUNoQjtBQUNkO0FBQ0c7QUFDd0Q7QUFDdkQ7QUFDTjtBQUNEO0FBQ3NIO0FBQ3BIO0FBQ1o7QUFDd0U7QUFDekY7QUFDZ0I7QUFDZDtBQUU3Qix3Q0FBd0M7QUFDeEMsSUFBSW1DLGFBQWEsYUFBYSxHQUFHbkMsc0VBQVFBLENBQUM7SUFDekNvQyxZQUFZLElBQU1BO0lBQ2xCQywwQkFBMEIsSUFBTUE7QUFDakM7QUFDQSxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHSixvQ0FBTUE7QUFDdkIsTUFBTUcsMkJBQTJCLENBQUNFO0lBQ2pDLE9BQU8sSUFBSUMsbUJBQW1CRDtBQUMvQjtBQUNBLElBQUlDLHFCQUFxQixjQUFjOUIsa0VBQWdCQTtJQWdCdEQrQixZQUFZRixPQUFPLENBQUU7UUFDcEIsS0FBSyxDQUFDQTthQWhCUHBDLFVBQVVDLGdFQUFnQkEsQ0FBQ3NDLEVBQUU7YUFJN0JDLGtCQUFrQixNQUFNO1FBYXZCOztFQUVBLEdBQ0EsSUFBSSxJQUFJLENBQUNKLE9BQU8sQ0FBQ0ssUUFBUSxLQUFLckMsK0NBQVFBLENBQUNzQyxJQUFJLEVBQUU7WUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxjQUFjLEVBQUUsTUFBTSxJQUFJQyxNQUFNO1FBQ25EO1FBQ0EsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDQyxjQUFjO1FBQ3RDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CO1FBQ3RDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0MsV0FBVztRQUM3QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUksQ0FBQ2YsT0FBTyxDQUFDSyxRQUFRLEtBQUtyQywrQ0FBUUEsQ0FBQ3NDLElBQUks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QixDQUFDQyxNQUFNQztnQkFDdEIsT0FBTztvQkFDTnRILEtBQUs7d0JBQ0osR0FBR3FILEtBQUtySCxHQUFHO3dCQUNYLEdBQUdzSCxRQUFRdEgsR0FBRztvQkFDZjtvQkFDQTRGLElBQUksSUFBSSxDQUFDN0gsT0FBTyxDQUFDNkgsRUFBRTtvQkFDbkIvRCxPQUFPd0YsS0FBS3hGLEtBQUssQ0FBQzRCLEdBQUcsQ0FBQyxDQUFDSCxNQUFNakMsSUFBTzs0QkFDbkMsR0FBR2lDLElBQUk7NEJBQ1AsR0FBR2dFLFFBQVF6RixPQUFPLENBQUNSLEVBQUU7d0JBQ3RCO29CQUNBaUgsU0FBU2pCLEtBQUtpQixPQUFPO2dCQUN0QjtZQUNEO1lBQ0E1RyxpQkFBaUIsQ0FBQzJGLE1BQU1DO2dCQUN2QixPQUFPO29CQUNOekcsUUFBUTt3QkFDUCxHQUFHd0csS0FBS3hHLE1BQU07d0JBQ2QsR0FBR3lHLFFBQVF6RyxNQUFNO29CQUNsQjtvQkFDQXlDLE1BQU0rRCxLQUFLL0QsSUFBSTtnQkFDaEI7WUFDRDtRQUNEO0lBQ0Q7QUFDRDtBQUNBLE1BQU1ILFNBQVMsQ0FBQ0Q7SUFDZixPQUFPcEYsT0FBT2tQLE1BQU0sQ0FBQzlKLElBQUkrSixNQUFNLENBQUM7QUFDakM7QUFDQSxNQUFNcEksU0FBUyxDQUFDN0I7SUFDZixPQUFPO1FBQ04sR0FBR0EsRUFBRTtRQUNMRSxJQUFJQyxPQUFPSCxHQUFHRSxFQUFFO0lBQ2pCO0FBQ0Q7QUFDQTs7QUFFQSxHQUNBLE1BQU10RixhQUFhO0lBQ2xCaUg7SUFDQTFCO0FBQ0Q7QUFFQSxZQUFZO0FBQ2dELENBQzVELDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MS5qcz85ZTIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXhwb3J0IH0gZnJvbSBcIi4uLy4uL192aXJ0dWFsL3JvbGxkb3duX3J1bnRpbWUuanNcIjtcbmltcG9ydCB7IGdldEFzeW5jQ3R4LCBnZXRBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gXCIuL2Fscy5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi8uLi92ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBFeGVjdXRpb25WZXJzaW9uLCBoZWFkZXJLZXlzLCBpbnRlcm5hbEV2ZW50cyB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL2NvbnN0cy5qc1wiO1xuaW1wb3J0IHsgU3RlcE1vZGUsIFN0ZXBPcENvZGUsIGpzb25FcnJvclNjaGVtYSB9IGZyb20gXCIuLi8uLi90eXBlcy5qc1wiO1xuaW1wb3J0IHsgSW5uZ2VzdEV4ZWN1dGlvbiB9IGZyb20gXCIuL0lubmdlc3RFeGVjdXRpb24uanNcIjtcbmltcG9ydCB7IE5vblJldHJpYWJsZUVycm9yIH0gZnJvbSBcIi4uL05vblJldHJpYWJsZUVycm9yLmpzXCI7XG5pbXBvcnQgeyBFcnJDb2RlLCBkZXNlcmlhbGl6ZUVycm9yLCBtaW5pZnlQcmV0dHlFcnJvciwgcHJldHR5RXJyb3IsIHNlcmlhbGl6ZUVycm9yIH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyB1bmRlZmluZWRUb051bGwgfSBmcm9tIFwiLi4vLi4vaGVscGVycy9mdW5jdGlvbnMuanNcIjtcbmltcG9ydCB7IGdldEhvb2tTdGFjayB9IGZyb20gXCIuLi9Jbm5nZXN0TWlkZGxld2FyZS5qc1wiO1xuaW1wb3J0IHsgY2xpZW50UHJvY2Vzc29yTWFwIH0gZnJvbSBcIi4vb3RlbC9hY2Nlc3MuanNcIjtcbmltcG9ydCB7IGNyZWF0ZURlZmVycmVkUHJvbWlzZSwgY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrLCBjcmVhdGVUaW1lb3V0UHJvbWlzZSwgcmVzb2x2ZUFmdGVyUGVuZGluZywgcmVzb2x2ZU5leHRUaWNrLCBydW5Bc1Byb21pc2UgfSBmcm9tIFwiLi4vLi4vaGVscGVycy9wcm9taXNlcy5qc1wiO1xuaW1wb3J0IHsgUmV0cnlBZnRlckVycm9yIH0gZnJvbSBcIi4uL1JldHJ5QWZ0ZXJFcnJvci5qc1wiO1xuaW1wb3J0IHsgU3RlcEVycm9yIH0gZnJvbSBcIi4uL1N0ZXBFcnJvci5qc1wiO1xuaW1wb3J0IHsgU1RFUF9JTkRFWElOR19TVUZGSVgsIGNyZWF0ZVN0ZXBUb29scywgZ2V0U3RlcE9wdGlvbnMsIGludm9rZVBheWxvYWRTY2hlbWEgfSBmcm9tIFwiLi4vSW5uZ2VzdFN0ZXBUb29scy5qc1wiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjNcIjtcbmltcG9ydCB7IHRyYWNlIH0gZnJvbSBcIkBvcGVudGVsZW1ldHJ5L2FwaVwiO1xuaW1wb3J0IGhhc2hqcyBmcm9tIFwiaGFzaC5qc1wiO1xuXG4vLyNyZWdpb24gc3JjL2NvbXBvbmVudHMvZXhlY3V0aW9uL3YxLnRzXG52YXIgdjFfZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBfX2V4cG9ydCh7XG5cdF9pbnRlcm5hbHM6ICgpID0+IF9pbnRlcm5hbHMsXG5cdGNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbjogKCkgPT4gY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uXG59KTtcbmNvbnN0IHsgc2hhMSB9ID0gaGFzaGpzO1xuY29uc3QgY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uID0gKG9wdGlvbnMpID0+IHtcblx0cmV0dXJuIG5ldyBWMUlubmdlc3RFeGVjdXRpb24ob3B0aW9ucyk7XG59O1xudmFyIFYxSW5uZ2VzdEV4ZWN1dGlvbiA9IGNsYXNzIGV4dGVuZHMgSW5uZ2VzdEV4ZWN1dGlvbiB7XG5cdHZlcnNpb24gPSBFeGVjdXRpb25WZXJzaW9uLlYxO1xuXHRzdGF0ZTtcblx0Zm5Bcmc7XG5cdGNoZWNrcG9pbnRIYW5kbGVycztcblx0dGltZW91dER1cmF0aW9uID0gMWUzICogMTA7XG5cdGV4ZWN1dGlvbjtcblx0dXNlckZuVG9SdW47XG5cdC8qKlxuXHQqIElmIHdlJ3JlIHN1cHBvc2VkIHRvIHJ1biBhIHBhcnRpY3VsYXIgc3RlcCB2aWEgYHJlcXVlc3RlZFJ1blN0ZXBgLCB0aGlzXG5cdCogd2lsbCBiZSBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGFmdGVyIG5vIHN0ZXBzIGhhdmUgYmVlbiBmb3VuZCBmb3Jcblx0KiBgdGltZW91dER1cmF0aW9uYCBtaWxsaXNlY29uZHMuXG5cdCpcblx0KiBJZiB3ZSdyZSBub3Qgc3VwcG9zZWQgdG8gcnVuIGEgcGFydGljdWxhciBzdGVwLCB0aGlzIHdpbGwgYmUgYHVuZGVmaW5lZGAuXG5cdCovXG5cdHRpbWVvdXQ7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0XHQvKipcblx0XHQqIENoZWNrIHdlIGhhdmUgZXZlcnl0aGluZyB3ZSBuZWVkIGZvciBjaGVja3BvaW50aW5nXG5cdFx0Ki9cblx0XHRpZiAodGhpcy5vcHRpb25zLnN0ZXBNb2RlID09PSBTdGVwTW9kZS5TeW5jKSB7XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5jcmVhdGVSZXNwb25zZSkgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlUmVzcG9uc2UgaXMgcmVxdWlyZWQgZm9yIHN5bmMgc3RlcCBtb2RlXCIpO1xuXHRcdH1cblx0XHR0aGlzLnVzZXJGblRvUnVuID0gdGhpcy5nZXRVc2VyRm5Ub1J1bigpO1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLmNyZWF0ZUV4ZWN1dGlvblN0YXRlKCk7XG5cdFx0dGhpcy5mbkFyZyA9IHRoaXMuY3JlYXRlRm5BcmcoKTtcblx0XHR0aGlzLmNoZWNrcG9pbnRIYW5kbGVycyA9IHRoaXMub3B0aW9ucy5zdGVwTW9kZSA9PT0gU3RlcE1vZGUuU3luYyA/IHRoaXMuY3JlYXRlQ2hlY2twb2ludGluZ0NoZWNrcG9pbnRIYW5kbGVycygpIDogdGhpcy5jcmVhdGVDaGVja3BvaW50SGFuZGxlcnMoKTtcblx0XHR0aGlzLmluaXRpYWxpemVUaW1lcih0aGlzLnN0YXRlKTtcblx0XHR0aGlzLmRlYnVnKFwiY3JlYXRlZCBuZXcgVjEgZXhlY3V0aW9uIGZvciBydW47XCIsIHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwID8gYHdhbnRpbmcgdG8gcnVuIHN0ZXAgXCIke3RoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwfVwiYCA6IFwiZGlzY292ZXJpbmcgc3RlcHNcIik7XG5cdFx0dGhpcy5kZWJ1ZyhcImV4aXN0aW5nIHN0YXRlIGtleXM6XCIsIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSk7XG5cdH1cblx0LyoqXG5cdCogSWRlbXBvdGVudGx5IHN0YXJ0IHRoZSBleGVjdXRpb24gb2YgdGhlIHVzZXIncyBmdW5jdGlvbi5cblx0Ki9cblx0c3RhcnQoKSB7XG5cdFx0aWYgKCF0aGlzLmV4ZWN1dGlvbikge1xuXHRcdFx0dGhpcy5kZWJ1ZyhcInN0YXJ0aW5nIFYxIGV4ZWN1dGlvblwiKTtcblx0XHRcdGNvbnN0IHRyYWNlciA9IHRyYWNlLmdldFRyYWNlcihcImlubmdlc3RcIiwgdmVyc2lvbik7XG5cdFx0XHR0aGlzLmV4ZWN1dGlvbiA9IGdldEFzeW5jTG9jYWxTdG9yYWdlKCkudGhlbigoYWxzKSA9PiB7XG5cdFx0XHRcdHJldHVybiBhbHMucnVuKHtcblx0XHRcdFx0XHRhcHA6IHRoaXMub3B0aW9ucy5jbGllbnQsXG5cdFx0XHRcdFx0ZXhlY3V0aW9uOiB7XG5cdFx0XHRcdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRcdFx0XHRpbnN0YW5jZTogdGhpc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKFwiaW5uZ2VzdC5leGVjdXRpb25cIiwgKHNwYW4pID0+IHtcblx0XHRcdFx0XHRcdGNsaWVudFByb2Nlc3Nvck1hcC5nZXQodGhpcy5vcHRpb25zLmNsaWVudCk/LmRlY2xhcmVTdGFydGluZ1NwYW4oe1xuXHRcdFx0XHRcdFx0XHRzcGFuLFxuXHRcdFx0XHRcdFx0XHRydW5JZDogdGhpcy5vcHRpb25zLnJ1bklkLFxuXHRcdFx0XHRcdFx0XHR0cmFjZXBhcmVudDogdGhpcy5vcHRpb25zLmhlYWRlcnNbaGVhZGVyS2V5cy5UcmFjZVBhcmVudF0sXG5cdFx0XHRcdFx0XHRcdHRyYWNlc3RhdGU6IHRoaXMub3B0aW9ucy5oZWFkZXJzW2hlYWRlcktleXMuVHJhY2VTdGF0ZV1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3N0YXJ0KCkudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVidWcoXCJyZXN1bHQ6XCIsIHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9KS5maW5hbGx5KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0c3Bhbi5lbmQoKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5leGVjdXRpb247XG5cdH1cblx0LyoqXG5cdCogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uIGFuZCB0aGUgY29yZSBsb29wLlxuXHQqL1xuXHRhc3luYyBfc3RhcnQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGFsbENoZWNrcG9pbnRIYW5kbGVyID0gdGhpcy5nZXRDaGVja3BvaW50SGFuZGxlcihcIlwiKTtcblx0XHRcdHRoaXMuc3RhdGUuaG9va3MgPSBhd2FpdCB0aGlzLmluaXRpYWxpemVNaWRkbGV3YXJlKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXJ0RXhlY3V0aW9uKCk7XG5cdFx0XHRsZXQgaSA9IDA7XG5cdFx0XHRmb3IgYXdhaXQgKGNvbnN0IGNoZWNrcG9pbnQgb2YgdGhpcy5zdGF0ZS5sb29wKSB7XG5cdFx0XHRcdGF3YWl0IGFsbENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQsIGkpO1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQudHlwZSkoY2hlY2twb2ludCwgaSsrKTtcblx0XHRcdFx0aWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZXJyb3IgfSk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuc3RhdGUubG9vcC5yZXR1cm4oKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmJlZm9yZVJlc3BvbnNlPy4oKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0KiBJZiB3ZSdyZSBoZXJlLCB0aGUgZ2VuZXJhdG9yIHNvbWVob3cgZmluaXNoZWQgd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZS5cblx0XHQqIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cblx0XHQqL1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvcmUgbG9vcCBmaW5pc2hlZCB3aXRob3V0IHJldHVybmluZyBhIHZhbHVlXCIpO1xuXHR9XG5cdGFzeW5jIGNoZWNrcG9pbnQoc3RlcHMpIHtcblx0XHRpZiAoIXRoaXMuc3RhdGUuY2hlY2twb2ludGVkUnVuKSB7XG5cdFx0XHRjb25zdCByZXMgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY2xpZW50W1wiaW5uZ2VzdEFwaVwiXS5jaGVja3BvaW50TmV3UnVuKHtcblx0XHRcdFx0cnVuSWQ6IHRoaXMuZm5BcmcucnVuSWQsXG5cdFx0XHRcdGV2ZW50OiB0aGlzLmZuQXJnLmV2ZW50LFxuXHRcdFx0XHRzdGVwc1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLnN0YXRlLmNoZWNrcG9pbnRlZFJ1biA9IHtcblx0XHRcdFx0YXBwSWQ6IHJlcy5kYXRhLmFwcF9pZCxcblx0XHRcdFx0Zm5JZDogcmVzLmRhdGEuZm5faWQsXG5cdFx0XHRcdHRva2VuOiByZXMuZGF0YS50b2tlblxuXHRcdFx0fTtcblx0XHR9IGVsc2UgYXdhaXQgdGhpcy5vcHRpb25zLmNsaWVudFtcImlubmdlc3RBcGlcIl0uY2hlY2twb2ludFN0ZXBzKHtcblx0XHRcdGFwcElkOiB0aGlzLnN0YXRlLmNoZWNrcG9pbnRlZFJ1bi5hcHBJZCxcblx0XHRcdGZuSWQ6IHRoaXMuc3RhdGUuY2hlY2twb2ludGVkUnVuLmZuSWQsXG5cdFx0XHRydW5JZDogdGhpcy5mbkFyZy5ydW5JZCxcblx0XHRcdHN0ZXBzXG5cdFx0fSk7XG5cdH1cblx0YXN5bmMgY2hlY2twb2ludEFuZFN3aXRjaFRvQXN5bmMoc3RlcHMpIHtcblx0XHRhd2FpdCB0aGlzLmNoZWNrcG9pbnQoc3RlcHMpO1xuXHRcdGlmICghdGhpcy5zdGF0ZS5jaGVja3BvaW50ZWRSdW4/LnRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY2hlY2twb2ludCBhbmQgc3dpdGNoIHRvIGFzeW5jIG1vZGVcIik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiY2hhbmdlLW1vZGVcIixcblx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdG9wczogdGhpcy5vcHMsXG5cdFx0XHR0bzogU3RlcE1vZGUuQXN5bmMsXG5cdFx0XHR0b2tlbjogdGhpcy5zdGF0ZS5jaGVja3BvaW50ZWRSdW4/LnRva2VuXG5cdFx0fTtcblx0fVxuXHQvKipcblx0KiBSZXR1cm5zIHdoZXRoZXIgd2UncmUgaW4gdGhlIGZpbmFsIGF0dGVtcHQgb2YgZXhlY3V0aW9uLCBvciBgbnVsbGAgaWYgd2Vcblx0KiBjYW4ndCBkZXRlcm1pbmUgdGhpcyBpbiB0aGUgU0RLLlxuXHQqL1xuXHRpbkZpbmFsQXR0ZW1wdCgpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMuZm5BcmcubWF4QXR0ZW1wdHMgIT09IFwibnVtYmVyXCIpIHJldHVybiBudWxsO1xuXHRcdHJldHVybiB0aGlzLmZuQXJnLmF0dGVtcHQgKyAxID49IHRoaXMuZm5BcmcubWF4QXR0ZW1wdHM7XG5cdH1cblx0Y3JlYXRlQ2hlY2twb2ludGluZ0NoZWNrcG9pbnRIYW5kbGVycygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0XCJcIjogYXN5bmMgKGNoZWNrcG9pbnQsIGkpID0+IHtcblx0XHRcdFx0dGhpcy5kZWJ1ZyhcInN5bmMgY2hlY2twb2ludDpcIiwgY2hlY2twb2ludCk7XG5cdFx0XHR9LFxuXHRcdFx0XCJmdW5jdGlvbi1yZXNvbHZlZFwiOiBhc3luYyAoY2hlY2twb2ludCwgaSkgPT4ge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNoZWNrcG9pbnQoW3tcblx0XHRcdFx0XHRvcDogU3RlcE9wQ29kZS5SdW5Db21wbGV0ZSxcblx0XHRcdFx0XHRpZDogX2ludGVybmFscy5oYXNoSWQoXCJjb21wbGV0ZVwiKSxcblx0XHRcdFx0XHRkYXRhOiBhd2FpdCB0aGlzLm9wdGlvbnMuY3JlYXRlUmVzcG9uc2UoY2hlY2twb2ludC5kYXRhKVxuXHRcdFx0XHR9XSk7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJmdW5jdGlvbi1yZXNvbHZlZFwiLFxuXHRcdFx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0XHRcdGRhdGE6IGNoZWNrcG9pbnQuZGF0YVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdFwiZnVuY3Rpb24tcmVqZWN0ZWRcIjogKGNoZWNrcG9pbnQpID0+IHtcblx0XHRcdFx0aWYgKHRoaXMuaW5GaW5hbEF0dGVtcHQoKSkgcmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsXG5cdFx0XHRcdFx0Y3R4OiB0aGlzLmZuQXJnLFxuXHRcdFx0XHRcdGVycm9yOiBjaGVja3BvaW50LmVycm9yLFxuXHRcdFx0XHRcdG9wczogdGhpcy5vcHMsXG5cdFx0XHRcdFx0cmV0cmlhYmxlOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jaGVja3BvaW50QW5kU3dpdGNoVG9Bc3luYyhbe1xuXHRcdFx0XHRcdGlkOiBfaW50ZXJuYWxzLmhhc2hJZChcImNvbXBsZXRlXCIpLFxuXHRcdFx0XHRcdGRpc3BsYXlOYW1lOiBcImNvbXBsZXRlXCIsXG5cdFx0XHRcdFx0b3A6IFN0ZXBPcENvZGUuU3RlcEVycm9yLFxuXHRcdFx0XHRcdGVycm9yOiBjaGVja3BvaW50LmVycm9yXG5cdFx0XHRcdH1dKTtcblx0XHRcdH0sXG5cdFx0XHRcInN0ZXAtbm90LWZvdW5kXCI6ICh7IHN0ZXAgfSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIixcblx0XHRcdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRcdFx0ZXJyb3I6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXJyb3IoXCJTdGVwIG5vdCBmb3VuZCB3aGVuIGNoZWNrcG9pbnRpbmc7IHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKSxcblx0XHRcdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0XHRcdHJldHJpYWJsZTogZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRcInN0ZXBzLWZvdW5kXCI6IGFzeW5jICh7IHN0ZXBzIH0pID0+IHtcblx0XHRcdFx0aWYgKHN0ZXBzLmxlbmd0aCAhPT0gMSB8fCBzdGVwc1swXS5tb2RlICE9PSBTdGVwTW9kZS5TeW5jKSByZXR1cm4gdGhpcy5jaGVja3BvaW50QW5kU3dpdGNoVG9Bc3luYyhzdGVwcy5tYXAoKHN0ZXAkMSkgPT4gKHtcblx0XHRcdFx0XHQuLi5zdGVwJDEsXG5cdFx0XHRcdFx0aWQ6IHN0ZXAkMS5oYXNoZWRJZFxuXHRcdFx0XHR9KSkpO1xuXHRcdFx0XHRjb25zdCBzdGVwID0gdGhpcy5zdGF0ZS5zdGVwcy5nZXQoc3RlcHNbMF0uaWQpO1xuXHRcdFx0XHRpZiAoIXN0ZXApIHRocm93IG5ldyBFcnJvcihcIlN0ZXAgbm90IGZvdW5kIGluIG1lbW9pemF0aW9uIHN0YXRlOyB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4gYW5kIGlzIGEgYnVnIGluIHRoZSBJbm5nZXN0IFNES1wiKTtcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVTdGVwKHN0ZXApO1xuXHRcdFx0XHRjb25zdCBpbnRlcnZhbCA9IHtcblx0XHRcdFx0XHRhOiBzdGFydCAqIDFlNixcblx0XHRcdFx0XHRiOiAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAqIDFlNlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAocmVzdWx0LmVycm9yKSB7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5jaGVja3BvaW50KFt7XG5cdFx0XHRcdFx0XHQuLi5zdGVwLFxuXHRcdFx0XHRcdFx0b3A6IHN0ZXAub3AgPT09IFN0ZXBPcENvZGUuU3RlcFBsYW5uZWQgPyBTdGVwT3BDb2RlLlN0ZXBFcnJvciA6IHN0ZXAub3AsXG5cdFx0XHRcdFx0XHRlcnJvcjogcmVzdWx0LmVycm9yXG5cdFx0XHRcdFx0fV0pO1xuXHRcdFx0XHRcdGlmICghdGhpcy5zdGF0ZS5jaGVja3BvaW50ZWRSdW4/LnRva2VuKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY2hlY2twb2ludCBhbmQgc3dpdGNoIHRvIGFzeW5jIG1vZGUgYXMgbm8gdG9rZW4gd2FzIHJldHVybmVkIGZyb20gdGhlIEFQSVwiKTtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJjaGFuZ2UtbW9kZVwiLFxuXHRcdFx0XHRcdFx0Y3R4OiB0aGlzLmZuQXJnLFxuXHRcdFx0XHRcdFx0b3BzOiB0aGlzLm9wcyxcblx0XHRcdFx0XHRcdHRvOiBTdGVwTW9kZS5Bc3luYyxcblx0XHRcdFx0XHRcdHRva2VuOiB0aGlzLnN0YXRlLmNoZWNrcG9pbnRlZFJ1bi50b2tlblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKFwiZGF0YVwiIGluIHJlc3VsdCkge1xuXHRcdFx0XHRcdHN0ZXAuZGF0YSA9IHJlc3VsdC5kYXRhO1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUuc3RlcFN0YXRlW3N0ZXBzWzBdLmhhc2hlZElkXSA9IHN0ZXA7XG5cdFx0XHRcdFx0c3RlcC5mdWxmaWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMuY2hlY2twb2ludChbe1xuXHRcdFx0XHRcdFx0aWQ6IHN0ZXAuaGFzaGVkSWQsXG5cdFx0XHRcdFx0XHRkYXRhOiBzdGVwLmRhdGEsXG5cdFx0XHRcdFx0XHRvcDogc3RlcC5vcCA9PT0gU3RlcE9wQ29kZS5TdGVwUGxhbm5lZCA/IFN0ZXBPcENvZGUuU3RlcFJ1biA6IHN0ZXAub3AsXG5cdFx0XHRcdFx0XHRkaXNwbGF5TmFtZTogc3RlcC5kaXNwbGF5TmFtZSxcblx0XHRcdFx0XHRcdG9wdHM6IHN0ZXAub3B0cyxcblx0XHRcdFx0XHRcdHVzZXJsYW5kOiBzdGVwLnVzZXJsYW5kLFxuXHRcdFx0XHRcdFx0bmFtZTogc3RlcC5uYW1lLFxuXHRcdFx0XHRcdFx0dGltaW5nOiBpbnRlcnZhbFxuXHRcdFx0XHRcdH1dKTtcblx0XHRcdFx0XHRzdGVwLmhhbmRsZSgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBIHN0ZXAgd2FzIHJ1biBhbmQgaGFkIG5vIGRhdGEgb3IgZXJyb3I7IHRoaXMgaXMgYSBidWcgaW4gdGhlIElubmdlc3QgU0RLXCIpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIGhhbmRsZXIgZm9yIGV2ZXJ5IGNoZWNrcG9pbnQgdHlwZSwgZGVmaW5pbmcgd2hhdCB0byBkbyB3aGVuIHdlXG5cdCogcmVhY2ggdGhhdCBjaGVja3BvaW50IGluIHRoZSBjb3JlIGxvb3AuXG5cdCovXG5cdGNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0XCJcIjogKGNoZWNrcG9pbnQpID0+IHtcblx0XHRcdFx0dGhpcy5kZWJ1ZyhcImFzeW5jIGNoZWNrcG9pbnQ6XCIsIGNoZWNrcG9pbnQpO1xuXHRcdFx0fSxcblx0XHRcdFwiZnVuY3Rpb24tcmVzb2x2ZWRcIjogYXN5bmMgKHsgZGF0YSB9KSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlUmVzcG9uc2UpIGRhdGEgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY3JlYXRlUmVzcG9uc2UoZGF0YSk7XG5cdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGEgfSk7XG5cdFx0XHR9LFxuXHRcdFx0XCJmdW5jdGlvbi1yZWplY3RlZFwiOiBhc3luYyAoY2hlY2twb2ludCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvcjogY2hlY2twb2ludC5lcnJvciB9KTtcblx0XHRcdH0sXG5cdFx0XHRcInN0ZXBzLWZvdW5kXCI6IGFzeW5jICh7IHN0ZXBzIH0pID0+IHtcblx0XHRcdFx0Y29uc3Qgc3RlcFJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpO1xuXHRcdFx0XHRpZiAoc3RlcFJlc3VsdCkge1xuXHRcdFx0XHRcdGNvbnN0IHRyYW5zZm9ybVJlc3VsdCA9IGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHN0ZXBSZXN1bHQpO1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCogVHJhbnNmb3JtaW5nIG91dHB1dCB3aWxsIGFsd2F5cyByZXR1cm4gZWl0aGVyIGZ1bmN0aW9uIHJlamVjdGlvbiBvclxuXHRcdFx0XHRcdCogcmVzb2x1dGlvbi4gSW4gbW9zdCBjYXNlcywgdGhpcyBjYW4gYmUgaW1tZWRpYXRlbHkgcmV0dXJuZWQsIGJ1dCBpblxuXHRcdFx0XHRcdCogdGhpcyBwYXJ0aWN1bGFyIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgaXQgZGlmZmVyZW50bHkuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRpZiAodHJhbnNmb3JtUmVzdWx0LnR5cGUgPT09IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIikgcmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RlcC1yYW5cIixcblx0XHRcdFx0XHRcdGN0eDogdHJhbnNmb3JtUmVzdWx0LmN0eCxcblx0XHRcdFx0XHRcdG9wczogdHJhbnNmb3JtUmVzdWx0Lm9wcyxcblx0XHRcdFx0XHRcdHN0ZXA6IF9pbnRlcm5hbHMuaGFzaE9wKHtcblx0XHRcdFx0XHRcdFx0Li4uc3RlcFJlc3VsdCxcblx0XHRcdFx0XHRcdFx0ZGF0YTogdHJhbnNmb3JtUmVzdWx0LmRhdGFcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRlbHNlIGlmICh0cmFuc2Zvcm1SZXN1bHQudHlwZSA9PT0gXCJmdW5jdGlvbi1yZWplY3RlZFwiKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdGVwRm9yUmVzcG9uc2UgPSBfaW50ZXJuYWxzLmhhc2hPcCh7XG5cdFx0XHRcdFx0XHRcdC4uLnN0ZXBSZXN1bHQsXG5cdFx0XHRcdFx0XHRcdGVycm9yOiB0cmFuc2Zvcm1SZXN1bHQuZXJyb3Jcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0aWYgKHN0ZXBSZXN1bHQub3AgPT09IFN0ZXBPcENvZGUuU3RlcEZhaWxlZCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzZXIgPSBzZXJpYWxpemVFcnJvcih0cmFuc2Zvcm1SZXN1bHQuZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRzdGVwRm9yUmVzcG9uc2UuZGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0XHRfX3NlcmlhbGl6ZWQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogc2VyLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogc2VyLm1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRcdFx0c3RhY2s6IFwiXCJcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RlcC1yYW5cIixcblx0XHRcdFx0XHRcdFx0Y3R4OiB0cmFuc2Zvcm1SZXN1bHQuY3R4LFxuXHRcdFx0XHRcdFx0XHRvcHM6IHRyYW5zZm9ybVJlc3VsdC5vcHMsXG5cdFx0XHRcdFx0XHRcdHJldHJpYWJsZTogdHJhbnNmb3JtUmVzdWx0LnJldHJpYWJsZSxcblx0XHRcdFx0XHRcdFx0c3RlcDogc3RlcEZvclJlc3BvbnNlXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNmb3JtUmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IG5ld1N0ZXBzID0gYXdhaXQgdGhpcy5maWx0ZXJOZXdTdGVwcyhBcnJheS5mcm9tKHRoaXMuc3RhdGUuc3RlcHMudmFsdWVzKCkpKTtcblx0XHRcdFx0aWYgKG5ld1N0ZXBzKSByZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwic3RlcHMtZm91bmRcIixcblx0XHRcdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRcdFx0b3BzOiB0aGlzLm9wcyxcblx0XHRcdFx0XHRzdGVwczogbmV3U3RlcHNcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRcInN0ZXAtbm90LWZvdW5kXCI6ICh7IHN0ZXAgfSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwic3RlcC1ub3QtZm91bmRcIixcblx0XHRcdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRcdFx0b3BzOiB0aGlzLm9wcyxcblx0XHRcdFx0XHRzdGVwXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRnZXRDaGVja3BvaW50SGFuZGxlcih0eXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hlY2twb2ludEhhbmRsZXJzW3R5cGVdO1xuXHR9XG5cdGFzeW5jIHRyeUV4ZWN1dGVTdGVwKHN0ZXBzKSB7XG5cdFx0Y29uc3QgaGFzaGVkU3RlcElkVG9SdW4gPSB0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCB8fCB0aGlzLmdldEVhcmx5RXhlY1J1blN0ZXAoc3RlcHMpO1xuXHRcdGlmICghaGFzaGVkU3RlcElkVG9SdW4pIHJldHVybjtcblx0XHRjb25zdCBzdGVwID0gc3RlcHMuZmluZCgoc3RlcCQxKSA9PiBzdGVwJDEuaGFzaGVkSWQgPT09IGhhc2hlZFN0ZXBJZFRvUnVuICYmIHN0ZXAkMS5mbik7XG5cdFx0aWYgKHN0ZXApIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVTdGVwKHN0ZXApO1xuXHRcdHRoaXMudGltZW91dD8ucmVzZXQoKTtcblx0fVxuXHQvKipcblx0KiBHaXZlbiBhIGxpc3Qgb2Ygb3V0Z29pbmcgb3BzLCBkZWNpZGUgaWYgd2UgY2FuIGV4ZWN1dGUgYW4gb3AgZWFybHkgYW5kXG5cdCogcmV0dXJuIHRoZSBJRCBvZiB0aGUgc3RlcCB0byBleGVjdXRlIGlmIHdlIGNhbi5cblx0Ki9cblx0Z2V0RWFybHlFeGVjUnVuU3RlcChzdGVwcykge1xuXHRcdC8qKlxuXHRcdCogV2UgbWF5IGhhdmUgYmVlbiBkaXNhYmxlZCBkdWUgdG8gcGFyYWxsZWxpc20sIGluIHdoaWNoIGNhc2Ugd2UgY2FuJ3Rcblx0XHQqIGltbWVkaWF0ZWx5IGV4ZWN1dGUgdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuXHRcdCovXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uKSByZXR1cm47XG5cdFx0Y29uc3QgdW5mdWxmaWxsZWRTdGVwcyA9IHN0ZXBzLmZpbHRlcigoc3RlcCkgPT4gIXN0ZXAuZnVsZmlsbGVkKTtcblx0XHRpZiAodW5mdWxmaWxsZWRTdGVwcy5sZW5ndGggIT09IDEpIHJldHVybjtcblx0XHRjb25zdCBvcCA9IHVuZnVsZmlsbGVkU3RlcHNbMF07XG5cdFx0aWYgKG9wICYmIG9wLm9wID09PSBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkKSByZXR1cm4gb3AuaGFzaGVkSWQ7XG5cdH1cblx0YXN5bmMgZmlsdGVyTmV3U3RlcHMoZm91bmRTdGVwcykge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkgcmV0dXJuO1xuXHRcdC8qKlxuXHRcdCogR2F0aGVyIGFueSBzdGVwcyB0aGF0IGFyZW4ndCBtZW1vaXplZCBhbmQgcmVwb3J0IHRoZW0uXG5cdFx0Ki9cblx0XHRjb25zdCBuZXdTdGVwcyA9IGZvdW5kU3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuXHRcdGlmICghbmV3U3RlcHMubGVuZ3RoKSByZXR1cm47XG5cdFx0LyoqXG5cdFx0KiBXYXJuIGlmIHdlJ3ZlIGZvdW5kIG5ldyBzdGVwcyBidXQgaGF2ZW4ndCB5ZXQgc2VlbiBhbGwgcHJldmlvdXNcblx0XHQqIHN0ZXBzLiBUaGlzIG1heSBpbmRpY2F0ZSB0aGF0IHN0ZXAgcHJlc2VuY2UgaXNuJ3QgZGV0ZXJtaW5hdGUuXG5cdFx0Ki9cblx0XHRsZXQga25vd25TdGVwcyA9IDA7XG5cdFx0Zm9yIChjb25zdCBzdGVwIG9mIGZvdW5kU3RlcHMpIGlmIChzdGVwLmZ1bGZpbGxlZCkga25vd25TdGVwcysrO1xuXHRcdGlmICghKHRoaXMuc3RhdGUuc3RlcHNUb0Z1bGZpbGwgPT09IGtub3duU3RlcHMpKSBjb25zb2xlLndhcm4ocHJldHR5RXJyb3Ioe1xuXHRcdFx0dHlwZTogXCJ3YXJuXCIsXG5cdFx0XHR3aGF0SGFwcGVuZWQ6IFwiRnVuY3Rpb24gbWF5IGJlIGluZGV0ZXJtaW5hdGVcIixcblx0XHRcdHdoeTogXCJXZSBmb3VuZCBuZXcgc3RlcHMgYmVmb3JlIHNlZWluZyBhbGwgcHJldmlvdXMgc3RlcHMsIHdoaWNoIG1heSBpbmRpY2F0ZSB0aGF0IHRoZSBmdW5jdGlvbiBpcyBub24tZGV0ZXJtaW5pc3RpYy5cIixcblx0XHRcdGNvbnNlcXVlbmNlczogXCJUaGlzIG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ciBhcyBJbm5nZXN0IGV4ZWN1dGVzIHlvdXIgZnVuY3Rpb24uXCIsXG5cdFx0XHRyZWFzc3VyYW5jZTogXCJUaGlzIGlzIGV4cGVjdGVkIGlmIGEgZnVuY3Rpb24gaXMgdXBkYXRlZCBpbiB0aGUgbWlkZGxlIG9mIGEgcnVuLCBidXQgbWF5IGluZGljYXRlIGEgYnVnIGlmIG5vdC5cIlxuXHRcdH0pKTtcblx0XHQvKipcblx0XHQqIFdlJ3JlIGZpbmlzaGluZyB1cDsgbGV0J3MgdHJpZ2dlciB0aGUgbGFzdCBvZiB0aGUgaG9va3MuXG5cdFx0Ki9cblx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5hZnRlck1lbW9pemF0aW9uPy4oKTtcblx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5iZWZvcmVFeGVjdXRpb24/LigpO1xuXHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyRXhlY3V0aW9uPy4oKTtcblx0XHRjb25zdCBzdGVwTGlzdCA9IG5ld1N0ZXBzLm1hcCgoc3RlcCkgPT4gKHtcblx0XHRcdGRpc3BsYXlOYW1lOiBzdGVwLmRpc3BsYXlOYW1lLFxuXHRcdFx0b3A6IHN0ZXAub3AsXG5cdFx0XHRpZDogc3RlcC5oYXNoZWRJZCxcblx0XHRcdG5hbWU6IHN0ZXAubmFtZSxcblx0XHRcdG9wdHM6IHN0ZXAub3B0cyxcblx0XHRcdHVzZXJsYW5kOiBzdGVwLnVzZXJsYW5kXG5cdFx0fSkpO1xuXHRcdC8qKlxuXHRcdCogV2UgYWxzbyBydW4gYG9uU2VuZEV2ZW50YCBtaWRkbGV3YXJlIGhvb2tzIGFnYWluc3QgYHN0ZXAuaW52b2tlKClgIHN0ZXBzXG5cdFx0KiB0byBlbnN1cmUgdGhhdCB0aGVpciBgZGF0YWAgaXMgdHJhbnNmb3JtZWQgY29ycmVjdGx5LlxuXHRcdCovXG5cdFx0cmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtTmV3U3RlcHMoc3RlcExpc3QpO1xuXHR9XG5cdC8qKlxuXHQqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBhbnkgbmV3bHktZm91bmQgc3RlcHMgYmVmb3JlIHJldHVybmluZyB0aGVtIHRvXG5cdCogYW4gSW5uZ2VzdCBTZXJ2ZXIuXG5cdCovXG5cdGFzeW5jIHRyYW5zZm9ybU5ld1N0ZXBzKHN0ZXBzKSB7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKHN0ZXBzLm1hcChhc3luYyAoc3RlcCkgPT4ge1xuXHRcdFx0aWYgKHN0ZXAub3AgIT09IFN0ZXBPcENvZGUuSW52b2tlRnVuY3Rpb24pIHJldHVybiBzdGVwO1xuXHRcdFx0LyoqXG5cdFx0XHQqIEZvciBlYWNoIGV2ZW50IGJlaW5nIHNlbnQsIGNyZWF0ZSBhIG5ldyBgb25TZW5kRXZlbnRgIGhvb2sgc3RhY2sgdG9cblx0XHRcdCogcHJvY2VzcyBpdC4gV2UgZG8gdGhpcyBhcyBtaWRkbGV3YXJlIGhvb2tzIGFyZSBpbnRlbmRlZCB0byBydW4gb25jZVxuXHRcdFx0KiBkdXJpbmcgZWFjaCBsaWZlY3ljbGUgKG9uRnVuY3Rpb25SdW4gb3Igb25TZW5kRXZlbnQpIGFuZCBoZXJlLCBhIGhvb2tcblx0XHRcdCogaXMgcnVuIGZvciBldmVyeSBzaW5nbGUgZXZlbnQuXG5cdFx0XHQqXG5cdFx0XHQqIFRoaXMgaXMgZG9uZSBiZWNhdXNlIGEgZGV2ZWxvcGVyIGNhbiB1c2UgdGhpcyBob29rIHRvIGZpbHRlciBvdXRcblx0XHRcdCogZXZlbnRzIGVudGlyZWx5OyBpZiB3ZSBiYXRjaCBhbGwgb2YgdGhlIGV2ZW50cyB0b2dldGhlciwgd2UgY2FuJ3Rcblx0XHRcdCogdGVsbCB3aGljaCBvbmVzIHdlcmUgZmlsdGVyZWQgb3V0IGlmIHdlJ3JlIHByb2Nlc3NpbmcgPjEgaW52b2NhdGlvblxuXHRcdFx0KiBoZXJlLlxuXHRcdFx0Ki9cblx0XHRcdGNvbnN0IHRyYW5zZm9ybWVkUGF5bG9hZCA9IGF3YWl0IChhd2FpdCBnZXRIb29rU3RhY2sodGhpcy5vcHRpb25zLmZuW1wibWlkZGxld2FyZVwiXSwgXCJvblNlbmRFdmVudFwiLCB2b2lkIDAsIHtcblx0XHRcdFx0dHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0Li4ucHJldixcblx0XHRcdFx0XHRcdC4uLm91dHB1dFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRyYW5zZm9ybU91dHB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB7IHJlc3VsdDoge1xuXHRcdFx0XHRcdFx0Li4ucHJldi5yZXN1bHQsXG5cdFx0XHRcdFx0XHQuLi5vdXRwdXQ/LnJlc3VsdFxuXHRcdFx0XHRcdH0gfTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpLnRyYW5zZm9ybUlucHV0Py4oeyBwYXlsb2FkczogW3tcblx0XHRcdFx0Li4uc3RlcC5vcHRzPy5wYXlsb2FkID8/IHt9LFxuXHRcdFx0XHRuYW1lOiBpbnRlcm5hbEV2ZW50cy5GdW5jdGlvbkludm9rZWRcblx0XHRcdH1dIH0pO1xuXHRcdFx0Y29uc3QgbmV3UGF5bG9hZCA9IGludm9rZVBheWxvYWRTY2hlbWEucGFyc2UodHJhbnNmb3JtZWRQYXlsb2FkPy5wYXlsb2Fkcz8uWzBdID8/IHt9KTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC4uLnN0ZXAsXG5cdFx0XHRcdG9wdHM6IHtcblx0XHRcdFx0XHQuLi5zdGVwLm9wdHMsXG5cdFx0XHRcdFx0cGF5bG9hZDoge1xuXHRcdFx0XHRcdFx0Li4uc3RlcC5vcHRzPy5wYXlsb2FkID8/IHt9LFxuXHRcdFx0XHRcdFx0Li4ubmV3UGF5bG9hZFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9KSk7XG5cdH1cblx0YXN5bmMgZXhlY3V0ZVN0ZXAoeyBpZCwgbmFtZSwgb3B0cywgZm4sIGRpc3BsYXlOYW1lLCB1c2VybGFuZCB9KSB7XG5cdFx0dGhpcy50aW1lb3V0Py5jbGVhcigpO1xuXHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyTWVtb2l6YXRpb24/LigpO1xuXHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmJlZm9yZUV4ZWN1dGlvbj8uKCk7XG5cdFx0Y29uc3Qgb3V0Z29pbmdPcCA9IHtcblx0XHRcdGlkLFxuXHRcdFx0b3A6IFN0ZXBPcENvZGUuU3RlcFJ1bixcblx0XHRcdG5hbWUsXG5cdFx0XHRvcHRzLFxuXHRcdFx0ZGlzcGxheU5hbWUsXG5cdFx0XHR1c2VybGFuZFxuXHRcdH07XG5cdFx0dGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwID0gb3V0Z29pbmdPcDtcblx0XHRjb25zdCBzdG9yZSA9IGF3YWl0IGdldEFzeW5jQ3R4KCk7XG5cdFx0aWYgKHN0b3JlPy5leGVjdXRpb24pIHN0b3JlLmV4ZWN1dGlvbi5leGVjdXRpbmdTdGVwID0ge1xuXHRcdFx0aWQsXG5cdFx0XHRuYW1lOiBkaXNwbGF5TmFtZVxuXHRcdH07XG5cdFx0dGhpcy5kZWJ1ZyhgZXhlY3V0aW5nIHN0ZXAgXCIke2lkfVwiYCk7XG5cdFx0cmV0dXJuIHJ1bkFzUHJvbWlzZShmbikuZmluYWxseShhc3luYyAoKSA9PiB7XG5cdFx0XHRkZWxldGUgdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwO1xuXHRcdFx0aWYgKHN0b3JlPy5leGVjdXRpb24pIGRlbGV0ZSBzdG9yZS5leGVjdXRpb24uZXhlY3V0aW5nU3RlcDtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyRXhlY3V0aW9uPy4oKTtcblx0XHR9KS50aGVuKChkYXRhKSA9PiB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQuLi5vdXRnb2luZ09wLFxuXHRcdFx0XHRkYXRhXG5cdFx0XHR9O1xuXHRcdH0pLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0bGV0IGVycm9ySXNSZXRyaWFibGUgPSB0cnVlO1xuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgTm9uUmV0cmlhYmxlRXJyb3IpIGVycm9ySXNSZXRyaWFibGUgPSBmYWxzZTtcblx0XHRcdGVsc2UgaWYgKHRoaXMuZm5BcmcubWF4QXR0ZW1wdHMgJiYgdGhpcy5mbkFyZz8ubWF4QXR0ZW1wdHMgLSAxID09PSB0aGlzLmZuQXJnLmF0dGVtcHQpIGVycm9ySXNSZXRyaWFibGUgPSBmYWxzZTtcblx0XHRcdGlmIChlcnJvcklzUmV0cmlhYmxlKSByZXR1cm4ge1xuXHRcdFx0XHQuLi5vdXRnb2luZ09wLFxuXHRcdFx0XHRvcDogU3RlcE9wQ29kZS5TdGVwRXJyb3IsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0ZWxzZSByZXR1cm4ge1xuXHRcdFx0XHQuLi5vdXRnb2luZ09wLFxuXHRcdFx0XHRvcDogU3RlcE9wQ29kZS5TdGVwRmFpbGVkLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24sIGluY2x1ZGluZyB0cmlnZ2VyaW5nIGNoZWNrcG9pbnRzXG5cdCogYW5kIG1pZGRsZXdhcmUgaG9va3Mgd2hlcmUgYXBwcm9wcmlhdGUuXG5cdCovXG5cdGFzeW5jIHN0YXJ0RXhlY3V0aW9uKCkge1xuXHRcdC8qKlxuXHRcdCogTXV0YXRlIGlucHV0IGFzIG5lY2Nlc3NhcnkgYmFzZWQgb24gbWlkZGxld2FyZS5cblx0XHQqL1xuXHRcdGF3YWl0IHRoaXMudHJhbnNmb3JtSW5wdXQoKTtcblx0XHQvKipcblx0XHQqIFN0YXJ0IHRoZSB0aW1lciB0byB0aW1lIG91dCB0aGUgcnVuIGlmIG5lZWRlZC5cblx0XHQqL1xuXHRcdHRoaXMudGltZW91dD8uc3RhcnQoKTtcblx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5iZWZvcmVNZW1vaXphdGlvbj8uKCk7XG5cdFx0LyoqXG5cdFx0KiBJZiB3ZSBoYWQgbm8gc3RhdGUgdG8gYmVnaW4gd2l0aCwgaW1tZWRpYXRlbHkgZW5kIHRoZSBtZW1vaXphdGlvbiBwaGFzZS5cblx0XHQqL1xuXHRcdGlmICh0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSB7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5hZnRlck1lbW9pemF0aW9uPy4oKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmJlZm9yZUV4ZWN1dGlvbj8uKCk7XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCogVHJpZ2dlciB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuXHRcdCovXG5cdFx0cnVuQXNQcm9taXNlKCgpID0+IHRoaXMudXNlckZuVG9SdW4odGhpcy5mbkFyZykpLmZpbmFsbHkoYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJNZW1vaXphdGlvbj8uKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5iZWZvcmVFeGVjdXRpb24/LigpO1xuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJFeGVjdXRpb24/LigpO1xuXHRcdH0pLnRoZW4oKGRhdGEpID0+IHtcblx0XHRcdHRoaXMuc3RhdGUuc2V0Q2hlY2twb2ludCh7XG5cdFx0XHRcdHR5cGU6IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIixcblx0XHRcdFx0ZGF0YVxuXHRcdFx0fSk7XG5cdFx0fSkuY2F0Y2goKGVycm9yKSA9PiB7XG5cdFx0XHR0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuXHRcdFx0XHR0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gaW5wdXQgYmVmb3JlIHJ1bm5pbmcuXG5cdCovXG5cdGFzeW5jIHRyYW5zZm9ybUlucHV0KCkge1xuXHRcdGNvbnN0IGlucHV0TXV0YXRpb25zID0gYXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8udHJhbnNmb3JtSW5wdXQ/Lih7XG5cdFx0XHRjdHg6IHsgLi4udGhpcy5mbkFyZyB9LFxuXHRcdFx0c3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5zdGVwU3RhdGUpLFxuXHRcdFx0Zm46IHRoaXMub3B0aW9ucy5mbixcblx0XHRcdHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzXG5cdFx0fSk7XG5cdFx0aWYgKGlucHV0TXV0YXRpb25zPy5jdHgpIHRoaXMuZm5BcmcgPSBpbnB1dE11dGF0aW9ucy5jdHg7XG5cdFx0aWYgKGlucHV0TXV0YXRpb25zPy5zdGVwcykgdGhpcy5zdGF0ZS5zdGVwU3RhdGUgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5wdXRNdXRhdGlvbnMuc3RlcHMubWFwKChzdGVwKSA9PiBbc3RlcC5pZCwgc3RlcF0pKTtcblx0fVxuXHQvKipcblx0KiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gb3V0cHV0IGJlZm9yZSByZXR1cm5pbmcuXG5cdCovXG5cdGFzeW5jIHRyYW5zZm9ybU91dHB1dChkYXRhT3JFcnJvcikge1xuXHRcdGNvbnN0IG91dHB1dCA9IHsgLi4uZGF0YU9yRXJyb3IgfTtcblx0XHRjb25zdCBpc1N0ZXBFeGVjdXRpb24gPSBCb29sZWFuKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCk7XG5cdFx0Y29uc3QgdHJhbnNmb3JtZWRPdXRwdXQgPSBhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy50cmFuc2Zvcm1PdXRwdXQ/Lih7XG5cdFx0XHRyZXN1bHQ6IHsgLi4ub3V0cHV0IH0sXG5cdFx0XHRzdGVwOiB0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXBcblx0XHR9KTtcblx0XHRjb25zdCB7IGRhdGEsIGVycm9yIH0gPSB7XG5cdFx0XHQuLi5vdXRwdXQsXG5cdFx0XHQuLi50cmFuc2Zvcm1lZE91dHB1dD8ucmVzdWx0XG5cdFx0fTtcblx0XHRpZiAoIWlzU3RlcEV4ZWN1dGlvbikgYXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uZmluaXNoZWQ/Lih7IHJlc3VsdDogeyAuLi50eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIgPyB7IGVycm9yIH0gOiB7IGRhdGEgfSB9IH0pO1xuXHRcdGlmICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdC8qKlxuXHRcdFx0KiBFbnN1cmUgd2UgZ2l2ZSBtaWRkbGV3YXJlIHRoZSBjaGFuY2UgdG8gZGVjaWRlIG9uIHJldHJpYWJsZSBiZWhhdmlvdXJcblx0XHRcdCogYnkgbG9va2luZyBhdCB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSBvdXRwdXQgdHJhbnNmb3JtYXRpb24uXG5cdFx0XHQqL1xuXHRcdFx0bGV0IHJldHJpYWJsZSA9ICEoZXJyb3IgaW5zdGFuY2VvZiBOb25SZXRyaWFibGVFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIFN0ZXBFcnJvciAmJiBlcnJvciA9PT0gdGhpcy5zdGF0ZS5yZWNlbnRseVJlamVjdGVkU3RlcEVycm9yKTtcblx0XHRcdGlmIChyZXRyaWFibGUgJiYgZXJyb3IgaW5zdGFuY2VvZiBSZXRyeUFmdGVyRXJyb3IpIHJldHJpYWJsZSA9IGVycm9yLnJldHJ5QWZ0ZXI7XG5cdFx0XHRjb25zdCBzZXJpYWxpemVkRXJyb3IgPSBtaW5pZnlQcmV0dHlFcnJvcihzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLFxuXHRcdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRcdG9wczogdGhpcy5vcHMsXG5cdFx0XHRcdGVycm9yOiBzZXJpYWxpemVkRXJyb3IsXG5cdFx0XHRcdHJldHJpYWJsZVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIixcblx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdG9wczogdGhpcy5vcHMsXG5cdFx0XHRkYXRhOiB1bmRlZmluZWRUb051bGwoZGF0YSlcblx0XHR9O1xuXHR9XG5cdGNyZWF0ZUV4ZWN1dGlvblN0YXRlKCkge1xuXHRcdGNvbnN0IGQgPSBjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2soKTtcblx0XHRsZXQgY2hlY2twb2ludFJlc29sdmUgPSBkLmRlZmVycmVkLnJlc29sdmU7XG5cdFx0Y29uc3QgY2hlY2twb2ludFJlc3VsdHMgPSBkLnJlc3VsdHM7XG5cdFx0Y29uc3QgbG9vcCA9IChhc3luYyBmdW5jdGlvbiogKGNsZWFuVXApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzID0gKGF3YWl0IGNoZWNrcG9pbnRSZXN1bHRzLm5leHQoKSkudmFsdWU7XG5cdFx0XHRcdFx0aWYgKHJlcykgeWllbGQgcmVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRjbGVhblVwPy4oKTtcblx0XHRcdH1cblx0XHR9KSgoKSA9PiB7XG5cdFx0XHR0aGlzLnRpbWVvdXQ/LmNsZWFyKCk7XG5cdFx0XHRjaGVja3BvaW50UmVzdWx0cy5yZXR1cm4oKTtcblx0XHR9KTtcblx0XHRjb25zdCBzdGVwc1RvRnVsZmlsbCA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLmxlbmd0aDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RlcFN0YXRlOiB0aGlzLm9wdGlvbnMuc3RlcFN0YXRlLFxuXHRcdFx0c3RlcHNUb0Z1bGZpbGwsXG5cdFx0XHRzdGVwczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcblx0XHRcdGxvb3AsXG5cdFx0XHRoYXNTdGVwczogQm9vbGVhbihzdGVwc1RvRnVsZmlsbCksXG5cdFx0XHRzdGVwQ29tcGxldGlvbk9yZGVyOiBbLi4udGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXJdLFxuXHRcdFx0cmVtYWluaW5nU3RlcHNUb0JlU2VlbjogbmV3IFNldCh0aGlzLm9wdGlvbnMuc3RlcENvbXBsZXRpb25PcmRlciksXG5cdFx0XHRzZXRDaGVja3BvaW50OiAoY2hlY2twb2ludCkgPT4ge1xuXHRcdFx0XHQoe3Jlc29sdmU6IGNoZWNrcG9pbnRSZXNvbHZlfSA9IGNoZWNrcG9pbnRSZXNvbHZlKGNoZWNrcG9pbnQpKTtcblx0XHRcdH0sXG5cdFx0XHRhbGxTdGF0ZVVzZWQ6ICgpID0+IHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RhdGUucmVtYWluaW5nU3RlcHNUb0JlU2Vlbi5zaXplID09PSAwO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0Z2V0IG9wcygpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc3RhdGUuc3RlcHMpO1xuXHR9XG5cdGNyZWF0ZUZuQXJnKCkge1xuXHRcdGNvbnN0IHN0ZXAgPSB0aGlzLmNyZWF0ZVN0ZXBUb29scygpO1xuXHRcdGxldCBmbkFyZyA9IHtcblx0XHRcdC4uLnRoaXMub3B0aW9ucy5kYXRhLFxuXHRcdFx0c3RlcFxuXHRcdH07XG5cdFx0LyoqXG5cdFx0KiBIYW5kbGUgdXNlIG9mIHRoZSBgb25GYWlsdXJlYCBvcHRpb24gYnkgZGVzZXJpYWxpemluZyB0aGUgZXJyb3IuXG5cdFx0Ki9cblx0XHRpZiAodGhpcy5vcHRpb25zLmlzRmFpbHVyZUhhbmRsZXIpIHtcblx0XHRcdGNvbnN0IGV2ZW50RGF0YSA9IHoub2JqZWN0KHsgZXJyb3I6IGpzb25FcnJvclNjaGVtYSB9KS5wYXJzZShmbkFyZy5ldmVudD8uZGF0YSk7XG5cdFx0XHRmbkFyZyA9IHtcblx0XHRcdFx0Li4uZm5BcmcsXG5cdFx0XHRcdGVycm9yOiBkZXNlcmlhbGl6ZUVycm9yKGV2ZW50RGF0YS5lcnJvcilcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMudHJhbnNmb3JtQ3R4Py4oZm5BcmcpID8/IGZuQXJnO1xuXHR9XG5cdGNyZWF0ZVN0ZXBUb29scygpIHtcblx0XHQvKipcblx0XHQqIEEgbGlzdCBvZiBzdGVwcyB0aGF0IGhhdmUgYmVlbiBmb3VuZCBhbmQgYXJlIGJlaW5nIHJvbGxlZCB1cCBiZWZvcmUgYmVpbmdcblx0XHQqIHJlcG9ydGVkIHRvIHRoZSBjb3JlIGxvb3AuXG5cdFx0Ki9cblx0XHRjb25zdCBmb3VuZFN0ZXBzVG9SZXBvcnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHRcdC8qKlxuXHRcdCogQSBtYXAgb2YgdGhlIHN1YnNldCBvZiBmb3VuZCBzdGVwcyB0byByZXBvcnQgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuXHRcdCogaGFuZGxlZC4gVXNlZCBmb3IgZmFzdCBhY2Nlc3MgdG8gc3RlcHMgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQgaW4gb3JkZXIuXG5cdFx0Ki9cblx0XHRjb25zdCB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHRcdC8qKlxuXHRcdCogQSBtYXAgb2YgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXhlcyBmb3VuZCBmb3IgZWFjaCBzdGVwIElELiBVc2VkXG5cdFx0KiB0byBlbnN1cmUgdGhhdCB3ZSBkb24ndCBpbmRleCBzdGVwcyBpbiBwYXJhbGxlbC5cblx0XHQqXG5cdFx0KiBOb3RlIHRoYXQgdGhlc2UgbXVzdCBiZSBzZXF1ZW50aWFsOyBpZiB3ZSd2ZSBzZWVuIG9yIGFzc2lnbmVkIGBhOjFgLFxuXHRcdCogYGE6MmAgYW5kIGBhOjRgLCB0aGUgbGF0ZXN0IHNlcXVlbnRpYWwgc3RlcCBpbmRleCBpcyBgMmAuXG5cdFx0KlxuXHRcdCovXG5cdFx0Y29uc3QgZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHRcdC8qKlxuXHRcdCogQW4gb3JkZXJlZCBsaXN0IG9mIHN0ZXAgSURzIHRoYXQgaGF2ZSB5ZXQgdG8gYmUgaGFuZGxlZCBpbiB0aGlzXG5cdFx0KiBleGVjdXRpb24uIFVzZWQgdG8gZW5zdXJlIHRoYXQgd2UgaGFuZGxlIHN0ZXBzIGluIHRoZSBvcmRlciB0aGV5IHdlcmVcblx0XHQqIGZvdW5kIGFuZCBiYXNlZCBvbiB0aGUgYHN0ZXBDb21wbGV0aW9uT3JkZXJgIGluIHRoaXMgZXhlY3V0aW9uJ3Mgc3RhdGUuXG5cdFx0Ki9cblx0XHRjb25zdCByZW1haW5pbmdTdGVwQ29tcGxldGlvbk9yZGVyID0gdGhpcy5zdGF0ZS5zdGVwQ29tcGxldGlvbk9yZGVyLnNsaWNlKCk7XG5cdFx0LyoqXG5cdFx0KiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gZW5zdXJlIHRoYXQgc3RlcCByZXBvcnRpbmcgY2Fubm90IGJlIHJ1biBtb3JlIHRoYW5cblx0XHQqIG9uY2UgaW4gYSBnaXZlbiBhc3luY2hyb25vdXMgdGltZSBzcGFuLlxuXHRcdCovXG5cdFx0bGV0IGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlO1xuXHRcdC8qKlxuXHRcdCogQSBwcm9taXNlIHRoYXQncyB1c2VkIHRvIHJlcHJlc2VudCBtaWRkbGV3YXJlIGhvb2tzIHJ1bm5pbmcgYmVmb3JlXG5cdFx0KiBleGVjdXRpb24uXG5cdFx0Ki9cblx0XHRsZXQgYmVmb3JlRXhlY0hvb2tzUHJvbWlzZTtcblx0XHQvKipcblx0XHQqIEEgZmxhZyB1c2VkIHRvIGVuc3VyZSB0aGF0IHdlIG9ubHkgd2FybiBhYm91dCBwYXJhbGxlbCBpbmRleGluZyBvbmNlIHBlclxuXHRcdCogZXhlY3V0aW9uIHRvIGF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlLlxuXHRcdCovXG5cdFx0bGV0IHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSBmYWxzZTtcblx0XHQvKipcblx0XHQqIENvdW50cyB0aGUgbnVtYmVyIG9mIHRpbWVzIHdlJ3ZlIGV4dGVuZGVkIHRoaXMgdGljay5cblx0XHQqL1xuXHRcdGxldCB0aWNrRXh0ZW5zaW9uQ291bnQgPSAwO1xuXHRcdC8qKlxuXHRcdCogR2l2ZW4gYSBjb2xsaWRpbmcgc3RlcCBJRCwgbWF5YmUgd2FybiB0aGUgdXNlciBhYm91dCBwYXJhbGxlbCBpbmRleGluZy5cblx0XHQqL1xuXHRcdGNvbnN0IG1heWJlV2Fybk9mUGFyYWxsZWxJbmRleGluZyA9IChjb2xsaXNpb25JZCkgPT4ge1xuXHRcdFx0aWYgKHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcpIHJldHVybjtcblx0XHRcdGlmICh0aGlzLnN0YXRlLnN0ZXBzLmhhcyhjb2xsaXNpb25JZCkpIHtcblx0XHRcdFx0aWYgKCFmb3VuZFN0ZXBzVG9SZXBvcnQuaGFzKGNvbGxpc2lvbklkKSkge1xuXHRcdFx0XHRcdHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihwcmV0dHlFcnJvcih7XG5cdFx0XHRcdFx0XHR0eXBlOiBcIndhcm5cIixcblx0XHRcdFx0XHRcdHdoYXRIYXBwZW5lZDogXCJXZSBkZXRlY3RlZCB0aGF0IHlvdSBoYXZlIG11bHRpcGxlIHN0ZXBzIHdpdGggdGhlIHNhbWUgSUQuXCIsXG5cdFx0XHRcdFx0XHRjb2RlOiBFcnJDb2RlLkFVVE9NQVRJQ19QQVJBTExFTF9JTkRFWElORyxcblx0XHRcdFx0XHRcdHdoeTogYFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UncmUgdXNpbmcgdGhlIHNhbWUgSUQgZm9yIG11bHRpcGxlIHN0ZXBzIGFjcm9zcyBkaWZmZXJlbnQgY2hhaW5zIG9mIHBhcmFsbGVsIHdvcmsuIFdlIGZvdW5kIHRoZSBpc3N1ZSB3aXRoIHN0ZXAgXCIke2NvbGxpc2lvbklkfVwiLmAsXG5cdFx0XHRcdFx0XHRyZWFzc3VyYW5jZTogXCJZb3VyIGZ1bmN0aW9uIGlzIHN0aWxsIHJ1bm5pbmcsIHRob3VnaCBpdCBtYXkgZXhoaWJpdCB1bmV4cGVjdGVkIGJlaGF2aW91ci5cIixcblx0XHRcdFx0XHRcdGNvbnNlcXVlbmNlczogXCJVc2luZyB0aGUgc2FtZSBJRHMgYWNyb3NzIHBhcmFsbGVsIGNoYWlucyBvZiB3b3JrIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ci5cIixcblx0XHRcdFx0XHRcdHRvRml4Tm93OiBcIldlIHJlY29tbWVuZCB1c2luZyBhIHVuaXF1ZSBJRCBmb3IgZWFjaCBzdGVwLCBlc3BlY2lhbGx5IHRob3NlIGhhcHBlbmluZyBpbiBwYXJhbGxlbC5cIlxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0KiBBIGhlbHBlciB1c2VkIHRvIHJlcG9ydCBzdGVwcyB0byB0aGUgY29yZSBsb29wLiBVc2VkIGFmdGVyIGFkZGluZyBhbiBpdGVtXG5cdFx0KiB0byBgZm91bmRTdGVwc1RvUmVwb3J0YC5cblx0XHQqL1xuXHRcdGNvbnN0IHJlcG9ydE5leHRUaWNrID0gKCkgPT4ge1xuXHRcdFx0aWYgKGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlKSByZXR1cm47XG5cdFx0XHRsZXQgZXh0ZW5zaW9uUHJvbWlzZTtcblx0XHRcdGlmICgrK3RpY2tFeHRlbnNpb25Db3VudCA+PSAxMCkge1xuXHRcdFx0XHR0aWNrRXh0ZW5zaW9uQ291bnQgPSAwO1xuXHRcdFx0XHRleHRlbnNpb25Qcm9taXNlID0gcmVzb2x2ZU5leHRUaWNrKCk7XG5cdFx0XHR9IGVsc2UgZXh0ZW5zaW9uUHJvbWlzZSA9IHJlc29sdmVBZnRlclBlbmRpbmcoKTtcblx0XHRcdGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gZXh0ZW5zaW9uUHJvbWlzZS50aGVuKCgpID0+IGJlZm9yZUV4ZWNIb29rc1Byb21pc2UpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSA9IHZvaWQgMDtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZW1haW5pbmdTdGVwQ29tcGxldGlvbk9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgbmV4dFN0ZXBJZCA9IHJlbWFpbmluZ1N0ZXBDb21wbGV0aW9uT3JkZXJbaV07XG5cdFx0XHRcdFx0aWYgKCFuZXh0U3RlcElkKSBjb250aW51ZTtcblx0XHRcdFx0XHRpZiAodW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0LmdldChuZXh0U3RlcElkKT8uaGFuZGxlKCkpIHtcblx0XHRcdFx0XHRcdHJlbWFpbmluZ1N0ZXBDb21wbGV0aW9uT3JkZXIuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0dW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0LmRlbGV0ZShuZXh0U3RlcElkKTtcblx0XHRcdFx0XHRcdHJlcG9ydE5leHRUaWNrKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHN0ZXBzID0gWy4uLmZvdW5kU3RlcHNUb1JlcG9ydC52YWx1ZXMoKV07XG5cdFx0XHRcdGZvdW5kU3RlcHNUb1JlcG9ydC5jbGVhcigpO1xuXHRcdFx0XHR1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuY2xlYXIoKTtcblx0XHRcdFx0dGhpcy5zdGF0ZS5zZXRDaGVja3BvaW50KHtcblx0XHRcdFx0XHR0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG5cdFx0XHRcdFx0c3RlcHNcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCogQSBoZWxwZXIgdXNlZCB0byBwdXNoIGEgc3RlcCB0byB0aGUgbGlzdCBvZiBzdGVwcyB0byByZXBvcnQuXG5cdFx0Ki9cblx0XHRjb25zdCBwdXNoU3RlcFRvUmVwb3J0ID0gKHN0ZXApID0+IHtcblx0XHRcdGZvdW5kU3RlcHNUb1JlcG9ydC5zZXQoc3RlcC5pZCwgc3RlcCk7XG5cdFx0XHR1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuc2V0KHN0ZXAuaGFzaGVkSWQsIHN0ZXApO1xuXHRcdFx0cmVwb3J0TmV4dFRpY2soKTtcblx0XHR9O1xuXHRcdGNvbnN0IHN0ZXBIYW5kbGVyID0gYXN5bmMgKHsgYXJncywgbWF0Y2hPcCwgb3B0cyB9KSA9PiB7XG5cdFx0XHRhd2FpdCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuXHRcdFx0Y29uc3Qgb3BJZCA9IG1hdGNoT3AoZ2V0U3RlcE9wdGlvbnMoYXJnc1swXSksIC4uLmFyZ3Muc2xpY2UoMSkpO1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcClcbiAvKipcblx0XHRcdCogSWYgYSBzdGVwIGlzIGZvdW5kIGFmdGVyIGFzeW5jaHJvbm91cyBhY3Rpb25zIGR1cmluZyBhbm90aGVyIHN0ZXAnc1xuXHRcdFx0KiBleGVjdXRpb24sIGV2ZXJ5dGhpbmcgaXMgZmluZS4gVGhlIHByb2JsZW0gaGVyZSBpcyBpZiB3ZSd2ZSBmb3VuZFxuXHRcdFx0KiB0aGF0IGEgc3RlcCBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgYSBzdGVwLCB3aGljaCBpcyBzb21ldGhpbmcgd2UgZG9uJ3Rcblx0XHRcdCogc3VwcG9ydCBhdCB0aGUgdGltZSBvZiB3cml0aW5nLlxuXHRcdFx0KlxuXHRcdFx0KiBJbiB0aGlzIGNhc2UsIHdlIGNvdWxkIHVzZSBzb21ldGhpbmcgbGlrZSBBc3luYyBIb29rcyB0byB1bmRlcnN0YW5kXG5cdFx0XHQqIGhvdyB0aGUgc3RlcCBpcyBiZWluZyB0cmlnZ2VyZWQsIHRob3VnaCB0aGlzIGlzbid0IGF2YWlsYWJsZSBpbiBhbGxcblx0XHRcdCogZW52aXJvbm1lbnRzLlxuXHRcdFx0KlxuXHRcdFx0KiBUaGVyZWZvcmUsIHdlJ2xsIG9ubHkgc2hvdyBhIHdhcm5pbmcgaGVyZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgaXNcblx0XHRcdCogcG90ZW50aWFsbHkgYW4gaXNzdWUuXG5cdFx0XHQqL1xuXHRcdFx0Y29uc29sZS53YXJuKHByZXR0eUVycm9yKHtcblx0XHRcdFx0d2hhdEhhcHBlbmVkOiBgV2UgZGV0ZWN0ZWQgdGhhdCB5b3UgaGF2ZSBuZXN0ZWQgXFxgc3RlcC4qXFxgIHRvb2xpbmcgaW4gXFxgJHtvcElkLmRpc3BsYXlOYW1lID8/IG9wSWQuaWR9XFxgYCxcblx0XHRcdFx0Y29uc2VxdWVuY2VzOiBcIk5lc3RpbmcgYHN0ZXAuKmAgdG9vbGluZyBpcyBub3Qgc3VwcG9ydGVkLlwiLFxuXHRcdFx0XHR0eXBlOiBcIndhcm5cIixcblx0XHRcdFx0cmVhc3N1cmFuY2U6IFwiSXQncyBwb3NzaWJsZSB0byBzZWUgdGhpcyB3YXJuaW5nIGlmIHN0ZXBzIGFyZSBzZXBhcmF0ZWQgYnkgcmVndWxhciBhc3luY2hyb25vdXMgY2FsbHMsIHdoaWNoIGlzIGZpbmUuXCIsXG5cdFx0XHRcdHN0YWNrOiB0cnVlLFxuXHRcdFx0XHR0b0ZpeE5vdzogXCJNYWtlIHN1cmUgeW91J3JlIG5vdCB1c2luZyBgc3RlcC4qYCB0b29saW5nIGluc2lkZSBvZiBvdGhlciBgc3RlcC4qYCB0b29saW5nLiBJZiB5b3UgbmVlZCB0byBjb21wb3NlIHN0ZXBzIHRvZ2V0aGVyLCB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBhc3luYyBmdW5jdGlvbiBhbmQgY2FsbCBpdCBmcm9tIHdpdGhpbiB5b3VyIHN0ZXAgZnVuY3Rpb24sIG9yIHVzZSBwcm9taXNlIGNoYWluaW5nLlwiLFxuXHRcdFx0XHRjb2RlOiBFcnJDb2RlLk5FU1RJTkdfU1RFUFNcblx0XHRcdH0pKTtcblx0XHRcdGlmICh0aGlzLnN0YXRlLnN0ZXBzLmhhcyhvcElkLmlkKSkge1xuXHRcdFx0XHRjb25zdCBvcmlnaW5hbElkID0gb3BJZC5pZDtcblx0XHRcdFx0bWF5YmVXYXJuT2ZQYXJhbGxlbEluZGV4aW5nKG9yaWdpbmFsSWQpO1xuXHRcdFx0XHRjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLmdldChvcmlnaW5hbElkKSA/PyAxO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gZXhwZWN0ZWROZXh0SW5kZXg7OyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBuZXdJZCA9IG9yaWdpbmFsSWQgKyBTVEVQX0lOREVYSU5HX1NVRkZJWCArIGk7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLnN0ZXBzLmhhcyhuZXdJZCkpIHtcblx0XHRcdFx0XHRcdGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLnNldChvcmlnaW5hbElkLCBpICsgMSk7XG5cdFx0XHRcdFx0XHRvcElkLmlkID0gbmV3SWQ7XG5cdFx0XHRcdFx0XHRvcElkLnVzZXJsYW5kLmluZGV4ID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpO1xuXHRcdFx0Y29uc3QgaGFzaGVkSWQgPSBfaW50ZXJuYWxzLmhhc2hJZChvcElkLmlkKTtcblx0XHRcdGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMuc3RhdGUuc3RlcFN0YXRlW2hhc2hlZElkXTtcblx0XHRcdGxldCBpc0Z1bGZpbGxlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHN0ZXBTdGF0ZSkge1xuXHRcdFx0XHRzdGVwU3RhdGUuc2VlbiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuc3RhdGUucmVtYWluaW5nU3RlcHNUb0JlU2Vlbi5kZWxldGUoaGFzaGVkSWQpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHN0ZXBTdGF0ZS5pbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikgaXNGdWxmaWxsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGV4dHJhT3B0cztcblx0XHRcdGxldCBmbkFyZ3MgPSBbLi4uYXJnc107XG5cdFx0XHRpZiAodHlwZW9mIHN0ZXBTdGF0ZT8uaW5wdXQgIT09IFwidW5kZWZpbmVkXCIgJiYgQXJyYXkuaXNBcnJheShzdGVwU3RhdGUuaW5wdXQpKSBzd2l0Y2ggKG9wSWQub3ApIHtcblx0XHRcdFx0Y2FzZSBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkOlxuXHRcdFx0XHRcdGZuQXJncyA9IFsuLi5hcmdzLnNsaWNlKDAsIDIpLCAuLi5zdGVwU3RhdGUuaW5wdXRdO1xuXHRcdFx0XHRcdGV4dHJhT3B0cyA9IHsgaW5wdXQ6IFsuLi5zdGVwU3RhdGUuaW5wdXRdIH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3RlcE9wQ29kZS5BaUdhdGV3YXk6XG5cdFx0XHRcdFx0ZXh0cmFPcHRzID0geyBib2R5OiB7XG5cdFx0XHRcdFx0XHQuLi50eXBlb2Ygb3BJZC5vcHRzPy5ib2R5ID09PSBcIm9iamVjdFwiID8geyAuLi5vcElkLm9wdHMuYm9keSB9IDoge30sXG5cdFx0XHRcdFx0XHQuLi5zdGVwU3RhdGUuaW5wdXRbMF1cblx0XHRcdFx0XHR9IH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBzdGVwID0ge1xuXHRcdFx0XHQuLi5vcElkLFxuXHRcdFx0XHRvcHRzOiB7XG5cdFx0XHRcdFx0Li4ub3BJZC5vcHRzLFxuXHRcdFx0XHRcdC4uLmV4dHJhT3B0c1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyYXdBcmdzOiBmbkFyZ3MsXG5cdFx0XHRcdGhhc2hlZElkLFxuXHRcdFx0XHRpbnB1dDogc3RlcFN0YXRlPy5pbnB1dCxcblx0XHRcdFx0Zm46IG9wdHM/LmZuID8gKCkgPT4gb3B0cy5mbj8uKC4uLmZuQXJncykgOiB2b2lkIDAsXG5cdFx0XHRcdHByb21pc2UsXG5cdFx0XHRcdGZ1bGZpbGxlZDogaXNGdWxmaWxsZWQsXG5cdFx0XHRcdGhhc1N0ZXBTdGF0ZTogQm9vbGVhbihzdGVwU3RhdGUpLFxuXHRcdFx0XHRkaXNwbGF5TmFtZTogb3BJZC5kaXNwbGF5TmFtZSA/PyBvcElkLmlkLFxuXHRcdFx0XHRoYW5kbGVkOiBmYWxzZSxcblx0XHRcdFx0aGFuZGxlOiAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHN0ZXAuaGFuZGxlZCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHN0ZXAuaGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gdGhpcy5zdGF0ZS5zdGVwU3RhdGVbaGFzaGVkSWRdO1xuXHRcdFx0XHRcdGlmIChzdGVwLmZ1bGZpbGxlZCAmJiByZXN1bHQpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5mdWxmaWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0UHJvbWlzZS5hbGwoW1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQuZGF0YSxcblx0XHRcdFx0XHRcdFx0cmVzdWx0LmVycm9yLFxuXHRcdFx0XHRcdFx0XHRyZXN1bHQuaW5wdXRcblx0XHRcdFx0XHRcdF0pLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlc3VsdC5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSByZXNvbHZlKHJlc3VsdC5kYXRhKTtcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5yZWNlbnRseVJlamVjdGVkU3RlcEVycm9yID0gbmV3IFN0ZXBFcnJvcihvcElkLmlkLCByZXN1bHQuZXJyb3IpO1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdCh0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR0aGlzLnN0YXRlLnN0ZXBzLnNldChvcElkLmlkLCBzdGVwKTtcblx0XHRcdHRoaXMuc3RhdGUuaGFzU3RlcHMgPSB0cnVlO1xuXHRcdFx0cHVzaFN0ZXBUb1JlcG9ydChzdGVwKTtcblx0XHRcdC8qKlxuXHRcdFx0KiBJZiB0aGlzIGlzIHRoZSBsYXN0IHBpZWNlIG9mIHN0YXRlIHdlIGhhZCwgd2UndmUgbm93IGZpbmlzaGVkXG5cdFx0XHQqIG1lbW9pemluZy5cblx0XHRcdCovXG5cdFx0XHRpZiAoIWJlZm9yZUV4ZWNIb29rc1Byb21pc2UgJiYgdGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkgYXdhaXQgKGJlZm9yZUV4ZWNIb29rc1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5hZnRlck1lbW9pemF0aW9uPy4oKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYmVmb3JlRXhlY3V0aW9uPy4oKTtcblx0XHRcdH0pKCkpO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0XHRyZXR1cm4gY3JlYXRlU3RlcFRvb2xzKHRoaXMub3B0aW9ucy5jbGllbnQsIHRoaXMsIHN0ZXBIYW5kbGVyKTtcblx0fVxuXHRnZXRVc2VyRm5Ub1J1bigpIHtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wiZm5cIl07XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXSlcbiAvKipcblx0XHQqIFNvbWVob3csIHdlJ3ZlIGVuZGVkIHVwIGRldGVjdGluZyB0aGF0IHRoaXMgaXMgYSBmYWlsdXJlIGhhbmRsZXIgYnV0XG5cdFx0KiBkb2Vzbid0IGhhdmUgYW4gYG9uRmFpbHVyZWAgZnVuY3Rpb24uIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cblx0XHQqL1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZ1bmN0aW9uIGBvbkZhaWx1cmVgIGhhbmRsZXJcIik7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5mbltcIm9uRmFpbHVyZUZuXCJdO1xuXHR9XG5cdGluaXRpYWxpemVUaW1lcihzdGF0ZSkge1xuXHRcdGlmICghdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHJldHVybjtcblx0XHR0aGlzLnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UHJvbWlzZSh0aGlzLnRpbWVvdXREdXJhdGlvbik7XG5cdFx0dGhpcy50aW1lb3V0LnRoZW4oYXN5bmMgKCkgPT4ge1xuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJNZW1vaXphdGlvbj8uKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5iZWZvcmVFeGVjdXRpb24/LigpO1xuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJFeGVjdXRpb24/LigpO1xuXHRcdFx0c3RhdGUuc2V0Q2hlY2twb2ludCh7XG5cdFx0XHRcdHR5cGU6IFwic3RlcC1ub3QtZm91bmRcIixcblx0XHRcdFx0c3RlcDoge1xuXHRcdFx0XHRcdGlkOiB0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCxcblx0XHRcdFx0XHRvcDogU3RlcE9wQ29kZS5TdGVwTm90Rm91bmRcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblx0YXN5bmMgaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKSB7XG5cdFx0Y29uc3QgY3R4ID0gdGhpcy5vcHRpb25zLmRhdGE7XG5cdFx0cmV0dXJuIGF3YWl0IGdldEhvb2tTdGFjayh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uRnVuY3Rpb25SdW5cIiwge1xuXHRcdFx0Y3R4LFxuXHRcdFx0Zm46IHRoaXMub3B0aW9ucy5mbixcblx0XHRcdHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5zdGVwU3RhdGUpLFxuXHRcdFx0cmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3Ncblx0XHR9LCB7XG5cdFx0XHR0cmFuc2Zvcm1JbnB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGN0eDoge1xuXHRcdFx0XHRcdFx0Li4ucHJldi5jdHgsXG5cdFx0XHRcdFx0XHQuLi5vdXRwdXQ/LmN0eFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Zm46IHRoaXMub3B0aW9ucy5mbixcblx0XHRcdFx0XHRzdGVwczogcHJldi5zdGVwcy5tYXAoKHN0ZXAsIGkpID0+ICh7XG5cdFx0XHRcdFx0XHQuLi5zdGVwLFxuXHRcdFx0XHRcdFx0Li4ub3V0cHV0Py5zdGVwcz8uW2ldXG5cdFx0XHRcdFx0fSkpLFxuXHRcdFx0XHRcdHJlcUFyZ3M6IHByZXYucmVxQXJnc1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdHRyYW5zZm9ybU91dHB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHJlc3VsdDoge1xuXHRcdFx0XHRcdFx0Li4ucHJldi5yZXN1bHQsXG5cdFx0XHRcdFx0XHQuLi5vdXRwdXQ/LnJlc3VsdFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3RlcDogcHJldi5zdGVwXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn07XG5jb25zdCBoYXNoSWQgPSAoaWQpID0+IHtcblx0cmV0dXJuIHNoYTEoKS51cGRhdGUoaWQpLmRpZ2VzdChcImhleFwiKTtcbn07XG5jb25zdCBoYXNoT3AgPSAob3ApID0+IHtcblx0cmV0dXJuIHtcblx0XHQuLi5vcCxcblx0XHRpZDogaGFzaElkKG9wLmlkKVxuXHR9O1xufTtcbi8qKlxuKiBFeHBvcnRlZCBmb3IgdGVzdGluZy5cbiovXG5jb25zdCBfaW50ZXJuYWxzID0ge1xuXHRoYXNoT3AsXG5cdGhhc2hJZFxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBfaW50ZXJuYWxzLCBjcmVhdGVWMUlubmdlc3RFeGVjdXRpb24sIHYxX2V4cG9ydHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXYxLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4cG9ydCIsImdldEFzeW5jQ3R4IiwiZ2V0QXN5bmNMb2NhbFN0b3JhZ2UiLCJ2ZXJzaW9uIiwiRXhlY3V0aW9uVmVyc2lvbiIsImhlYWRlcktleXMiLCJpbnRlcm5hbEV2ZW50cyIsIlN0ZXBNb2RlIiwiU3RlcE9wQ29kZSIsImpzb25FcnJvclNjaGVtYSIsIklubmdlc3RFeGVjdXRpb24iLCJOb25SZXRyaWFibGVFcnJvciIsIkVyckNvZGUiLCJkZXNlcmlhbGl6ZUVycm9yIiwibWluaWZ5UHJldHR5RXJyb3IiLCJwcmV0dHlFcnJvciIsInNlcmlhbGl6ZUVycm9yIiwidW5kZWZpbmVkVG9OdWxsIiwiZ2V0SG9va1N0YWNrIiwiY2xpZW50UHJvY2Vzc29yTWFwIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrIiwiY3JlYXRlVGltZW91dFByb21pc2UiLCJyZXNvbHZlQWZ0ZXJQZW5kaW5nIiwicmVzb2x2ZU5leHRUaWNrIiwicnVuQXNQcm9taXNlIiwiUmV0cnlBZnRlckVycm9yIiwiU3RlcEVycm9yIiwiU1RFUF9JTkRFWElOR19TVUZGSVgiLCJjcmVhdGVTdGVwVG9vbHMiLCJnZXRTdGVwT3B0aW9ucyIsImludm9rZVBheWxvYWRTY2hlbWEiLCJ6IiwidHJhY2UiLCJoYXNoanMiLCJ2MV9leHBvcnRzIiwiX2ludGVybmFscyIsImNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbiIsInNoYTEiLCJvcHRpb25zIiwiVjFJbm5nZXN0RXhlY3V0aW9uIiwiY29uc3RydWN0b3IiLCJWMSIsInRpbWVvdXREdXJhdGlvbiIsInN0ZXBNb2RlIiwiU3luYyIsImNyZWF0ZVJlc3BvbnNlIiwiRXJyb3IiLCJ1c2VyRm5Ub1J1biIsImdldFVzZXJGblRvUnVuIiwic3RhdGUiLCJjcmVhdGVFeGVjdXRpb25TdGF0ZSIsImZuQXJnIiwiY3JlYXRlRm5BcmciLCJjaGVja3BvaW50SGFuZGxlcnMiLCJjcmVhdGVDaGVja3BvaW50aW5nQ2hlY2twb2ludEhhbmRsZXJzIiwiY3JlYXRlQ2hlY2twb2ludEhhbmRsZXJzIiwiaW5pdGlhbGl6ZVRpbWVyIiwiZGVidWciLCJyZXF1ZXN0ZWRSdW5TdGVwIiwiT2JqZWN0Iiwia2V5cyIsInN0ZXBTdGF0ZSIsInN0YXJ0IiwiZXhlY3V0aW9uIiwidHJhY2VyIiwiZ2V0VHJhY2VyIiwidGhlbiIsImFscyIsInJ1biIsImFwcCIsImNsaWVudCIsImN0eCIsImluc3RhbmNlIiwic3RhcnRBY3RpdmVTcGFuIiwic3BhbiIsImdldCIsImRlY2xhcmVTdGFydGluZ1NwYW4iLCJydW5JZCIsInRyYWNlcGFyZW50IiwiaGVhZGVycyIsIlRyYWNlUGFyZW50IiwidHJhY2VzdGF0ZSIsIlRyYWNlU3RhdGUiLCJfc3RhcnQiLCJyZXN1bHQiLCJmaW5hbGx5IiwiZW5kIiwiYWxsQ2hlY2twb2ludEhhbmRsZXIiLCJnZXRDaGVja3BvaW50SGFuZGxlciIsImhvb2tzIiwiaW5pdGlhbGl6ZU1pZGRsZXdhcmUiLCJzdGFydEV4ZWN1dGlvbiIsImkiLCJjaGVja3BvaW50IiwibG9vcCIsInR5cGUiLCJlcnJvciIsInRyYW5zZm9ybU91dHB1dCIsInJldHVybiIsImJlZm9yZVJlc3BvbnNlIiwic3RlcHMiLCJjaGVja3BvaW50ZWRSdW4iLCJyZXMiLCJjaGVja3BvaW50TmV3UnVuIiwiZXZlbnQiLCJhcHBJZCIsImRhdGEiLCJhcHBfaWQiLCJmbklkIiwiZm5faWQiLCJ0b2tlbiIsImNoZWNrcG9pbnRTdGVwcyIsImNoZWNrcG9pbnRBbmRTd2l0Y2hUb0FzeW5jIiwib3BzIiwidG8iLCJBc3luYyIsImluRmluYWxBdHRlbXB0IiwibWF4QXR0ZW1wdHMiLCJhdHRlbXB0Iiwib3AiLCJSdW5Db21wbGV0ZSIsImlkIiwiaGFzaElkIiwicmV0cmlhYmxlIiwiZGlzcGxheU5hbWUiLCJzdGVwIiwibGVuZ3RoIiwibW9kZSIsIm1hcCIsInN0ZXAkMSIsImhhc2hlZElkIiwiRGF0ZSIsIm5vdyIsImV4ZWN1dGVTdGVwIiwiaW50ZXJ2YWwiLCJhIiwiYiIsIlN0ZXBQbGFubmVkIiwiZnVsZmlsbGVkIiwiU3RlcFJ1biIsIm9wdHMiLCJ1c2VybGFuZCIsIm5hbWUiLCJ0aW1pbmciLCJoYW5kbGUiLCJzdGVwUmVzdWx0IiwidHJ5RXhlY3V0ZVN0ZXAiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJoYXNoT3AiLCJzdGVwRm9yUmVzcG9uc2UiLCJTdGVwRmFpbGVkIiwic2VyIiwiX19zZXJpYWxpemVkIiwibWVzc2FnZSIsInN0YWNrIiwibmV3U3RlcHMiLCJmaWx0ZXJOZXdTdGVwcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImhhc2hlZFN0ZXBJZFRvUnVuIiwiZ2V0RWFybHlFeGVjUnVuU3RlcCIsImZpbmQiLCJmbiIsInRpbWVvdXQiLCJyZXNldCIsImRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb24iLCJ1bmZ1bGZpbGxlZFN0ZXBzIiwiZmlsdGVyIiwiZm91bmRTdGVwcyIsImtub3duU3RlcHMiLCJzdGVwc1RvRnVsZmlsbCIsImNvbnNvbGUiLCJ3YXJuIiwid2hhdEhhcHBlbmVkIiwid2h5IiwiY29uc2VxdWVuY2VzIiwicmVhc3N1cmFuY2UiLCJhZnRlck1lbW9pemF0aW9uIiwiYmVmb3JlRXhlY3V0aW9uIiwiYWZ0ZXJFeGVjdXRpb24iLCJzdGVwTGlzdCIsInRyYW5zZm9ybU5ld1N0ZXBzIiwiUHJvbWlzZSIsImFsbCIsIkludm9rZUZ1bmN0aW9uIiwidHJhbnNmb3JtZWRQYXlsb2FkIiwidHJhbnNmb3JtSW5wdXQiLCJwcmV2Iiwib3V0cHV0IiwicGF5bG9hZHMiLCJwYXlsb2FkIiwiRnVuY3Rpb25JbnZva2VkIiwibmV3UGF5bG9hZCIsInBhcnNlIiwiY2xlYXIiLCJvdXRnb2luZ09wIiwiZXhlY3V0aW5nU3RlcCIsInN0b3JlIiwiY2F0Y2giLCJlcnJvcklzUmV0cmlhYmxlIiwiYmVmb3JlTWVtb2l6YXRpb24iLCJhbGxTdGF0ZVVzZWQiLCJzZXRDaGVja3BvaW50IiwiaW5wdXRNdXRhdGlvbnMiLCJyZXFBcmdzIiwiZnJvbUVudHJpZXMiLCJkYXRhT3JFcnJvciIsImlzU3RlcEV4ZWN1dGlvbiIsIkJvb2xlYW4iLCJ0cmFuc2Zvcm1lZE91dHB1dCIsImZpbmlzaGVkIiwicmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvciIsInJldHJ5QWZ0ZXIiLCJzZXJpYWxpemVkRXJyb3IiLCJkIiwiY2hlY2twb2ludFJlc29sdmUiLCJkZWZlcnJlZCIsInJlc29sdmUiLCJjaGVja3BvaW50UmVzdWx0cyIsInJlc3VsdHMiLCJjbGVhblVwIiwibmV4dCIsInZhbHVlIiwiTWFwIiwiaGFzU3RlcHMiLCJzdGVwQ29tcGxldGlvbk9yZGVyIiwicmVtYWluaW5nU3RlcHNUb0JlU2VlbiIsIlNldCIsInNpemUiLCJpc0ZhaWx1cmVIYW5kbGVyIiwiZXZlbnREYXRhIiwib2JqZWN0IiwidHJhbnNmb3JtQ3R4IiwiZm91bmRTdGVwc1RvUmVwb3J0IiwidW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0IiwiZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMiLCJyZW1haW5pbmdTdGVwQ29tcGxldGlvbk9yZGVyIiwic2xpY2UiLCJmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSIsImJlZm9yZUV4ZWNIb29rc1Byb21pc2UiLCJ3YXJuT2ZQYXJhbGxlbEluZGV4aW5nIiwidGlja0V4dGVuc2lvbkNvdW50IiwibWF5YmVXYXJuT2ZQYXJhbGxlbEluZGV4aW5nIiwiY29sbGlzaW9uSWQiLCJoYXMiLCJjb2RlIiwiQVVUT01BVElDX1BBUkFMTEVMX0lOREVYSU5HIiwidG9GaXhOb3ciLCJyZXBvcnROZXh0VGljayIsImV4dGVuc2lvblByb21pc2UiLCJuZXh0U3RlcElkIiwic3BsaWNlIiwiZGVsZXRlIiwicHVzaFN0ZXBUb1JlcG9ydCIsInNldCIsInN0ZXBIYW5kbGVyIiwiYXJncyIsIm1hdGNoT3AiLCJvcElkIiwiTkVTVElOR19TVEVQUyIsIm9yaWdpbmFsSWQiLCJleHBlY3RlZE5leHRJbmRleCIsIm5ld0lkIiwiaW5kZXgiLCJwcm9taXNlIiwicmVqZWN0IiwiaXNGdWxmaWxsZWQiLCJzZWVuIiwiaW5wdXQiLCJleHRyYU9wdHMiLCJmbkFyZ3MiLCJpc0FycmF5IiwiQWlHYXRld2F5IiwiYm9keSIsInJhd0FyZ3MiLCJoYXNTdGVwU3RhdGUiLCJoYW5kbGVkIiwiU3RlcE5vdEZvdW5kIiwidXBkYXRlIiwiZGlnZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v2.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v2.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createV2InngestExecution: () => (/* binding */ createV2InngestExecution),\n/* harmony export */   v2_exports: () => (/* binding */ v2_exports)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _als_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\n/* harmony import */ var _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _InngestExecution_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/* harmony import */ var _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\n/* harmony import */ var _helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var _helpers_functions_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/* harmony import */ var _InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/* harmony import */ var _otel_access_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\n/* harmony import */ var _helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/* harmony import */ var _RetryAfterError_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\n/* harmony import */ var _StepError_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\n/* harmony import */ var _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//#region src/components/execution/v2.ts\nvar v2_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_2__.__export)({\n    _internals: ()=>_internals,\n    createV2InngestExecution: ()=>createV2InngestExecution\n});\nconst { sha1 } = hash_js__WEBPACK_IMPORTED_MODULE_1__;\nconst createV2InngestExecution = (options)=>{\n    return new V2InngestExecution(options);\n};\nvar V2InngestExecution = class extends _InngestExecution_js__WEBPACK_IMPORTED_MODULE_3__.InngestExecution {\n    constructor(options){\n        super(options);\n        this.version = _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.ExecutionVersion.V2;\n        this.timeoutDuration = 1e3 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V2 execution for run;\", this.options.requestedRunStep ? `wanting to run step \"${this.options.requestedRunStep}\"` : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n\t* Idempotently start the execution of the user's function.\n\t*/ start() {\n        if (!this.execution) {\n            this.debug(\"starting V2 execution\");\n            const tracer = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.trace.getTracer(\"inngest\", _version_js__WEBPACK_IMPORTED_MODULE_5__.version);\n            this.execution = (0,_als_js__WEBPACK_IMPORTED_MODULE_6__.getAsyncLocalStorage)().then((als)=>{\n                return als.run({\n                    app: this.options.client,\n                    execution: {\n                        ctx: this.fnArg,\n                        instance: this\n                    }\n                }, async ()=>{\n                    return tracer.startActiveSpan(\"inngest.execution\", (span)=>{\n                        _otel_access_js__WEBPACK_IMPORTED_MODULE_7__.clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.TraceParent],\n                            tracestate: this.options.headers[_helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.headerKeys.TraceState]\n                        });\n                        return this._start().then((result)=>{\n                            this.debug(\"result:\", result);\n                            return result;\n                        }).finally(()=>{\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n\t* Starts execution of the user's function and the core loop.\n\t*/ async _start() {\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            for await (const checkpoint of this.state.loop){\n                await allCheckpointHandler(checkpoint);\n                const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint);\n                if (result) return result;\n            }\n        } catch (error) {\n            return await this.transformOutput({\n                error\n            });\n        } finally{\n            this.state.loop.return();\n            await this.state.hooks?.beforeResponse?.();\n        }\n        /**\n\t\t* If we're here, the generator somehow finished without returning a value.\n\t\t* This should never happen.\n\t\t*/ throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n\t* Creates a handler for every checkpoint type, defining what to do when we\n\t* reach that checkpoint in the core loop.\n\t*/ createCheckpointHandlers() {\n        return {\n            \"\": (checkpoint)=>{\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            \"function-resolved\": async (checkpoint)=>{\n                return await this.transformOutput({\n                    data: checkpoint.data\n                });\n            },\n            \"function-rejected\": async (checkpoint)=>{\n                return await this.transformOutput({\n                    error: checkpoint.error\n                });\n            },\n            \"steps-found\": async ({ steps })=>{\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n\t\t\t\t\t* Transforming output will always return either function rejection or\n\t\t\t\t\t* resolution. In most cases, this can be immediately returned, but in\n\t\t\t\t\t* this particular case we want to handle it differently.\n\t\t\t\t\t*/ if (transformResult.type === \"function-resolved\") return {\n                        type: \"step-ran\",\n                        ctx: transformResult.ctx,\n                        ops: transformResult.ops,\n                        step: _internals.hashOp({\n                            ...stepResult,\n                            data: transformResult.data\n                        })\n                    };\n                    else if (transformResult.type === \"function-rejected\") {\n                        const stepForResponse = _internals.hashOp({\n                            ...stepResult,\n                            error: transformResult.error\n                        });\n                        if (stepResult.op === _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepFailed) {\n                            const ser = (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.serializeError)(transformResult.error);\n                            stepForResponse.data = {\n                                __serialized: true,\n                                name: ser.name,\n                                message: ser.message,\n                                stack: \"\"\n                            };\n                        }\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            retriable: transformResult.retriable,\n                            step: stepForResponse\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) return {\n                    type: \"steps-found\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    steps: newSteps\n                };\n            },\n            \"step-not-found\": ({ step })=>{\n                return {\n                    type: \"step-not-found\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    step\n                };\n            }\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) return;\n        const step = steps.find((step$1)=>step$1.hashedId === hashedStepIdToRun && step$1.fn);\n        if (step) return await this.executeStep(step);\n        this.timeout?.reset();\n    }\n    /**\n\t* Given a list of outgoing ops, decide if we can execute an op early and\n\t* return the ID of the step to execute if we can.\n\t*/ getEarlyExecRunStep(steps) {\n        /**\n\t\t* We may have been disabled due to parallelism, in which case we can't\n\t\t* immediately execute unless explicitly requested.\n\t\t*/ if (this.options.disableImmediateExecution) return;\n        const unfulfilledSteps = steps.filter((step)=>!step.fulfilled);\n        if (unfulfilledSteps.length !== 1) return;\n        const op = unfulfilledSteps[0];\n        if (op && op.op === _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepPlanned) return op.hashedId;\n    }\n    async filterNewSteps(foundSteps) {\n        if (this.options.requestedRunStep) return;\n        /**\n\t\t* Gather any steps that aren't memoized and report them.\n\t\t*/ const newSteps = foundSteps.filter((step)=>!step.fulfilled);\n        if (!newSteps.length) return;\n        /**\n\t\t* Warn if we've found new steps but haven't yet seen all previous\n\t\t* steps. This may indicate that step presence isn't determinate.\n\t\t*/ let knownSteps = 0;\n        for (const step of foundSteps)if (step.fulfilled) knownSteps++;\n        if (!(this.state.stepsToFulfill === knownSteps)) console.warn((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyError)({\n            type: \"warn\",\n            whatHappened: \"Function may be indeterminate\",\n            why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n            consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n            reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\"\n        }));\n        /**\n\t\t* We're finishing up; let's trigger the last of the hooks.\n\t\t*/ await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n        const stepList = newSteps.map((step)=>({\n                displayName: step.displayName,\n                op: step.op,\n                id: step.hashedId,\n                name: step.name,\n                opts: step.opts,\n                userland: step.userland\n            }));\n        /**\n\t\t* We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n\t\t* to ensure that their `data` is transformed correctly.\n\t\t*/ return await this.transformNewSteps(stepList);\n    }\n    /**\n\t* Using middleware, transform any newly-found steps before returning them to\n\t* an Inngest Server.\n\t*/ async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step)=>{\n            if (step.op !== _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.InvokeFunction) return step;\n            /**\n\t\t\t* For each event being sent, create a new `onSendEvent` hook stack to\n\t\t\t* process it. We do this as middleware hooks are intended to run once\n\t\t\t* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n\t\t\t* is run for every single event.\n\t\t\t*\n\t\t\t* This is done because a developer can use this hook to filter out\n\t\t\t* events entirely; if we batch all of the events together, we can't\n\t\t\t* tell which ones were filtered out if we're processing >1 invocation\n\t\t\t* here.\n\t\t\t*/ const transformedPayload = await (await (0,_InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_10__.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", void 0, {\n                transformInput: (prev, output)=>{\n                    return {\n                        ...prev,\n                        ...output\n                    };\n                },\n                transformOutput: (prev, output)=>{\n                    return {\n                        result: {\n                            ...prev.result,\n                            ...output?.result\n                        }\n                    };\n                }\n            })).transformInput?.({\n                payloads: [\n                    {\n                        ...step.opts?.payload ?? {},\n                        name: _helpers_consts_js__WEBPACK_IMPORTED_MODULE_4__.internalEvents.FunctionInvoked\n                    }\n                ]\n            });\n            const newPayload = _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.invokePayloadSchema.parse(transformedPayload?.payloads?.[0] ?? {});\n            return {\n                ...step,\n                opts: {\n                    ...step.opts,\n                    payload: {\n                        ...step.opts?.payload ?? {},\n                        ...newPayload\n                    }\n                }\n            };\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, userland }) {\n        this.timeout?.clear();\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        const outgoingOp = {\n            id,\n            op: _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n            userland\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0,_als_js__WEBPACK_IMPORTED_MODULE_6__.getAsyncCtx)();\n        if (store?.execution) store.execution.executingStep = {\n            id,\n            name: displayName\n        };\n        this.debug(`executing step \"${id}\"`);\n        return (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.runAsPromise)(fn).finally(async ()=>{\n            if (store?.execution) delete store.execution.executingStep;\n            await this.state.hooks?.afterExecution?.();\n        }).then((data)=>{\n            return {\n                ...outgoingOp,\n                data\n            };\n        }).catch((error)=>{\n            let errorIsRetriable = true;\n            if (error instanceof _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_13__.NonRetriableError) errorIsRetriable = false;\n            else if (this.fnArg.maxAttempts && this.fnArg?.maxAttempts - 1 === this.fnArg.attempt) errorIsRetriable = false;\n            if (errorIsRetriable) return {\n                ...outgoingOp,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepError,\n                error\n            };\n            else return {\n                ...outgoingOp,\n                op: _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepFailed,\n                error\n            };\n        });\n    }\n    /**\n\t* Starts execution of the user's function, including triggering checkpoints\n\t* and middleware hooks where appropriate.\n\t*/ async startExecution() {\n        /**\n\t\t* Mutate input as neccessary based on middleware.\n\t\t*/ await this.transformInput();\n        /**\n\t\t* Start the timer to time out the run if needed.\n\t\t*/ this.timeout?.start();\n        await this.state.hooks?.beforeMemoization?.();\n        /**\n\t\t* If we had no state to begin with, immediately end the memoization phase.\n\t\t*/ if (this.state.allStateUsed()) {\n            await this.state.hooks?.afterMemoization?.();\n            await this.state.hooks?.beforeExecution?.();\n        }\n        /**\n\t\t* Trigger the user's function.\n\t\t*/ (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.runAsPromise)(()=>this.userFnToRun(this.fnArg)).finally(async ()=>{\n            await this.state.hooks?.afterMemoization?.();\n            await this.state.hooks?.beforeExecution?.();\n            await this.state.hooks?.afterExecution?.();\n        }).then((data)=>{\n            this.state.setCheckpoint({\n                type: \"function-resolved\",\n                data\n            });\n        }).catch((error)=>{\n            this.state.setCheckpoint({\n                type: \"function-rejected\",\n                error\n            });\n        });\n    }\n    /**\n\t* Using middleware, transform input before running.\n\t*/ async transformInput() {\n        const inputMutations = await this.state.hooks?.transformInput?.({\n            ctx: {\n                ...this.fnArg\n            },\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs\n        });\n        if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;\n        if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step)=>[\n                step.id,\n                step\n            ]));\n    }\n    /**\n\t* Using middleware, transform output before returning.\n\t*/ async transformOutput(dataOrError) {\n        const output = {\n            ...dataOrError\n        };\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await this.state.hooks?.transformOutput?.({\n            result: {\n                ...output\n            },\n            step: this.state.executingStep\n        });\n        const { data, error } = {\n            ...output,\n            ...transformedOutput?.result\n        };\n        if (!isStepExecution) await this.state.hooks?.finished?.({\n            result: {\n                ...typeof error !== \"undefined\" ? {\n                    error\n                } : {\n                    data\n                }\n            }\n        });\n        if (typeof error !== \"undefined\") {\n            /**\n\t\t\t* Ensure we give middleware the chance to decide on retriable behaviour\n\t\t\t* by looking at the error returned from output transformation.\n\t\t\t*/ let retriable = !(error instanceof _NonRetriableError_js__WEBPACK_IMPORTED_MODULE_13__.NonRetriableError || error instanceof _StepError_js__WEBPACK_IMPORTED_MODULE_14__.StepError && error === this.state.recentlyRejectedStepError);\n            if (retriable && error instanceof _RetryAfterError_js__WEBPACK_IMPORTED_MODULE_15__.RetryAfterError) retriable = error.retryAfter;\n            const serializedError = (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.minifyPrettyError)((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0,_helpers_functions_js__WEBPACK_IMPORTED_MODULE_16__.undefinedToNull)(data)\n        };\n    }\n    createExecutionState() {\n        const d = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = async function*(cleanUp) {\n            try {\n                while(true){\n                    const res = (await checkpointResults.next()).value;\n                    if (res) yield res;\n                }\n            } finally{\n                cleanUp?.();\n            }\n        }(()=>{\n            this.timeout?.clear();\n            checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        return {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: /* @__PURE__ */ new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [\n                ...this.options.stepCompletionOrder\n            ],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint)=>{\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: ()=>{\n                return this.state.remainingStepsToBeSeen.size === 0;\n            }\n        };\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        const step = this.createStepTools();\n        let fnArg = {\n            ...this.options.data,\n            step\n        };\n        /**\n\t\t* Handle use of the `onFailure` option by deserializing the error.\n\t\t*/ if (this.options.isFailureHandler) {\n            const eventData = zod_v3__WEBPACK_IMPORTED_MODULE_17__.object({\n                error: _types_js__WEBPACK_IMPORTED_MODULE_8__.jsonErrorSchema\n            }).parse(fnArg.event?.data);\n            fnArg = {\n                ...fnArg,\n                error: (0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.deserializeError)(eventData.error)\n            };\n        }\n        return this.options.transformCtx?.(fnArg) ?? fnArg;\n    }\n    createStepTools() {\n        /**\n\t\t* A list of steps that have been found and are being rolled up before being\n\t\t* reported to the core loop.\n\t\t*/ const foundStepsToReport = /* @__PURE__ */ new Map();\n        /**\n\t\t* A map of the subset of found steps to report that have not yet been\n\t\t* handled. Used for fast access to steps that need to be handled in order.\n\t\t*/ const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();\n        /**\n\t\t* A map of the latest sequential step indexes found for each step ID. Used\n\t\t* to ensure that we don't index steps in parallel.\n\t\t*\n\t\t* Note that these must be sequential; if we've seen or assigned `a:1`,\n\t\t* `a:2` and `a:4`, the latest sequential step index is `2`.\n\t\t*\n\t\t*/ const expectedNextStepIndexes = /* @__PURE__ */ new Map();\n        /**\n\t\t* A promise that's used to ensure that step reporting cannot be run more than\n\t\t* once in a given asynchronous time span.\n\t\t*/ let foundStepsReportPromise;\n        /**\n\t\t* A promise that's used to represent middleware hooks running before\n\t\t* execution.\n\t\t*/ let beforeExecHooksPromise;\n        /**\n\t\t* A helper used to report steps to the core loop. Used after adding an item\n\t\t* to `foundStepsToReport`.\n\t\t*/ const reportNextTick = ()=>{\n            if (foundStepsReportPromise) return;\n            foundStepsReportPromise = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.resolveNextTick)().then(()=>beforeExecHooksPromise).then(()=>{\n                foundStepsReportPromise = void 0;\n                for (const [hashedId, step] of unhandledFoundStepsToReport)if (step.handle()) {\n                    unhandledFoundStepsToReport.delete(hashedId);\n                    if (step.fulfilled) foundStepsToReport.delete(step.id);\n                }\n                if (foundStepsToReport.size) {\n                    const steps = [\n                        ...foundStepsToReport.values()\n                    ];\n                    foundStepsToReport.clear();\n                    this.state.setCheckpoint({\n                        type: \"steps-found\",\n                        steps\n                    });\n                    return;\n                }\n            });\n        };\n        /**\n\t\t* A helper used to push a step to the list of steps to report.\n\t\t*/ const pushStepToReport = (step)=>{\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts })=>{\n            await beforeExecHooksPromise;\n            const opId = matchOp((0,_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.getStepOptions)(args[0]), ...args.slice(1));\n            if (this.state.executingStep) /**\n\t\t\t* If a step is found after asynchronous actions during another step's\n\t\t\t* execution, everything is fine. The problem here is if we've found\n\t\t\t* that a step nested inside another a step, which is something we don't\n\t\t\t* support at the time of writing.\n\t\t\t*\n\t\t\t* In this case, we could use something like Async Hooks to understand\n\t\t\t* how the step is being triggered, though this isn't available in all\n\t\t\t* environments.\n\t\t\t*\n\t\t\t* Therefore, we'll only show a warning here to indicate that this is\n\t\t\t* potentially an issue.\n\t\t\t*/ console.warn((0,_helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.prettyError)({\n                whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${opId.displayName ?? opId.id}\\``,\n                consequences: \"Nesting `step.*` tooling is not supported.\",\n                type: \"warn\",\n                reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                stack: true,\n                toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                code: _helpers_errors_js__WEBPACK_IMPORTED_MODULE_9__.ErrCode.NESTING_STEPS\n            }));\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n                for(let i = expectedNextIndex;; i++){\n                    const newId = originalId + _InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        opId.userland.index = i;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.createDeferredPromise)();\n            const hashedId = _internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") isFulfilled = true;\n            }\n            let extraOpts;\n            let fnArgs = [\n                ...args\n            ];\n            if (typeof stepState?.input !== \"undefined\" && Array.isArray(stepState.input)) switch(opId.op){\n                case _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepPlanned:\n                    fnArgs = [\n                        ...args.slice(0, 2),\n                        ...stepState.input\n                    ];\n                    extraOpts = {\n                        input: [\n                            ...stepState.input\n                        ]\n                    };\n                    break;\n                case _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.AiGateway:\n                    extraOpts = {\n                        body: {\n                            ...typeof opId.opts?.body === \"object\" ? {\n                                ...opId.opts.body\n                            } : {},\n                            ...stepState.input[0]\n                        }\n                    };\n                    break;\n            }\n            const step = {\n                ...opId,\n                opts: {\n                    ...opId.opts,\n                    ...extraOpts\n                },\n                rawArgs: fnArgs,\n                hashedId,\n                input: stepState?.input,\n                fn: opts?.fn ? ()=>opts.fn?.(...fnArgs) : void 0,\n                promise,\n                fulfilled: isFulfilled,\n                hasStepState: Boolean(stepState),\n                displayName: opId.displayName ?? opId.id,\n                handled: false,\n                handle: ()=>{\n                    if (step.handled) return false;\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input\n                        ]).then(()=>{\n                            if (typeof stepState.data !== \"undefined\") resolve(stepState.data);\n                            else {\n                                this.state.recentlyRejectedStepError = new _StepError_js__WEBPACK_IMPORTED_MODULE_14__.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                }\n            };\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n\t\t\t* If this is the last piece of state we had, we've now finished\n\t\t\t* memoizing.\n\t\t\t*/ if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async ()=>{\n                await this.state.hooks?.afterMemoization?.();\n                await this.state.hooks?.beforeExecution?.();\n            })());\n            return promise;\n        };\n        return (0,_InngestStepTools_js__WEBPACK_IMPORTED_MODULE_11__.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) return this.options.fn[\"fn\"];\n        if (!this.options.fn[\"onFailureFn\"]) /**\n\t\t* Somehow, we've ended up detecting that this is a failure handler but\n\t\t* doesn't have an `onFailure` function. This should never happen.\n\t\t*/ throw new Error(\"Cannot find function `onFailure` handler\");\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) return;\n        this.timeout = (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_12__.createTimeoutPromise)(this.timeoutDuration);\n        this.timeout.then(async ()=>{\n            await this.state.hooks?.afterMemoization?.();\n            await this.state.hooks?.beforeExecution?.();\n            await this.state.hooks?.afterExecution?.();\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: _types_js__WEBPACK_IMPORTED_MODULE_8__.StepOpCode.StepNotFound\n                }\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        return await (0,_InngestMiddleware_js__WEBPACK_IMPORTED_MODULE_10__.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs\n        }, {\n            transformInput: (prev, output)=>{\n                return {\n                    ctx: {\n                        ...prev.ctx,\n                        ...output?.ctx\n                    },\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i)=>({\n                            ...step,\n                            ...output?.steps?.[i]\n                        })),\n                    reqArgs: prev.reqArgs\n                };\n            },\n            transformOutput: (prev, output)=>{\n                return {\n                    result: {\n                        ...prev.result,\n                        ...output?.result\n                    },\n                    step: prev.step\n                };\n            }\n        });\n    }\n};\nconst hashId = (id)=>{\n    return sha1().update(id).digest(\"hex\");\n};\nconst hashOp = (op)=>{\n    return {\n        ...op,\n        id: hashId(op.id)\n    };\n};\n/**\n* Exported for testing.\n*/ const _internals = {\n    hashOp,\n    hashId\n};\n//#endregion\n //# sourceMappingURL=v2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUNEO0FBQ2xCO0FBQzRDO0FBQzFCO0FBQ0o7QUFDRztBQUN3RDtBQUN2RDtBQUNOO0FBQ0Q7QUFDaUc7QUFDL0Y7QUFDWjtBQUN3RTtBQUN6RjtBQUNnQjtBQUNkO0FBRTdCLHdDQUF3QztBQUN4QyxJQUFJaUMsYUFBYSxhQUFhLEdBQUdqQyxzRUFBUUEsQ0FBQztJQUN6Q2tDLFlBQVksSUFBTUE7SUFDbEJDLDBCQUEwQixJQUFNQTtBQUNqQztBQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdKLG9DQUFNQTtBQUN2QixNQUFNRywyQkFBMkIsQ0FBQ0U7SUFDakMsT0FBTyxJQUFJQyxtQkFBbUJEO0FBQy9CO0FBQ0EsSUFBSUMscUJBQXFCLGNBQWM3QixrRUFBZ0JBO0lBZ0J0RDhCLFlBQVlGLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO2FBaEJQbEMsVUFBVUMsZ0VBQWdCQSxDQUFDb0MsRUFBRTthQUk3QkMsa0JBQWtCLE1BQU07UUFhdkIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDQyxjQUFjO1FBQ3RDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0Msb0JBQW9CO1FBQ3RDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0MsV0FBVztRQUM3QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUksQ0FBQ0Msd0JBQXdCO1FBQ3ZELElBQUksQ0FBQ0MsZUFBZSxDQUFDLElBQUksQ0FBQ04sS0FBSztRQUMvQixJQUFJLENBQUNPLEtBQUssQ0FBQyxxQ0FBcUMsSUFBSSxDQUFDZCxPQUFPLENBQUNlLGdCQUFnQixHQUFHLENBQUMscUJBQXFCLEVBQUUsSUFBSSxDQUFDZixPQUFPLENBQUNlLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHO1FBQzNJLElB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LE1BQU1DO2dCQUN2QixPQUFPO29CQUNOOUUsUUFBUTt3QkFDUCxHQUFHNkUsS0FBSzdFLE1BQU07d0JBQ2QsR0FBRzhFLFFBQVE5RSxNQUFNO29CQUNsQjtvQkFDQXNCLE1BQU11RCxLQUFLdkQsSUFBSTtnQkFDaEI7WUFDRDtRQUNEO0lBQ0Q7QUFDRDtBQUNBLE1BQU1vSSxTQUFTLENBQUN0RjtJQUNmLE9BQU85RyxPQUFPaU4sTUFBTSxDQUFDbkcsSUFBSW9HLE1BQU0sQ0FBQztBQUNqQztBQUNBLE1BQU1qSixTQUFTLENBQUNFO0lBQ2YsT0FBTztRQUNOLEdBQUdBLEVBQUU7UUFDTDJDLElBQUlzRixPQUFPakksR0FBRzJDLEVBQUU7SUFDakI7QUFDRDtBQUNBOztBQUVBLEdBQ0EsTUFBTWhILGFBQWE7SUFDbEJtRTtJQUNBbUk7QUFDRDtBQUVBLFlBQVk7QUFDb0MsQ0FDaEQsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL3YyLmpzPzRlMmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHBvcnQgfSBmcm9tIFwiLi4vLi4vX3ZpcnR1YWwvcm9sbGRvd25fcnVudGltZS5qc1wiO1xuaW1wb3J0IHsgZ2V0QXN5bmNDdHgsIGdldEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSBcIi4vYWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uLy4uL3ZlcnNpb24uanNcIjtcbmltcG9ydCB7IEV4ZWN1dGlvblZlcnNpb24sIGhlYWRlcktleXMsIGludGVybmFsRXZlbnRzIH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBTdGVwT3BDb2RlLCBqc29uRXJyb3JTY2hlbWEgfSBmcm9tIFwiLi4vLi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IElubmdlc3RFeGVjdXRpb24gfSBmcm9tIFwiLi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCI7XG5pbXBvcnQgeyBOb25SZXRyaWFibGVFcnJvciB9IGZyb20gXCIuLi9Ob25SZXRyaWFibGVFcnJvci5qc1wiO1xuaW1wb3J0IHsgRXJyQ29kZSwgZGVzZXJpYWxpemVFcnJvciwgbWluaWZ5UHJldHR5RXJyb3IsIHByZXR0eUVycm9yLCBzZXJpYWxpemVFcnJvciB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgdW5kZWZpbmVkVG9OdWxsIH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCI7XG5pbXBvcnQgeyBnZXRIb29rU3RhY2sgfSBmcm9tIFwiLi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIjtcbmltcG9ydCB7IGNsaWVudFByb2Nlc3Nvck1hcCB9IGZyb20gXCIuL290ZWwvYWNjZXNzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZFByb21pc2UsIGNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjaywgY3JlYXRlVGltZW91dFByb21pc2UsIHJlc29sdmVOZXh0VGljaywgcnVuQXNQcm9taXNlIH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvcHJvbWlzZXMuanNcIjtcbmltcG9ydCB7IFJldHJ5QWZ0ZXJFcnJvciB9IGZyb20gXCIuLi9SZXRyeUFmdGVyRXJyb3IuanNcIjtcbmltcG9ydCB7IFN0ZXBFcnJvciB9IGZyb20gXCIuLi9TdGVwRXJyb3IuanNcIjtcbmltcG9ydCB7IFNURVBfSU5ERVhJTkdfU1VGRklYLCBjcmVhdGVTdGVwVG9vbHMsIGdldFN0ZXBPcHRpb25zLCBpbnZva2VQYXlsb2FkU2NoZW1hIH0gZnJvbSBcIi4uL0lubmdlc3RTdGVwVG9vbHMuanNcIjtcbmltcG9ydCB7IHogfSBmcm9tIFwiem9kL3YzXCI7XG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcbmltcG9ydCBoYXNoanMgZnJvbSBcImhhc2guanNcIjtcblxuLy8jcmVnaW9uIHNyYy9jb21wb25lbnRzL2V4ZWN1dGlvbi92Mi50c1xudmFyIHYyX2V4cG9ydHMgPSAvKiBAX19QVVJFX18gKi8gX19leHBvcnQoe1xuXHRfaW50ZXJuYWxzOiAoKSA9PiBfaW50ZXJuYWxzLFxuXHRjcmVhdGVWMklubmdlc3RFeGVjdXRpb246ICgpID0+IGNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvblxufSk7XG5jb25zdCB7IHNoYTEgfSA9IGhhc2hqcztcbmNvbnN0IGNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvbiA9IChvcHRpb25zKSA9PiB7XG5cdHJldHVybiBuZXcgVjJJbm5nZXN0RXhlY3V0aW9uKG9wdGlvbnMpO1xufTtcbnZhciBWMklubmdlc3RFeGVjdXRpb24gPSBjbGFzcyBleHRlbmRzIElubmdlc3RFeGVjdXRpb24ge1xuXHR2ZXJzaW9uID0gRXhlY3V0aW9uVmVyc2lvbi5WMjtcblx0c3RhdGU7XG5cdGZuQXJnO1xuXHRjaGVja3BvaW50SGFuZGxlcnM7XG5cdHRpbWVvdXREdXJhdGlvbiA9IDFlMyAqIDEwO1xuXHRleGVjdXRpb247XG5cdHVzZXJGblRvUnVuO1xuXHQvKipcblx0KiBJZiB3ZSdyZSBzdXBwb3NlZCB0byBydW4gYSBwYXJ0aWN1bGFyIHN0ZXAgdmlhIGByZXF1ZXN0ZWRSdW5TdGVwYCwgdGhpc1xuXHQqIHdpbGwgYmUgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBhZnRlciBubyBzdGVwcyBoYXZlIGJlZW4gZm91bmQgZm9yXG5cdCogYHRpbWVvdXREdXJhdGlvbmAgbWlsbGlzZWNvbmRzLlxuXHQqXG5cdCogSWYgd2UncmUgbm90IHN1cHBvc2VkIHRvIHJ1biBhIHBhcnRpY3VsYXIgc3RlcCwgdGhpcyB3aWxsIGJlIGB1bmRlZmluZWRgLlxuXHQqL1xuXHR0aW1lb3V0O1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0dGhpcy51c2VyRm5Ub1J1biA9IHRoaXMuZ2V0VXNlckZuVG9SdW4oKTtcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVFeGVjdXRpb25TdGF0ZSgpO1xuXHRcdHRoaXMuZm5BcmcgPSB0aGlzLmNyZWF0ZUZuQXJnKCk7XG5cdFx0dGhpcy5jaGVja3BvaW50SGFuZGxlcnMgPSB0aGlzLmNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpO1xuXHRcdHRoaXMuaW5pdGlhbGl6ZVRpbWVyKHRoaXMuc3RhdGUpO1xuXHRcdHRoaXMuZGVidWcoXCJjcmVhdGVkIG5ldyBWMiBleGVjdXRpb24gZm9yIHJ1bjtcIiwgdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAgPyBgd2FudGluZyB0byBydW4gc3RlcCBcIiR7dGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXB9XCJgIDogXCJkaXNjb3ZlcmluZyBzdGVwc1wiKTtcblx0XHR0aGlzLmRlYnVnKFwiZXhpc3Rpbmcgc3RhdGUga2V5czpcIiwgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5zdGVwU3RhdGUpKTtcblx0fVxuXHQvKipcblx0KiBJZGVtcG90ZW50bHkgc3RhcnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuXHQqL1xuXHRzdGFydCgpIHtcblx0XHRpZiAoIXRoaXMuZXhlY3V0aW9uKSB7XG5cdFx0XHR0aGlzLmRlYnVnKFwic3RhcnRpbmcgVjIgZXhlY3V0aW9uXCIpO1xuXHRcdFx0Y29uc3QgdHJhY2VyID0gdHJhY2UuZ2V0VHJhY2VyKFwiaW5uZ2VzdFwiLCB2ZXJzaW9uKTtcblx0XHRcdHRoaXMuZXhlY3V0aW9uID0gZ2V0QXN5bmNMb2NhbFN0b3JhZ2UoKS50aGVuKChhbHMpID0+IHtcblx0XHRcdFx0cmV0dXJuIGFscy5ydW4oe1xuXHRcdFx0XHRcdGFwcDogdGhpcy5vcHRpb25zLmNsaWVudCxcblx0XHRcdFx0XHRleGVjdXRpb246IHtcblx0XHRcdFx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdFx0XHRcdGluc3RhbmNlOiB0aGlzXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4oXCJpbm5nZXN0LmV4ZWN1dGlvblwiLCAoc3BhbikgPT4ge1xuXHRcdFx0XHRcdFx0Y2xpZW50UHJvY2Vzc29yTWFwLmdldCh0aGlzLm9wdGlvbnMuY2xpZW50KT8uZGVjbGFyZVN0YXJ0aW5nU3Bhbih7XG5cdFx0XHRcdFx0XHRcdHNwYW4sXG5cdFx0XHRcdFx0XHRcdHJ1bklkOiB0aGlzLm9wdGlvbnMucnVuSWQsXG5cdFx0XHRcdFx0XHRcdHRyYWNlcGFyZW50OiB0aGlzLm9wdGlvbnMuaGVhZGVyc1toZWFkZXJLZXlzLlRyYWNlUGFyZW50XSxcblx0XHRcdFx0XHRcdFx0dHJhY2VzdGF0ZTogdGhpcy5vcHRpb25zLmhlYWRlcnNbaGVhZGVyS2V5cy5UcmFjZVN0YXRlXVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fc3RhcnQoKS50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWJ1ZyhcInJlc3VsdDpcIiwgcmVzdWx0KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0XHRcdH0pLmZpbmFsbHkoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRzcGFuLmVuZCgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmV4ZWN1dGlvbjtcblx0fVxuXHQvKipcblx0KiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24gYW5kIHRoZSBjb3JlIGxvb3AuXG5cdCovXG5cdGFzeW5jIF9zdGFydCgpIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYWxsQ2hlY2twb2ludEhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKFwiXCIpO1xuXHRcdFx0dGhpcy5zdGF0ZS5ob29rcyA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhcnRFeGVjdXRpb24oKTtcblx0XHRcdGZvciBhd2FpdCAoY29uc3QgY2hlY2twb2ludCBvZiB0aGlzLnN0YXRlLmxvb3ApIHtcblx0XHRcdFx0YXdhaXQgYWxsQ2hlY2twb2ludEhhbmRsZXIoY2hlY2twb2ludCk7XG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0Q2hlY2twb2ludEhhbmRsZXIoY2hlY2twb2ludC50eXBlKShjaGVja3BvaW50KTtcblx0XHRcdFx0aWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZXJyb3IgfSk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRoaXMuc3RhdGUubG9vcC5yZXR1cm4oKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmJlZm9yZVJlc3BvbnNlPy4oKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0KiBJZiB3ZSdyZSBoZXJlLCB0aGUgZ2VuZXJhdG9yIHNvbWVob3cgZmluaXNoZWQgd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZS5cblx0XHQqIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cblx0XHQqL1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvcmUgbG9vcCBmaW5pc2hlZCB3aXRob3V0IHJldHVybmluZyBhIHZhbHVlXCIpO1xuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBoYW5kbGVyIGZvciBldmVyeSBjaGVja3BvaW50IHR5cGUsIGRlZmluaW5nIHdoYXQgdG8gZG8gd2hlbiB3ZVxuXHQqIHJlYWNoIHRoYXQgY2hlY2twb2ludCBpbiB0aGUgY29yZSBsb29wLlxuXHQqL1xuXHRjcmVhdGVDaGVja3BvaW50SGFuZGxlcnMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdFwiXCI6IChjaGVja3BvaW50KSA9PiB7XG5cdFx0XHRcdHRoaXMuZGVidWcoXCJjaGVja3BvaW50OlwiLCBjaGVja3BvaW50KTtcblx0XHRcdH0sXG5cdFx0XHRcImZ1bmN0aW9uLXJlc29sdmVkXCI6IGFzeW5jIChjaGVja3BvaW50KSA9PiB7XG5cdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGE6IGNoZWNrcG9pbnQuZGF0YSB9KTtcblx0XHRcdH0sXG5cdFx0XHRcImZ1bmN0aW9uLXJlamVjdGVkXCI6IGFzeW5jIChjaGVja3BvaW50KSA9PiB7XG5cdFx0XHRcdHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yOiBjaGVja3BvaW50LmVycm9yIH0pO1xuXHRcdFx0fSxcblx0XHRcdFwic3RlcHMtZm91bmRcIjogYXN5bmMgKHsgc3RlcHMgfSkgPT4ge1xuXHRcdFx0XHRjb25zdCBzdGVwUmVzdWx0ID0gYXdhaXQgdGhpcy50cnlFeGVjdXRlU3RlcChzdGVwcyk7XG5cdFx0XHRcdGlmIChzdGVwUmVzdWx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtUmVzdWx0ID0gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoc3RlcFJlc3VsdCk7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0KiBUcmFuc2Zvcm1pbmcgb3V0cHV0IHdpbGwgYWx3YXlzIHJldHVybiBlaXRoZXIgZnVuY3Rpb24gcmVqZWN0aW9uIG9yXG5cdFx0XHRcdFx0KiByZXNvbHV0aW9uLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGNhbiBiZSBpbW1lZGlhdGVseSByZXR1cm5lZCwgYnV0IGluXG5cdFx0XHRcdFx0KiB0aGlzIHBhcnRpY3VsYXIgY2FzZSB3ZSB3YW50IHRvIGhhbmRsZSBpdCBkaWZmZXJlbnRseS5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdGlmICh0cmFuc2Zvcm1SZXN1bHQudHlwZSA9PT0gXCJmdW5jdGlvbi1yZXNvbHZlZFwiKSByZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJzdGVwLXJhblwiLFxuXHRcdFx0XHRcdFx0Y3R4OiB0cmFuc2Zvcm1SZXN1bHQuY3R4LFxuXHRcdFx0XHRcdFx0b3BzOiB0cmFuc2Zvcm1SZXN1bHQub3BzLFxuXHRcdFx0XHRcdFx0c3RlcDogX2ludGVybmFscy5oYXNoT3Aoe1xuXHRcdFx0XHRcdFx0XHQuLi5zdGVwUmVzdWx0LFxuXHRcdFx0XHRcdFx0XHRkYXRhOiB0cmFuc2Zvcm1SZXN1bHQuZGF0YVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGVsc2UgaWYgKHRyYW5zZm9ybVJlc3VsdC50eXBlID09PSBcImZ1bmN0aW9uLXJlamVjdGVkXCIpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0ZXBGb3JSZXNwb25zZSA9IF9pbnRlcm5hbHMuaGFzaE9wKHtcblx0XHRcdFx0XHRcdFx0Li4uc3RlcFJlc3VsdCxcblx0XHRcdFx0XHRcdFx0ZXJyb3I6IHRyYW5zZm9ybVJlc3VsdC5lcnJvclxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRpZiAoc3RlcFJlc3VsdC5vcCA9PT0gU3RlcE9wQ29kZS5TdGVwRmFpbGVkKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNlciA9IHNlcmlhbGl6ZUVycm9yKHRyYW5zZm9ybVJlc3VsdC5lcnJvcik7XG5cdFx0XHRcdFx0XHRcdHN0ZXBGb3JSZXNwb25zZS5kYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRcdF9fc2VyaWFsaXplZDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBzZXIubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBzZXIubWVzc2FnZSxcblx0XHRcdFx0XHRcdFx0XHRzdGFjazogXCJcIlxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdGVwLXJhblwiLFxuXHRcdFx0XHRcdFx0XHRjdHg6IHRyYW5zZm9ybVJlc3VsdC5jdHgsXG5cdFx0XHRcdFx0XHRcdG9wczogdHJhbnNmb3JtUmVzdWx0Lm9wcyxcblx0XHRcdFx0XHRcdFx0cmV0cmlhYmxlOiB0cmFuc2Zvcm1SZXN1bHQucmV0cmlhYmxlLFxuXHRcdFx0XHRcdFx0XHRzdGVwOiBzdGVwRm9yUmVzcG9uc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1SZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgbmV3U3RlcHMgPSBhd2FpdCB0aGlzLmZpbHRlck5ld1N0ZXBzKEFycmF5LmZyb20odGhpcy5zdGF0ZS5zdGVwcy52YWx1ZXMoKSkpO1xuXHRcdFx0XHRpZiAobmV3U3RlcHMpIHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuXHRcdFx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0XHRcdHN0ZXBzOiBuZXdTdGVwc1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdFwic3RlcC1ub3QtZm91bmRcIjogKHsgc3RlcCB9KSA9PiB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLFxuXHRcdFx0XHRcdGN0eDogdGhpcy5mbkFyZyxcblx0XHRcdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0XHRcdHN0ZXBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGdldENoZWNrcG9pbnRIYW5kbGVyKHR5cGUpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGVja3BvaW50SGFuZGxlcnNbdHlwZV07XG5cdH1cblx0YXN5bmMgdHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpIHtcblx0XHRjb25zdCBoYXNoZWRTdGVwSWRUb1J1biA9IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwIHx8IHRoaXMuZ2V0RWFybHlFeGVjUnVuU3RlcChzdGVwcyk7XG5cdFx0aWYgKCFoYXNoZWRTdGVwSWRUb1J1bikgcmV0dXJuO1xuXHRcdGNvbnN0IHN0ZXAgPSBzdGVwcy5maW5kKChzdGVwJDEpID0+IHN0ZXAkMS5oYXNoZWRJZCA9PT0gaGFzaGVkU3RlcElkVG9SdW4gJiYgc3RlcCQxLmZuKTtcblx0XHRpZiAoc3RlcCkgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVN0ZXAoc3RlcCk7XG5cdFx0dGhpcy50aW1lb3V0Py5yZXNldCgpO1xuXHR9XG5cdC8qKlxuXHQqIEdpdmVuIGEgbGlzdCBvZiBvdXRnb2luZyBvcHMsIGRlY2lkZSBpZiB3ZSBjYW4gZXhlY3V0ZSBhbiBvcCBlYXJseSBhbmRcblx0KiByZXR1cm4gdGhlIElEIG9mIHRoZSBzdGVwIHRvIGV4ZWN1dGUgaWYgd2UgY2FuLlxuXHQqL1xuXHRnZXRFYXJseUV4ZWNSdW5TdGVwKHN0ZXBzKSB7XG5cdFx0LyoqXG5cdFx0KiBXZSBtYXkgaGF2ZSBiZWVuIGRpc2FibGVkIGR1ZSB0byBwYXJhbGxlbGlzbSwgaW4gd2hpY2ggY2FzZSB3ZSBjYW4ndFxuXHRcdCogaW1tZWRpYXRlbHkgZXhlY3V0ZSB1bmxlc3MgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG5cdFx0Ki9cblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb24pIHJldHVybjtcblx0XHRjb25zdCB1bmZ1bGZpbGxlZFN0ZXBzID0gc3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuXHRcdGlmICh1bmZ1bGZpbGxlZFN0ZXBzLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xuXHRcdGNvbnN0IG9wID0gdW5mdWxmaWxsZWRTdGVwc1swXTtcblx0XHRpZiAob3AgJiYgb3Aub3AgPT09IFN0ZXBPcENvZGUuU3RlcFBsYW5uZWQpIHJldHVybiBvcC5oYXNoZWRJZDtcblx0fVxuXHRhc3luYyBmaWx0ZXJOZXdTdGVwcyhmb3VuZFN0ZXBzKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwKSByZXR1cm47XG5cdFx0LyoqXG5cdFx0KiBHYXRoZXIgYW55IHN0ZXBzIHRoYXQgYXJlbid0IG1lbW9pemVkIGFuZCByZXBvcnQgdGhlbS5cblx0XHQqL1xuXHRcdGNvbnN0IG5ld1N0ZXBzID0gZm91bmRTdGVwcy5maWx0ZXIoKHN0ZXApID0+ICFzdGVwLmZ1bGZpbGxlZCk7XG5cdFx0aWYgKCFuZXdTdGVwcy5sZW5ndGgpIHJldHVybjtcblx0XHQvKipcblx0XHQqIFdhcm4gaWYgd2UndmUgZm91bmQgbmV3IHN0ZXBzIGJ1dCBoYXZlbid0IHlldCBzZWVuIGFsbCBwcmV2aW91c1xuXHRcdCogc3RlcHMuIFRoaXMgbWF5IGluZGljYXRlIHRoYXQgc3RlcCBwcmVzZW5jZSBpc24ndCBkZXRlcm1pbmF0ZS5cblx0XHQqL1xuXHRcdGxldCBrbm93blN0ZXBzID0gMDtcblx0XHRmb3IgKGNvbnN0IHN0ZXAgb2YgZm91bmRTdGVwcykgaWYgKHN0ZXAuZnVsZmlsbGVkKSBrbm93blN0ZXBzKys7XG5cdFx0aWYgKCEodGhpcy5zdGF0ZS5zdGVwc1RvRnVsZmlsbCA9PT0ga25vd25TdGVwcykpIGNvbnNvbGUud2FybihwcmV0dHlFcnJvcih7XG5cdFx0XHR0eXBlOiBcIndhcm5cIixcblx0XHRcdHdoYXRIYXBwZW5lZDogXCJGdW5jdGlvbiBtYXkgYmUgaW5kZXRlcm1pbmF0ZVwiLFxuXHRcdFx0d2h5OiBcIldlIGZvdW5kIG5ldyBzdGVwcyBiZWZvcmUgc2VlaW5nIGFsbCBwcmV2aW91cyBzdGVwcywgd2hpY2ggbWF5IGluZGljYXRlIHRoYXQgdGhlIGZ1bmN0aW9uIGlzIG5vbi1kZXRlcm1pbmlzdGljLlwiLFxuXHRcdFx0Y29uc2VxdWVuY2VzOiBcIlRoaXMgbWF5IGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyIGFzIElubmdlc3QgZXhlY3V0ZXMgeW91ciBmdW5jdGlvbi5cIixcblx0XHRcdHJlYXNzdXJhbmNlOiBcIlRoaXMgaXMgZXhwZWN0ZWQgaWYgYSBmdW5jdGlvbiBpcyB1cGRhdGVkIGluIHRoZSBtaWRkbGUgb2YgYSBydW4sIGJ1dCBtYXkgaW5kaWNhdGUgYSBidWcgaWYgbm90LlwiXG5cdFx0fSkpO1xuXHRcdC8qKlxuXHRcdCogV2UncmUgZmluaXNoaW5nIHVwOyBsZXQncyB0cmlnZ2VyIHRoZSBsYXN0IG9mIHRoZSBob29rcy5cblx0XHQqL1xuXHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyTWVtb2l6YXRpb24/LigpO1xuXHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmJlZm9yZUV4ZWN1dGlvbj8uKCk7XG5cdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJFeGVjdXRpb24/LigpO1xuXHRcdGNvbnN0IHN0ZXBMaXN0ID0gbmV3U3RlcHMubWFwKChzdGVwKSA9PiAoe1xuXHRcdFx0ZGlzcGxheU5hbWU6IHN0ZXAuZGlzcGxheU5hbWUsXG5cdFx0XHRvcDogc3RlcC5vcCxcblx0XHRcdGlkOiBzdGVwLmhhc2hlZElkLFxuXHRcdFx0bmFtZTogc3RlcC5uYW1lLFxuXHRcdFx0b3B0czogc3RlcC5vcHRzLFxuXHRcdFx0dXNlcmxhbmQ6IHN0ZXAudXNlcmxhbmRcblx0XHR9KSk7XG5cdFx0LyoqXG5cdFx0KiBXZSBhbHNvIHJ1biBgb25TZW5kRXZlbnRgIG1pZGRsZXdhcmUgaG9va3MgYWdhaW5zdCBgc3RlcC5pbnZva2UoKWAgc3RlcHNcblx0XHQqIHRvIGVuc3VyZSB0aGF0IHRoZWlyIGBkYXRhYCBpcyB0cmFuc2Zvcm1lZCBjb3JyZWN0bHkuXG5cdFx0Ki9cblx0XHRyZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1OZXdTdGVwcyhzdGVwTGlzdCk7XG5cdH1cblx0LyoqXG5cdCogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGFueSBuZXdseS1mb3VuZCBzdGVwcyBiZWZvcmUgcmV0dXJuaW5nIHRoZW0gdG9cblx0KiBhbiBJbm5nZXN0IFNlcnZlci5cblx0Ki9cblx0YXN5bmMgdHJhbnNmb3JtTmV3U3RlcHMoc3RlcHMpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoc3RlcHMubWFwKGFzeW5jIChzdGVwKSA9PiB7XG5cdFx0XHRpZiAoc3RlcC5vcCAhPT0gU3RlcE9wQ29kZS5JbnZva2VGdW5jdGlvbikgcmV0dXJuIHN0ZXA7XG5cdFx0XHQvKipcblx0XHRcdCogRm9yIGVhY2ggZXZlbnQgYmVpbmcgc2VudCwgY3JlYXRlIGEgbmV3IGBvblNlbmRFdmVudGAgaG9vayBzdGFjayB0b1xuXHRcdFx0KiBwcm9jZXNzIGl0LiBXZSBkbyB0aGlzIGFzIG1pZGRsZXdhcmUgaG9va3MgYXJlIGludGVuZGVkIHRvIHJ1biBvbmNlXG5cdFx0XHQqIGR1cmluZyBlYWNoIGxpZmVjeWNsZSAob25GdW5jdGlvblJ1biBvciBvblNlbmRFdmVudCkgYW5kIGhlcmUsIGEgaG9va1xuXHRcdFx0KiBpcyBydW4gZm9yIGV2ZXJ5IHNpbmdsZSBldmVudC5cblx0XHRcdCpcblx0XHRcdCogVGhpcyBpcyBkb25lIGJlY2F1c2UgYSBkZXZlbG9wZXIgY2FuIHVzZSB0aGlzIGhvb2sgdG8gZmlsdGVyIG91dFxuXHRcdFx0KiBldmVudHMgZW50aXJlbHk7IGlmIHdlIGJhdGNoIGFsbCBvZiB0aGUgZXZlbnRzIHRvZ2V0aGVyLCB3ZSBjYW4ndFxuXHRcdFx0KiB0ZWxsIHdoaWNoIG9uZXMgd2VyZSBmaWx0ZXJlZCBvdXQgaWYgd2UncmUgcHJvY2Vzc2luZyA+MSBpbnZvY2F0aW9uXG5cdFx0XHQqIGhlcmUuXG5cdFx0XHQqL1xuXHRcdFx0Y29uc3QgdHJhbnNmb3JtZWRQYXlsb2FkID0gYXdhaXQgKGF3YWl0IGdldEhvb2tTdGFjayh0aGlzLm9wdGlvbnMuZm5bXCJtaWRkbGV3YXJlXCJdLCBcIm9uU2VuZEV2ZW50XCIsIHZvaWQgMCwge1xuXHRcdFx0XHR0cmFuc2Zvcm1JbnB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHQuLi5wcmV2LFxuXHRcdFx0XHRcdFx0Li4ub3V0cHV0XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgcmVzdWx0OiB7XG5cdFx0XHRcdFx0XHQuLi5wcmV2LnJlc3VsdCxcblx0XHRcdFx0XHRcdC4uLm91dHB1dD8ucmVzdWx0XG5cdFx0XHRcdFx0fSB9O1xuXHRcdFx0XHR9XG5cdFx0XHR9KSkudHJhbnNmb3JtSW5wdXQ/Lih7IHBheWxvYWRzOiBbe1xuXHRcdFx0XHQuLi5zdGVwLm9wdHM/LnBheWxvYWQgPz8ge30sXG5cdFx0XHRcdG5hbWU6IGludGVybmFsRXZlbnRzLkZ1bmN0aW9uSW52b2tlZFxuXHRcdFx0fV0gfSk7XG5cdFx0XHRjb25zdCBuZXdQYXlsb2FkID0gaW52b2tlUGF5bG9hZFNjaGVtYS5wYXJzZSh0cmFuc2Zvcm1lZFBheWxvYWQ/LnBheWxvYWRzPy5bMF0gPz8ge30pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4uc3RlcCxcblx0XHRcdFx0b3B0czoge1xuXHRcdFx0XHRcdC4uLnN0ZXAub3B0cyxcblx0XHRcdFx0XHRwYXlsb2FkOiB7XG5cdFx0XHRcdFx0XHQuLi5zdGVwLm9wdHM/LnBheWxvYWQgPz8ge30sXG5cdFx0XHRcdFx0XHQuLi5uZXdQYXlsb2FkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pKTtcblx0fVxuXHRhc3luYyBleGVjdXRlU3RlcCh7IGlkLCBuYW1lLCBvcHRzLCBmbiwgZGlzcGxheU5hbWUsIHVzZXJsYW5kIH0pIHtcblx0XHR0aGlzLnRpbWVvdXQ/LmNsZWFyKCk7XG5cdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJNZW1vaXphdGlvbj8uKCk7XG5cdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYmVmb3JlRXhlY3V0aW9uPy4oKTtcblx0XHRjb25zdCBvdXRnb2luZ09wID0ge1xuXHRcdFx0aWQsXG5cdFx0XHRvcDogU3RlcE9wQ29kZS5TdGVwUnVuLFxuXHRcdFx0bmFtZSxcblx0XHRcdG9wdHMsXG5cdFx0XHRkaXNwbGF5TmFtZSxcblx0XHRcdHVzZXJsYW5kXG5cdFx0fTtcblx0XHR0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXAgPSBvdXRnb2luZ09wO1xuXHRcdGNvbnN0IHN0b3JlID0gYXdhaXQgZ2V0QXN5bmNDdHgoKTtcblx0XHRpZiAoc3RvcmU/LmV4ZWN1dGlvbikgc3RvcmUuZXhlY3V0aW9uLmV4ZWN1dGluZ1N0ZXAgPSB7XG5cdFx0XHRpZCxcblx0XHRcdG5hbWU6IGRpc3BsYXlOYW1lXG5cdFx0fTtcblx0XHR0aGlzLmRlYnVnKGBleGVjdXRpbmcgc3RlcCBcIiR7aWR9XCJgKTtcblx0XHRyZXR1cm4gcnVuQXNQcm9taXNlKGZuKS5maW5hbGx5KGFzeW5jICgpID0+IHtcblx0XHRcdGlmIChzdG9yZT8uZXhlY3V0aW9uKSBkZWxldGUgc3RvcmUuZXhlY3V0aW9uLmV4ZWN1dGluZ1N0ZXA7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5hZnRlckV4ZWN1dGlvbj8uKCk7XG5cdFx0fSkudGhlbigoZGF0YSkgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Li4ub3V0Z29pbmdPcCxcblx0XHRcdFx0ZGF0YVxuXHRcdFx0fTtcblx0XHR9KS5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdGxldCBlcnJvcklzUmV0cmlhYmxlID0gdHJ1ZTtcblx0XHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIE5vblJldHJpYWJsZUVycm9yKSBlcnJvcklzUmV0cmlhYmxlID0gZmFsc2U7XG5cdFx0XHRlbHNlIGlmICh0aGlzLmZuQXJnLm1heEF0dGVtcHRzICYmIHRoaXMuZm5Bcmc/Lm1heEF0dGVtcHRzIC0gMSA9PT0gdGhpcy5mbkFyZy5hdHRlbXB0KSBlcnJvcklzUmV0cmlhYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAoZXJyb3JJc1JldHJpYWJsZSkgcmV0dXJuIHtcblx0XHRcdFx0Li4ub3V0Z29pbmdPcCxcblx0XHRcdFx0b3A6IFN0ZXBPcENvZGUuU3RlcEVycm9yLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdGVsc2UgcmV0dXJuIHtcblx0XHRcdFx0Li4ub3V0Z29pbmdPcCxcblx0XHRcdFx0b3A6IFN0ZXBPcENvZGUuU3RlcEZhaWxlZCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLCBpbmNsdWRpbmcgdHJpZ2dlcmluZyBjaGVja3BvaW50c1xuXHQqIGFuZCBtaWRkbGV3YXJlIGhvb2tzIHdoZXJlIGFwcHJvcHJpYXRlLlxuXHQqL1xuXHRhc3luYyBzdGFydEV4ZWN1dGlvbigpIHtcblx0XHQvKipcblx0XHQqIE11dGF0ZSBpbnB1dCBhcyBuZWNjZXNzYXJ5IGJhc2VkIG9uIG1pZGRsZXdhcmUuXG5cdFx0Ki9cblx0XHRhd2FpdCB0aGlzLnRyYW5zZm9ybUlucHV0KCk7XG5cdFx0LyoqXG5cdFx0KiBTdGFydCB0aGUgdGltZXIgdG8gdGltZSBvdXQgdGhlIHJ1biBpZiBuZWVkZWQuXG5cdFx0Ki9cblx0XHR0aGlzLnRpbWVvdXQ/LnN0YXJ0KCk7XG5cdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYmVmb3JlTWVtb2l6YXRpb24/LigpO1xuXHRcdC8qKlxuXHRcdCogSWYgd2UgaGFkIG5vIHN0YXRlIHRvIGJlZ2luIHdpdGgsIGltbWVkaWF0ZWx5IGVuZCB0aGUgbWVtb2l6YXRpb24gcGhhc2UuXG5cdFx0Ki9cblx0XHRpZiAodGhpcy5zdGF0ZS5hbGxTdGF0ZVVzZWQoKSkge1xuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYWZ0ZXJNZW1vaXphdGlvbj8uKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5iZWZvcmVFeGVjdXRpb24/LigpO1xuXHRcdH1cblx0XHQvKipcblx0XHQqIFRyaWdnZXIgdGhlIHVzZXIncyBmdW5jdGlvbi5cblx0XHQqL1xuXHRcdHJ1bkFzUHJvbWlzZSgoKSA9PiB0aGlzLnVzZXJGblRvUnVuKHRoaXMuZm5BcmcpKS5maW5hbGx5KGFzeW5jICgpID0+IHtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyTWVtb2l6YXRpb24/LigpO1xuXHRcdFx0YXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8uYmVmb3JlRXhlY3V0aW9uPy4oKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyRXhlY3V0aW9uPy4oKTtcblx0XHR9KS50aGVuKChkYXRhKSA9PiB7XG5cdFx0XHR0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuXHRcdFx0XHR0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsXG5cdFx0XHRcdGRhdGFcblx0XHRcdH0pO1xuXHRcdH0pLmNhdGNoKChlcnJvcikgPT4ge1xuXHRcdFx0dGhpcy5zdGF0ZS5zZXRDaGVja3BvaW50KHtcblx0XHRcdFx0dHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGlucHV0IGJlZm9yZSBydW5uaW5nLlxuXHQqL1xuXHRhc3luYyB0cmFuc2Zvcm1JbnB1dCgpIHtcblx0XHRjb25zdCBpbnB1dE11dGF0aW9ucyA9IGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LnRyYW5zZm9ybUlucHV0Py4oe1xuXHRcdFx0Y3R4OiB7IC4uLnRoaXMuZm5BcmcgfSxcblx0XHRcdHN0ZXBzOiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSxcblx0XHRcdGZuOiB0aGlzLm9wdGlvbnMuZm4sXG5cdFx0XHRyZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJnc1xuXHRcdH0pO1xuXHRcdGlmIChpbnB1dE11dGF0aW9ucz8uY3R4KSB0aGlzLmZuQXJnID0gaW5wdXRNdXRhdGlvbnMuY3R4O1xuXHRcdGlmIChpbnB1dE11dGF0aW9ucz8uc3RlcHMpIHRoaXMuc3RhdGUuc3RlcFN0YXRlID0gT2JqZWN0LmZyb21FbnRyaWVzKGlucHV0TXV0YXRpb25zLnN0ZXBzLm1hcCgoc3RlcCkgPT4gW3N0ZXAuaWQsIHN0ZXBdKSk7XG5cdH1cblx0LyoqXG5cdCogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIG91dHB1dCBiZWZvcmUgcmV0dXJuaW5nLlxuXHQqL1xuXHRhc3luYyB0cmFuc2Zvcm1PdXRwdXQoZGF0YU9yRXJyb3IpIHtcblx0XHRjb25zdCBvdXRwdXQgPSB7IC4uLmRhdGFPckVycm9yIH07XG5cdFx0Y29uc3QgaXNTdGVwRXhlY3V0aW9uID0gQm9vbGVhbih0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApO1xuXHRcdGNvbnN0IHRyYW5zZm9ybWVkT3V0cHV0ID0gYXdhaXQgdGhpcy5zdGF0ZS5ob29rcz8udHJhbnNmb3JtT3V0cHV0Py4oe1xuXHRcdFx0cmVzdWx0OiB7IC4uLm91dHB1dCB9LFxuXHRcdFx0c3RlcDogdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwXG5cdFx0fSk7XG5cdFx0Y29uc3QgeyBkYXRhLCBlcnJvciB9ID0ge1xuXHRcdFx0Li4ub3V0cHV0LFxuXHRcdFx0Li4udHJhbnNmb3JtZWRPdXRwdXQ/LnJlc3VsdFxuXHRcdH07XG5cdFx0aWYgKCFpc1N0ZXBFeGVjdXRpb24pIGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmZpbmlzaGVkPy4oeyByZXN1bHQ6IHsgLi4udHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiID8geyBlcnJvciB9IDogeyBkYXRhIH0gfSB9KTtcblx0XHRpZiAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHQvKipcblx0XHRcdCogRW5zdXJlIHdlIGdpdmUgbWlkZGxld2FyZSB0aGUgY2hhbmNlIHRvIGRlY2lkZSBvbiByZXRyaWFibGUgYmVoYXZpb3VyXG5cdFx0XHQqIGJ5IGxvb2tpbmcgYXQgdGhlIGVycm9yIHJldHVybmVkIGZyb20gb3V0cHV0IHRyYW5zZm9ybWF0aW9uLlxuXHRcdFx0Ki9cblx0XHRcdGxldCByZXRyaWFibGUgPSAhKGVycm9yIGluc3RhbmNlb2YgTm9uUmV0cmlhYmxlRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBTdGVwRXJyb3IgJiYgZXJyb3IgPT09IHRoaXMuc3RhdGUucmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvcik7XG5cdFx0XHRpZiAocmV0cmlhYmxlICYmIGVycm9yIGluc3RhbmNlb2YgUmV0cnlBZnRlckVycm9yKSByZXRyaWFibGUgPSBlcnJvci5yZXRyeUFmdGVyO1xuXHRcdFx0Y29uc3Qgc2VyaWFsaXplZEVycm9yID0gbWluaWZ5UHJldHR5RXJyb3Ioc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIixcblx0XHRcdFx0Y3R4OiB0aGlzLmZuQXJnLFxuXHRcdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0XHRlcnJvcjogc2VyaWFsaXplZEVycm9yLFxuXHRcdFx0XHRyZXRyaWFibGVcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsXG5cdFx0XHRjdHg6IHRoaXMuZm5BcmcsXG5cdFx0XHRvcHM6IHRoaXMub3BzLFxuXHRcdFx0ZGF0YTogdW5kZWZpbmVkVG9OdWxsKGRhdGEpXG5cdFx0fTtcblx0fVxuXHRjcmVhdGVFeGVjdXRpb25TdGF0ZSgpIHtcblx0XHRjb25zdCBkID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrKCk7XG5cdFx0bGV0IGNoZWNrcG9pbnRSZXNvbHZlID0gZC5kZWZlcnJlZC5yZXNvbHZlO1xuXHRcdGNvbnN0IGNoZWNrcG9pbnRSZXN1bHRzID0gZC5yZXN1bHRzO1xuXHRcdGNvbnN0IGxvb3AgPSAoYXN5bmMgZnVuY3Rpb24qIChjbGVhblVwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcyA9IChhd2FpdCBjaGVja3BvaW50UmVzdWx0cy5uZXh0KCkpLnZhbHVlO1xuXHRcdFx0XHRcdGlmIChyZXMpIHlpZWxkIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0Y2xlYW5VcD8uKCk7XG5cdFx0XHR9XG5cdFx0fSkoKCkgPT4ge1xuXHRcdFx0dGhpcy50aW1lb3V0Py5jbGVhcigpO1xuXHRcdFx0Y2hlY2twb2ludFJlc3VsdHMucmV0dXJuKCk7XG5cdFx0fSk7XG5cdFx0Y29uc3Qgc3RlcHNUb0Z1bGZpbGwgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuc3RlcFN0YXRlKS5sZW5ndGg7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0ZXBTdGF0ZTogdGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSxcblx0XHRcdHN0ZXBzVG9GdWxmaWxsLFxuXHRcdFx0c3RlcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG5cdFx0XHRsb29wLFxuXHRcdFx0aGFzU3RlcHM6IEJvb2xlYW4oc3RlcHNUb0Z1bGZpbGwpLFxuXHRcdFx0c3RlcENvbXBsZXRpb25PcmRlcjogWy4uLnRoaXMub3B0aW9ucy5zdGVwQ29tcGxldGlvbk9yZGVyXSxcblx0XHRcdHJlbWFpbmluZ1N0ZXBzVG9CZVNlZW46IG5ldyBTZXQodGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXIpLFxuXHRcdFx0c2V0Q2hlY2twb2ludDogKGNoZWNrcG9pbnQpID0+IHtcblx0XHRcdFx0KHtyZXNvbHZlOiBjaGVja3BvaW50UmVzb2x2ZX0gPSBjaGVja3BvaW50UmVzb2x2ZShjaGVja3BvaW50KSk7XG5cdFx0XHR9LFxuXHRcdFx0YWxsU3RhdGVVc2VkOiAoKSA9PiB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0YXRlLnJlbWFpbmluZ1N0ZXBzVG9CZVNlZW4uc2l6ZSA9PT0gMDtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdGdldCBvcHMoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLnN0YXRlLnN0ZXBzKTtcblx0fVxuXHRjcmVhdGVGbkFyZygpIHtcblx0XHRjb25zdCBzdGVwID0gdGhpcy5jcmVhdGVTdGVwVG9vbHMoKTtcblx0XHRsZXQgZm5BcmcgPSB7XG5cdFx0XHQuLi50aGlzLm9wdGlvbnMuZGF0YSxcblx0XHRcdHN0ZXBcblx0XHR9O1xuXHRcdC8qKlxuXHRcdCogSGFuZGxlIHVzZSBvZiB0aGUgYG9uRmFpbHVyZWAgb3B0aW9uIGJ5IGRlc2VyaWFsaXppbmcgdGhlIGVycm9yLlxuXHRcdCovXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSB7XG5cdFx0XHRjb25zdCBldmVudERhdGEgPSB6Lm9iamVjdCh7IGVycm9yOiBqc29uRXJyb3JTY2hlbWEgfSkucGFyc2UoZm5BcmcuZXZlbnQ/LmRhdGEpO1xuXHRcdFx0Zm5BcmcgPSB7XG5cdFx0XHRcdC4uLmZuQXJnLFxuXHRcdFx0XHRlcnJvcjogZGVzZXJpYWxpemVFcnJvcihldmVudERhdGEuZXJyb3IpXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnRyYW5zZm9ybUN0eD8uKGZuQXJnKSA/PyBmbkFyZztcblx0fVxuXHRjcmVhdGVTdGVwVG9vbHMoKSB7XG5cdFx0LyoqXG5cdFx0KiBBIGxpc3Qgb2Ygc3RlcHMgdGhhdCBoYXZlIGJlZW4gZm91bmQgYW5kIGFyZSBiZWluZyByb2xsZWQgdXAgYmVmb3JlIGJlaW5nXG5cdFx0KiByZXBvcnRlZCB0byB0aGUgY29yZSBsb29wLlxuXHRcdCovXG5cdFx0Y29uc3QgZm91bmRTdGVwc1RvUmVwb3J0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblx0XHQvKipcblx0XHQqIEEgbWFwIG9mIHRoZSBzdWJzZXQgb2YgZm91bmQgc3RlcHMgdG8gcmVwb3J0IHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cblx0XHQqIGhhbmRsZWQuIFVzZWQgZm9yIGZhc3QgYWNjZXNzIHRvIHN0ZXBzIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkIGluIG9yZGVyLlxuXHRcdCovXG5cdFx0Y29uc3QgdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblx0XHQvKipcblx0XHQqIEEgbWFwIG9mIHRoZSBsYXRlc3Qgc2VxdWVudGlhbCBzdGVwIGluZGV4ZXMgZm91bmQgZm9yIGVhY2ggc3RlcCBJRC4gVXNlZFxuXHRcdCogdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaW5kZXggc3RlcHMgaW4gcGFyYWxsZWwuXG5cdFx0KlxuXHRcdCogTm90ZSB0aGF0IHRoZXNlIG11c3QgYmUgc2VxdWVudGlhbDsgaWYgd2UndmUgc2VlbiBvciBhc3NpZ25lZCBgYToxYCxcblx0XHQqIGBhOjJgIGFuZCBgYTo0YCwgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXggaXMgYDJgLlxuXHRcdCpcblx0XHQqL1xuXHRcdGNvbnN0IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblx0XHQvKipcblx0XHQqIEEgcHJvbWlzZSB0aGF0J3MgdXNlZCB0byBlbnN1cmUgdGhhdCBzdGVwIHJlcG9ydGluZyBjYW5ub3QgYmUgcnVuIG1vcmUgdGhhblxuXHRcdCogb25jZSBpbiBhIGdpdmVuIGFzeW5jaHJvbm91cyB0aW1lIHNwYW4uXG5cdFx0Ki9cblx0XHRsZXQgZm91bmRTdGVwc1JlcG9ydFByb21pc2U7XG5cdFx0LyoqXG5cdFx0KiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gcmVwcmVzZW50IG1pZGRsZXdhcmUgaG9va3MgcnVubmluZyBiZWZvcmVcblx0XHQqIGV4ZWN1dGlvbi5cblx0XHQqL1xuXHRcdGxldCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuXHRcdC8qKlxuXHRcdCogQSBoZWxwZXIgdXNlZCB0byByZXBvcnQgc3RlcHMgdG8gdGhlIGNvcmUgbG9vcC4gVXNlZCBhZnRlciBhZGRpbmcgYW4gaXRlbVxuXHRcdCogdG8gYGZvdW5kU3RlcHNUb1JlcG9ydGAuXG5cdFx0Ki9cblx0XHRjb25zdCByZXBvcnROZXh0VGljayA9ICgpID0+IHtcblx0XHRcdGlmIChmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSkgcmV0dXJuO1xuXHRcdFx0Zm91bmRTdGVwc1JlcG9ydFByb21pc2UgPSByZXNvbHZlTmV4dFRpY2soKS50aGVuKCgpID0+IGJlZm9yZUV4ZWNIb29rc1Byb21pc2UpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZSA9IHZvaWQgMDtcblx0XHRcdFx0Zm9yIChjb25zdCBbaGFzaGVkSWQsIHN0ZXBdIG9mIHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydCkgaWYgKHN0ZXAuaGFuZGxlKCkpIHtcblx0XHRcdFx0XHR1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuZGVsZXRlKGhhc2hlZElkKTtcblx0XHRcdFx0XHRpZiAoc3RlcC5mdWxmaWxsZWQpIGZvdW5kU3RlcHNUb1JlcG9ydC5kZWxldGUoc3RlcC5pZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZvdW5kU3RlcHNUb1JlcG9ydC5zaXplKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc3RlcHMgPSBbLi4uZm91bmRTdGVwc1RvUmVwb3J0LnZhbHVlcygpXTtcblx0XHRcdFx0XHRmb3VuZFN0ZXBzVG9SZXBvcnQuY2xlYXIoKTtcblx0XHRcdFx0XHR0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoe1xuXHRcdFx0XHRcdFx0dHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuXHRcdFx0XHRcdFx0c3RlcHNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0KiBBIGhlbHBlciB1c2VkIHRvIHB1c2ggYSBzdGVwIHRvIHRoZSBsaXN0IG9mIHN0ZXBzIHRvIHJlcG9ydC5cblx0XHQqL1xuXHRcdGNvbnN0IHB1c2hTdGVwVG9SZXBvcnQgPSAoc3RlcCkgPT4ge1xuXHRcdFx0Zm91bmRTdGVwc1RvUmVwb3J0LnNldChzdGVwLmlkLCBzdGVwKTtcblx0XHRcdHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydC5zZXQoc3RlcC5oYXNoZWRJZCwgc3RlcCk7XG5cdFx0XHRyZXBvcnROZXh0VGljaygpO1xuXHRcdH07XG5cdFx0Y29uc3Qgc3RlcEhhbmRsZXIgPSBhc3luYyAoeyBhcmdzLCBtYXRjaE9wLCBvcHRzIH0pID0+IHtcblx0XHRcdGF3YWl0IGJlZm9yZUV4ZWNIb29rc1Byb21pc2U7XG5cdFx0XHRjb25zdCBvcElkID0gbWF0Y2hPcChnZXRTdGVwT3B0aW9ucyhhcmdzWzBdKSwgLi4uYXJncy5zbGljZSgxKSk7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwKVxuIC8qKlxuXHRcdFx0KiBJZiBhIHN0ZXAgaXMgZm91bmQgYWZ0ZXIgYXN5bmNocm9ub3VzIGFjdGlvbnMgZHVyaW5nIGFub3RoZXIgc3RlcCdzXG5cdFx0XHQqIGV4ZWN1dGlvbiwgZXZlcnl0aGluZyBpcyBmaW5lLiBUaGUgcHJvYmxlbSBoZXJlIGlzIGlmIHdlJ3ZlIGZvdW5kXG5cdFx0XHQqIHRoYXQgYSBzdGVwIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBhIHN0ZXAsIHdoaWNoIGlzIHNvbWV0aGluZyB3ZSBkb24ndFxuXHRcdFx0KiBzdXBwb3J0IGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcuXG5cdFx0XHQqXG5cdFx0XHQqIEluIHRoaXMgY2FzZSwgd2UgY291bGQgdXNlIHNvbWV0aGluZyBsaWtlIEFzeW5jIEhvb2tzIHRvIHVuZGVyc3RhbmRcblx0XHRcdCogaG93IHRoZSBzdGVwIGlzIGJlaW5nIHRyaWdnZXJlZCwgdGhvdWdoIHRoaXMgaXNuJ3QgYXZhaWxhYmxlIGluIGFsbFxuXHRcdFx0KiBlbnZpcm9ubWVudHMuXG5cdFx0XHQqXG5cdFx0XHQqIFRoZXJlZm9yZSwgd2UnbGwgb25seSBzaG93IGEgd2FybmluZyBoZXJlIHRvIGluZGljYXRlIHRoYXQgdGhpcyBpc1xuXHRcdFx0KiBwb3RlbnRpYWxseSBhbiBpc3N1ZS5cblx0XHRcdCovXG5cdFx0XHRjb25zb2xlLndhcm4ocHJldHR5RXJyb3Ioe1xuXHRcdFx0XHR3aGF0SGFwcGVuZWQ6IGBXZSBkZXRlY3RlZCB0aGF0IHlvdSBoYXZlIG5lc3RlZCBcXGBzdGVwLipcXGAgdG9vbGluZyBpbiBcXGAke29wSWQuZGlzcGxheU5hbWUgPz8gb3BJZC5pZH1cXGBgLFxuXHRcdFx0XHRjb25zZXF1ZW5jZXM6IFwiTmVzdGluZyBgc3RlcC4qYCB0b29saW5nIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG5cdFx0XHRcdHR5cGU6IFwid2FyblwiLFxuXHRcdFx0XHRyZWFzc3VyYW5jZTogXCJJdCdzIHBvc3NpYmxlIHRvIHNlZSB0aGlzIHdhcm5pbmcgaWYgc3RlcHMgYXJlIHNlcGFyYXRlZCBieSByZWd1bGFyIGFzeW5jaHJvbm91cyBjYWxscywgd2hpY2ggaXMgZmluZS5cIixcblx0XHRcdFx0c3RhY2s6IHRydWUsXG5cdFx0XHRcdHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB5b3UncmUgbm90IHVzaW5nIGBzdGVwLipgIHRvb2xpbmcgaW5zaWRlIG9mIG90aGVyIGBzdGVwLipgIHRvb2xpbmcuIElmIHlvdSBuZWVkIHRvIGNvbXBvc2Ugc3RlcHMgdG9nZXRoZXIsIHlvdSBjYW4gY3JlYXRlIGEgbmV3IGFzeW5jIGZ1bmN0aW9uIGFuZCBjYWxsIGl0IGZyb20gd2l0aGluIHlvdXIgc3RlcCBmdW5jdGlvbiwgb3IgdXNlIHByb21pc2UgY2hhaW5pbmcuXCIsXG5cdFx0XHRcdGNvZGU6IEVyckNvZGUuTkVTVElOR19TVEVQU1xuXHRcdFx0fSkpO1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuc3RlcHMuaGFzKG9wSWQuaWQpKSB7XG5cdFx0XHRcdGNvbnN0IG9yaWdpbmFsSWQgPSBvcElkLmlkO1xuXHRcdFx0XHRjb25zdCBleHBlY3RlZE5leHRJbmRleCA9IGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLmdldChvcmlnaW5hbElkKSA/PyAxO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gZXhwZWN0ZWROZXh0SW5kZXg7OyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBuZXdJZCA9IG9yaWdpbmFsSWQgKyBTVEVQX0lOREVYSU5HX1NVRkZJWCArIGk7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLnN0ZXBzLmhhcyhuZXdJZCkpIHtcblx0XHRcdFx0XHRcdGV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzLnNldChvcmlnaW5hbElkLCBpICsgMSk7XG5cdFx0XHRcdFx0XHRvcElkLmlkID0gbmV3SWQ7XG5cdFx0XHRcdFx0XHRvcElkLnVzZXJsYW5kLmluZGV4ID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpO1xuXHRcdFx0Y29uc3QgaGFzaGVkSWQgPSBfaW50ZXJuYWxzLmhhc2hJZChvcElkLmlkKTtcblx0XHRcdGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMuc3RhdGUuc3RlcFN0YXRlW2hhc2hlZElkXTtcblx0XHRcdGxldCBpc0Z1bGZpbGxlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHN0ZXBTdGF0ZSkge1xuXHRcdFx0XHRzdGVwU3RhdGUuc2VlbiA9IHRydWU7XG5cdFx0XHRcdHRoaXMuc3RhdGUucmVtYWluaW5nU3RlcHNUb0JlU2Vlbi5kZWxldGUoaGFzaGVkSWQpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHN0ZXBTdGF0ZS5pbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikgaXNGdWxmaWxsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGV4dHJhT3B0cztcblx0XHRcdGxldCBmbkFyZ3MgPSBbLi4uYXJnc107XG5cdFx0XHRpZiAodHlwZW9mIHN0ZXBTdGF0ZT8uaW5wdXQgIT09IFwidW5kZWZpbmVkXCIgJiYgQXJyYXkuaXNBcnJheShzdGVwU3RhdGUuaW5wdXQpKSBzd2l0Y2ggKG9wSWQub3ApIHtcblx0XHRcdFx0Y2FzZSBTdGVwT3BDb2RlLlN0ZXBQbGFubmVkOlxuXHRcdFx0XHRcdGZuQXJncyA9IFsuLi5hcmdzLnNsaWNlKDAsIDIpLCAuLi5zdGVwU3RhdGUuaW5wdXRdO1xuXHRcdFx0XHRcdGV4dHJhT3B0cyA9IHsgaW5wdXQ6IFsuLi5zdGVwU3RhdGUuaW5wdXRdIH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgU3RlcE9wQ29kZS5BaUdhdGV3YXk6XG5cdFx0XHRcdFx0ZXh0cmFPcHRzID0geyBib2R5OiB7XG5cdFx0XHRcdFx0XHQuLi50eXBlb2Ygb3BJZC5vcHRzPy5ib2R5ID09PSBcIm9iamVjdFwiID8geyAuLi5vcElkLm9wdHMuYm9keSB9IDoge30sXG5cdFx0XHRcdFx0XHQuLi5zdGVwU3RhdGUuaW5wdXRbMF1cblx0XHRcdFx0XHR9IH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBzdGVwID0ge1xuXHRcdFx0XHQuLi5vcElkLFxuXHRcdFx0XHRvcHRzOiB7XG5cdFx0XHRcdFx0Li4ub3BJZC5vcHRzLFxuXHRcdFx0XHRcdC4uLmV4dHJhT3B0c1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyYXdBcmdzOiBmbkFyZ3MsXG5cdFx0XHRcdGhhc2hlZElkLFxuXHRcdFx0XHRpbnB1dDogc3RlcFN0YXRlPy5pbnB1dCxcblx0XHRcdFx0Zm46IG9wdHM/LmZuID8gKCkgPT4gb3B0cy5mbj8uKC4uLmZuQXJncykgOiB2b2lkIDAsXG5cdFx0XHRcdHByb21pc2UsXG5cdFx0XHRcdGZ1bGZpbGxlZDogaXNGdWxmaWxsZWQsXG5cdFx0XHRcdGhhc1N0ZXBTdGF0ZTogQm9vbGVhbihzdGVwU3RhdGUpLFxuXHRcdFx0XHRkaXNwbGF5TmFtZTogb3BJZC5kaXNwbGF5TmFtZSA/PyBvcElkLmlkLFxuXHRcdFx0XHRoYW5kbGVkOiBmYWxzZSxcblx0XHRcdFx0aGFuZGxlOiAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHN0ZXAuaGFuZGxlZCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHN0ZXAuaGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKGlzRnVsZmlsbGVkICYmIHN0ZXBTdGF0ZSkge1xuXHRcdFx0XHRcdFx0c3RlcFN0YXRlLmZ1bGZpbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRQcm9taXNlLmFsbChbXG5cdFx0XHRcdFx0XHRcdHN0ZXBTdGF0ZS5kYXRhLFxuXHRcdFx0XHRcdFx0XHRzdGVwU3RhdGUuZXJyb3IsXG5cdFx0XHRcdFx0XHRcdHN0ZXBTdGF0ZS5pbnB1dFxuXHRcdFx0XHRcdFx0XSkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2Ygc3RlcFN0YXRlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHJlc29sdmUoc3RlcFN0YXRlLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlLnJlY2VudGx5UmVqZWN0ZWRTdGVwRXJyb3IgPSBuZXcgU3RlcEVycm9yKG9wSWQuaWQsIHN0ZXBTdGF0ZS5lcnJvcik7XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KHRoaXMuc3RhdGUucmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuc3RhdGUuc3RlcHMuc2V0KG9wSWQuaWQsIHN0ZXApO1xuXHRcdFx0dGhpcy5zdGF0ZS5oYXNTdGVwcyA9IHRydWU7XG5cdFx0XHRwdXNoU3RlcFRvUmVwb3J0KHN0ZXApO1xuXHRcdFx0LyoqXG5cdFx0XHQqIElmIHRoaXMgaXMgdGhlIGxhc3QgcGllY2Ugb2Ygc3RhdGUgd2UgaGFkLCB3ZSd2ZSBub3cgZmluaXNoZWRcblx0XHRcdCogbWVtb2l6aW5nLlxuXHRcdFx0Ki9cblx0XHRcdGlmICghYmVmb3JlRXhlY0hvb2tzUHJvbWlzZSAmJiB0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSBhd2FpdCAoYmVmb3JlRXhlY0hvb2tzUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmFmdGVyTWVtb2l6YXRpb24/LigpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5iZWZvcmVFeGVjdXRpb24/LigpO1xuXHRcdFx0fSkoKSk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHRcdHJldHVybiBjcmVhdGVTdGVwVG9vbHModGhpcy5vcHRpb25zLmNsaWVudCwgdGhpcywgc3RlcEhhbmRsZXIpO1xuXHR9XG5cdGdldFVzZXJGblRvUnVuKCkge1xuXHRcdGlmICghdGhpcy5vcHRpb25zLmlzRmFpbHVyZUhhbmRsZXIpIHJldHVybiB0aGlzLm9wdGlvbnMuZm5bXCJmblwiXTtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5mbltcIm9uRmFpbHVyZUZuXCJdKVxuIC8qKlxuXHRcdCogU29tZWhvdywgd2UndmUgZW5kZWQgdXAgZGV0ZWN0aW5nIHRoYXQgdGhpcyBpcyBhIGZhaWx1cmUgaGFuZGxlciBidXRcblx0XHQqIGRvZXNuJ3QgaGF2ZSBhbiBgb25GYWlsdXJlYCBmdW5jdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuXHRcdCovXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgZnVuY3Rpb24gYG9uRmFpbHVyZWAgaGFuZGxlclwiKTtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wib25GYWlsdXJlRm5cIl07XG5cdH1cblx0aW5pdGlhbGl6ZVRpbWVyKHN0YXRlKSB7XG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkgcmV0dXJuO1xuXHRcdHRoaXMudGltZW91dCA9IGNyZWF0ZVRpbWVvdXRQcm9taXNlKHRoaXMudGltZW91dER1cmF0aW9uKTtcblx0XHR0aGlzLnRpbWVvdXQudGhlbihhc3luYyAoKSA9PiB7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5hZnRlck1lbW9pemF0aW9uPy4oKTtcblx0XHRcdGF3YWl0IHRoaXMuc3RhdGUuaG9va3M/LmJlZm9yZUV4ZWN1dGlvbj8uKCk7XG5cdFx0XHRhd2FpdCB0aGlzLnN0YXRlLmhvb2tzPy5hZnRlckV4ZWN1dGlvbj8uKCk7XG5cdFx0XHRzdGF0ZS5zZXRDaGVja3BvaW50KHtcblx0XHRcdFx0dHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLFxuXHRcdFx0XHRzdGVwOiB7XG5cdFx0XHRcdFx0aWQ6IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwLFxuXHRcdFx0XHRcdG9wOiBTdGVwT3BDb2RlLlN0ZXBOb3RGb3VuZFxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHRhc3luYyBpbml0aWFsaXplTWlkZGxld2FyZSgpIHtcblx0XHRjb25zdCBjdHggPSB0aGlzLm9wdGlvbnMuZGF0YTtcblx0XHRyZXR1cm4gYXdhaXQgZ2V0SG9va1N0YWNrKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25GdW5jdGlvblJ1blwiLCB7XG5cdFx0XHRjdHgsXG5cdFx0XHRmbjogdGhpcy5vcHRpb25zLmZuLFxuXHRcdFx0c3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSksXG5cdFx0XHRyZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJnc1xuXHRcdH0sIHtcblx0XHRcdHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y3R4OiB7XG5cdFx0XHRcdFx0XHQuLi5wcmV2LmN0eCxcblx0XHRcdFx0XHRcdC4uLm91dHB1dD8uY3R4XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRmbjogdGhpcy5vcHRpb25zLmZuLFxuXHRcdFx0XHRcdHN0ZXBzOiBwcmV2LnN0ZXBzLm1hcCgoc3RlcCwgaSkgPT4gKHtcblx0XHRcdFx0XHRcdC4uLnN0ZXAsXG5cdFx0XHRcdFx0XHQuLi5vdXRwdXQ/LnN0ZXBzPy5baV1cblx0XHRcdFx0XHR9KSksXG5cdFx0XHRcdFx0cmVxQXJnczogcHJldi5yZXFBcmdzXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNmb3JtT3V0cHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0cmVzdWx0OiB7XG5cdFx0XHRcdFx0XHQuLi5wcmV2LnJlc3VsdCxcblx0XHRcdFx0XHRcdC4uLm91dHB1dD8ucmVzdWx0XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdGVwOiBwcmV2LnN0ZXBcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxufTtcbmNvbnN0IGhhc2hJZCA9IChpZCkgPT4ge1xuXHRyZXR1cm4gc2hhMSgpLnVwZGF0ZShpZCkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmNvbnN0IGhhc2hPcCA9IChvcCkgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdC4uLm9wLFxuXHRcdGlkOiBoYXNoSWQob3AuaWQpXG5cdH07XG59O1xuLyoqXG4qIEV4cG9ydGVkIGZvciB0ZXN0aW5nLlxuKi9cbmNvbnN0IF9pbnRlcm5hbHMgPSB7XG5cdGhhc2hPcCxcblx0aGFzaElkXG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvbiwgdjJfZXhwb3J0cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9djIuanMubWFwIl0sIm5hbWVzIjpbIl9fZXhwb3J0IiwiZ2V0QXN5bmNDdHgiLCJnZXRBc3luY0xvY2FsU3RvcmFnZSIsInZlcnNpb24iLCJFeGVjdXRpb25WZXJzaW9uIiwiaGVhZGVyS2V5cyIsImludGVybmFsRXZlbnRzIiwiU3RlcE9wQ29kZSIsImpzb25FcnJvclNjaGVtYSIsIklubmdlc3RFeGVjdXRpb24iLCJOb25SZXRyaWFibGVFcnJvciIsIkVyckNvZGUiLCJkZXNlcmlhbGl6ZUVycm9yIiwibWluaWZ5UHJldHR5RXJyb3IiLCJwcmV0dHlFcnJvciIsInNlcmlhbGl6ZUVycm9yIiwidW5kZWZpbmVkVG9OdWxsIiwiZ2V0SG9va1N0YWNrIiwiY2xpZW50UHJvY2Vzc29yTWFwIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlIiwiY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrIiwiY3JlYXRlVGltZW91dFByb21pc2UiLCJyZXNvbHZlTmV4dFRpY2siLCJydW5Bc1Byb21pc2UiLCJSZXRyeUFmdGVyRXJyb3IiLCJTdGVwRXJyb3IiLCJTVEVQX0lOREVYSU5HX1NVRkZJWCIsImNyZWF0ZVN0ZXBUb29scyIsImdldFN0ZXBPcHRpb25zIiwiaW52b2tlUGF5bG9hZFNjaGVtYSIsInoiLCJ0cmFjZSIsImhhc2hqcyIsInYyX2V4cG9ydHMiLCJfaW50ZXJuYWxzIiwiY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uIiwic2hhMSIsIm9wdGlvbnMiLCJWMklubmdlc3RFeGVjdXRpb24iLCJjb25zdHJ1Y3RvciIsIlYyIiwidGltZW91dER1cmF0aW9uIiwidXNlckZuVG9SdW4iLCJnZXRVc2VyRm5Ub1J1biIsInN0YXRlIiwiY3JlYXRlRXhlY3V0aW9uU3RhdGUiLCJmbkFyZyIsImNyZWF0ZUZuQXJnIiwiY2hlY2twb2ludEhhbmRsZXJzIiwiY3JlYXRlQ2hlY2twb2ludEhhbmRsZXJzIiwiaW5pdGlhbGl6ZVRpbWVyIiwiZGVidWciLCJyZXF1ZXN0ZWRSdW5TdGVwIiwiT2JqZWN0Iiwia2V5cyIsInN0ZXBTdGF0ZSIsInN0YXJ0IiwiZXhlY3V0aW9uIiwidHJhY2VyIiwiZ2V0VHJhY2VyIiwidGhlbiIsImFscyIsInJ1biIsImFwcCIsImNsaWVudCIsImN0eCIsImluc3RhbmNlIiwic3RhcnRBY3RpdmVTcGFuIiwic3BhbiIsImdldCIsImRlY2xhcmVTdGFydGluZ1NwYW4iLCJydW5JZCIsInRyYWNlcGFyZW50IiwiaGVhZGVycyIsIlRyYWNlUGFyZW50IiwidHJhY2VzdGF0ZSIsIlRyYWNlU3RhdGUiLCJfc3RhcnQiLCJyZXN1bHQiLCJmaW5hbGx5IiwiZW5kIiwiYWxsQ2hlY2twb2ludEhhbmRsZXIiLCJnZXRDaGVja3BvaW50SGFuZGxlciIsImhvb2tzIiwiaW5pdGlhbGl6ZU1pZGRsZXdhcmUiLCJzdGFydEV4ZWN1dGlvbiIsImNoZWNrcG9pbnQiLCJsb29wIiwidHlwZSIsImVycm9yIiwidHJhbnNmb3JtT3V0cHV0IiwicmV0dXJuIiwiYmVmb3JlUmVzcG9uc2UiLCJFcnJvciIsImRhdGEiLCJzdGVwcyIsInN0ZXBSZXN1bHQiLCJ0cnlFeGVjdXRlU3RlcCIsInRyYW5zZm9ybVJlc3VsdCIsIm9wcyIsInN0ZXAiLCJoYXNoT3AiLCJzdGVwRm9yUmVzcG9uc2UiLCJvcCIsIlN0ZXBGYWlsZWQiLCJzZXIiLCJfX3NlcmlhbGl6ZWQiLCJuYW1lIiwibWVzc2FnZSIsInN0YWNrIiwicmV0cmlhYmxlIiwibmV3U3RlcHMiLCJmaWx0ZXJOZXdTdGVwcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImhhc2hlZFN0ZXBJZFRvUnVuIiwiZ2V0RWFybHlFeGVjUnVuU3RlcCIsImZpbmQiLCJzdGVwJDEiLCJoYXNoZWRJZCIsImZuIiwiZXhlY3V0ZVN0ZXAiLCJ0aW1lb3V0IiwicmVzZXQiLCJkaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uIiwidW5mdWxmaWxsZWRTdGVwcyIsImZpbHRlciIsImZ1bGZpbGxlZCIsImxlbmd0aCIsIlN0ZXBQbGFubmVkIiwiZm91bmRTdGVwcyIsImtub3duU3RlcHMiLCJzdGVwc1RvRnVsZmlsbCIsImNvbnNvbGUiLCJ3YXJuIiwid2hhdEhhcHBlbmVkIiwid2h5IiwiY29uc2VxdWVuY2VzIiwicmVhc3N1cmFuY2UiLCJhZnRlck1lbW9pemF0aW9uIiwiYmVmb3JlRXhlY3V0aW9uIiwiYWZ0ZXJFeGVjdXRpb24iLCJzdGVwTGlzdCIsIm1hcCIsImRpc3BsYXlOYW1lIiwiaWQiLCJvcHRzIiwidXNlcmxhbmQiLCJ0cmFuc2Zvcm1OZXdTdGVwcyIsIlByb21pc2UiLCJhbGwiLCJJbnZva2VGdW5jdGlvbiIsInRyYW5zZm9ybWVkUGF5bG9hZCIsInRyYW5zZm9ybUlucHV0IiwicHJldiIsIm91dHB1dCIsInBheWxvYWRzIiwicGF5bG9hZCIsIkZ1bmN0aW9uSW52b2tlZCIsIm5ld1BheWxvYWQiLCJwYXJzZSIsImNsZWFyIiwib3V0Z29pbmdPcCIsIlN0ZXBSdW4iLCJleGVjdXRpbmdTdGVwIiwic3RvcmUiLCJjYXRjaCIsImVycm9ySXNSZXRyaWFibGUiLCJtYXhBdHRlbXB0cyIsImF0dGVtcHQiLCJiZWZvcmVNZW1vaXphdGlvbiIsImFsbFN0YXRlVXNlZCIsInNldENoZWNrcG9pbnQiLCJpbnB1dE11dGF0aW9ucyIsInJlcUFyZ3MiLCJmcm9tRW50cmllcyIsImRhdGFPckVycm9yIiwiaXNTdGVwRXhlY3V0aW9uIiwiQm9vbGVhbiIsInRyYW5zZm9ybWVkT3V0cHV0IiwiZmluaXNoZWQiLCJyZWNlbnRseVJlamVjdGVkU3RlcEVycm9yIiwicmV0cnlBZnRlciIsInNlcmlhbGl6ZWRFcnJvciIsImQiLCJjaGVja3BvaW50UmVzb2x2ZSIsImRlZmVycmVkIiwicmVzb2x2ZSIsImNoZWNrcG9pbnRSZXN1bHRzIiwicmVzdWx0cyIsImNsZWFuVXAiLCJyZXMiLCJuZXh0IiwidmFsdWUiLCJNYXAiLCJoYXNTdGVwcyIsInN0ZXBDb21wbGV0aW9uT3JkZXIiLCJyZW1haW5pbmdTdGVwc1RvQmVTZWVuIiwiU2V0Iiwic2l6ZSIsImlzRmFpbHVyZUhhbmRsZXIiLCJldmVudERhdGEiLCJvYmplY3QiLCJldmVudCIsInRyYW5zZm9ybUN0eCIsImZvdW5kU3RlcHNUb1JlcG9ydCIsInVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydCIsImV4cGVjdGVkTmV4dFN0ZXBJbmRleGVzIiwiZm91bmRTdGVwc1JlcG9ydFByb21pc2UiLCJiZWZvcmVFeGVjSG9va3NQcm9taXNlIiwicmVwb3J0TmV4dFRpY2siLCJoYW5kbGUiLCJkZWxldGUiLCJwdXNoU3RlcFRvUmVwb3J0Iiwic2V0Iiwic3RlcEhhbmRsZXIiLCJhcmdzIiwibWF0Y2hPcCIsIm9wSWQiLCJzbGljZSIsInRvRml4Tm93IiwiY29kZSIsIk5FU1RJTkdfU1RFUFMiLCJoYXMiLCJvcmlnaW5hbElkIiwiZXhwZWN0ZWROZXh0SW5kZXgiLCJpIiwibmV3SWQiLCJpbmRleCIsInByb21pc2UiLCJyZWplY3QiLCJoYXNoSWQiLCJpc0Z1bGZpbGxlZCIsInNlZW4iLCJpbnB1dCIsImV4dHJhT3B0cyIsImZuQXJncyIsImlzQXJyYXkiLCJBaUdhdGV3YXkiLCJib2R5IiwicmF3QXJncyIsImhhc1N0ZXBTdGF0ZSIsImhhbmRsZWQiLCJTdGVwTm90Rm91bmQiLCJ1cGRhdGUiLCJkaWdlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/ServerTiming.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/helpers/ServerTiming.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerTiming: () => (/* binding */ ServerTiming),\n/* harmony export */   ServerTiming_exports: () => (/* binding */ ServerTiming_exports)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _promises_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n\n\n//#region src/helpers/ServerTiming.ts\nvar ServerTiming_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_0__.__export)({\n    ServerTiming: ()=>ServerTiming\n});\n/**\n* A class to manage timing functions and arbitrary periods of time before\n* generating a `Server-Timing` header for use in HTTP responses.\n*\n* This is a very simple implementation that does not support nested timings or\n* fractions of a millisecond.\n*/ var ServerTiming = class {\n    /**\n\t* Start a timing. Returns a function that, when called, will stop the timing\n\t* and add it to the header.\n\t*/ start(name, description) {\n        if (!this.timings[name]) this.timings[name] = {\n            description: description ?? \"\",\n            timers: []\n        };\n        const index = this.timings[name].timers.push({\n            start: Date.now()\n        }) - 1;\n        return ()=>{\n            const target = this.timings[name];\n            if (!target) return console.warn(`Timing \"${name}\" does not exist`);\n            const timer = target.timers[index];\n            if (!timer) return console.warn(`Timer ${index} for timing \"${name}\" does not exist`);\n            timer.end = Date.now();\n        };\n    }\n    /**\n\t* Add a piece of arbitrary, untimed information to the header. Common use\n\t* cases would be cache misses.\n\t*\n\t* @example\n\t* ```\n\t* timer.append(\"cache\", \"miss\");\n\t* ```\n\t*/ append(key, value) {\n        this.timings[key] = {\n            description: value,\n            timers: []\n        };\n    }\n    /**\n\t* Wrap a function in a timing. The timing will be stopped and added to the\n\t* header when the function resolves or rejects.\n\t*\n\t* The return value of the function will be returned from this function.\n\t*/ async wrap(name, fn, description) {\n        const stop = this.start(name, description);\n        try {\n            return await (0,_promises_js__WEBPACK_IMPORTED_MODULE_1__.runAsPromise)(fn);\n        } finally{\n            stop();\n        }\n    }\n    /**\n\t* Generate the `Server-Timing` header.\n\t*/ getHeader() {\n        return Object.entries(this.timings).reduce((acc, [name, { description, timers }])=>{\n            if (!timers.some((timer)=>timer.end)) return acc;\n            const dur = timers.reduce((acc$1, { start, end })=>{\n                if (!start || !end) return acc$1;\n                return acc$1 + (end - start);\n            }, 0);\n            const entry = [\n                name,\n                description ? `desc=\"${description}\"` : \"\",\n                dur ? `dur=${dur}` : \"\"\n            ].filter(Boolean).join(\";\");\n            return [\n                ...acc,\n                entry\n            ];\n        }, []).join(\", \");\n    }\n    constructor(){\n        this.timings = {};\n    }\n};\n//#endregion\n //# sourceMappingURL=ServerTiming.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL1NlcnZlclRpbWluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJEO0FBQ2Q7QUFFN0MscUNBQXFDO0FBQ3JDLElBQUlFLHVCQUF1QixhQUFhLEdBQUdGLHNFQUFRQSxDQUFDO0lBQUVHLGNBQWMsSUFBTUE7QUFBYTtBQUN2Rjs7Ozs7O0FBTUEsR0FDQSxJQUFJQSxlQUFlO0lBRWxCOzs7Q0FHQSxHQUNBQyxNQUFNQyxJQUFJLEVBQUVDLFdBQVcsRUFBRTtRQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUNGLEtBQUssRUFBRSxJQUFJLENBQUNFLE9BQU8sQ0FBQ0YsS0FBSyxHQUFHO1lBQzdDQyxhQUFhQSxlQUFlO1lBQzVCRSxRQUFRLEVBQUU7UUFDWDtRQUNBLE1BQU1DLFFBQVEsSUFBSSxDQUFDRixPQUFPLENBQUNGLEtBQUssQ0FBQ0csTUFBTSxDQUFDRSxJQUFJLENBQUM7WUFBRU4sT0FBT08sS0FBS0MsR0FBRztRQUFHLEtBQUs7UUFDdEUsT0FBTztZQUNOLE1BQU1DLFNBQVMsSUFBSSxDQUFDTixPQUFPLENBQUNGLEtBQUs7WUFDakMsSUFBSSxDQUFDUSxRQUFRLE9BQU9DLFFBQVFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRVYsS0FBSyxnQkFBZ0IsQ0FBQztZQUNsRSxNQUFNVyxRQUFRSCxPQUFPTCxNQUFNLENBQUNDLE1BQU07WUFDbEMsSUFBSSxDQUFDTyxPQUFPLE9BQU9GLFFBQVFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRU4sTUFBTSxhQUFhLEVBQUVKLEtBQUssZ0JBQWdCLENBQUM7WUFDcEZXLE1BQU1DLEdBQUcsR0FBR04sS0FBS0MsR0FBRztRQUNyQjtJQUNEO0lBQ0E7Ozs7Ozs7O0NBUUEsR0FDQU0sT0FBT0MsR0FBRyxFQUFFQyxLQUFLLEVBQUU7UUFDbEIsSUFBSSxDQUFDYixPQUFPLENBQUNZLElBQUksR0FBRztZQUNuQmIsYUFBYWM7WUFDYlosUUFBUSxFQUFFO1FBQ1g7SUFDRDtJQUNBOzs7OztDQUtBLEdBQ0EsTUFBTWEsS0FBS2hCLElBQUksRUFBRWlCLEVBQUUsRUFBRWhCLFdBQVcsRUFBRTtRQUNqQyxNQUFNaUIsT0FBTyxJQUFJLENBQUNuQixLQUFLLENBQUNDLE1BQU1DO1FBQzlCLElBQUk7WUFDSCxPQUFPLE1BQU1MLDBEQUFZQSxDQUFDcUI7UUFDM0IsU0FBVTtZQUNUQztRQUNEO0lBQ0Q7SUFDQTs7Q0FFQSxHQUNBQyxZQUFZO1FBQ1gsT0FBT0MsT0FBT0MsT0FBTyxDQUFDLElBQUksQ0FBQ25CLE9BQU8sRUFBRW9CLE1BQU0sQ0FBQyxDQUFDQyxLQUFLLENBQUN2QixNQUFNLEVBQUVDLFdBQVcsRUFBRUUsTUFBTSxFQUFFLENBQUM7WUFDL0UsSUFBSSxDQUFDQSxPQUFPcUIsSUFBSSxDQUFDLENBQUNiLFFBQVVBLE1BQU1DLEdBQUcsR0FBRyxPQUFPVztZQUMvQyxNQUFNRSxNQUFNdEIsT0FBT21CLE1BQU0sQ0FBQyxDQUFDSSxPQUFPLEVBQUUzQixLQUFLLEVBQUVhLEdBQUcsRUFBRTtnQkFDL0MsSUFBSSxDQUFDYixTQUFTLENBQUNhLEtBQUssT0FBT2M7Z0JBQzNCLE9BQU9BLFFBQVNkLENBQUFBLE1BQU1iLEtBQUk7WUFDM0IsR0FBRztZQUNILE1BQU00QixRQUFRO2dCQUNiM0I7Z0JBQ0FDLGNBQWMsQ0FBQyxNQUFNLEVBQUVBLFlBQVksQ0FBQyxDQUFDLEdBQUc7Z0JBQ3hDd0IsTUFBTSxDQUFDLElBQUksRUFBRUEsSUFBSSxDQUFDLEdBQUc7YUFDckIsQ0FBQ0csTUFBTSxDQUFDQyxTQUFTQyxJQUFJLENBQUM7WUFDdkIsT0FBTzttQkFBSVA7Z0JBQUtJO2FBQU07UUFDdkIsR0FBRyxFQUFFLEVBQUVHLElBQUksQ0FBQztJQUNiOzthQWpFQTVCLFVBQVUsQ0FBQzs7QUFrRVo7QUFFQSxZQUFZO0FBQ2tDLENBQzlDLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL1NlcnZlclRpbWluZy5qcz9jMTJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZXhwb3J0IH0gZnJvbSBcIi4uL192aXJ0dWFsL3JvbGxkb3duX3J1bnRpbWUuanNcIjtcbmltcG9ydCB7IHJ1bkFzUHJvbWlzZSB9IGZyb20gXCIuL3Byb21pc2VzLmpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvaGVscGVycy9TZXJ2ZXJUaW1pbmcudHNcbnZhciBTZXJ2ZXJUaW1pbmdfZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBfX2V4cG9ydCh7IFNlcnZlclRpbWluZzogKCkgPT4gU2VydmVyVGltaW5nIH0pO1xuLyoqXG4qIEEgY2xhc3MgdG8gbWFuYWdlIHRpbWluZyBmdW5jdGlvbnMgYW5kIGFyYml0cmFyeSBwZXJpb2RzIG9mIHRpbWUgYmVmb3JlXG4qIGdlbmVyYXRpbmcgYSBgU2VydmVyLVRpbWluZ2AgaGVhZGVyIGZvciB1c2UgaW4gSFRUUCByZXNwb25zZXMuXG4qXG4qIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXMgbm90IHN1cHBvcnQgbmVzdGVkIHRpbWluZ3Mgb3JcbiogZnJhY3Rpb25zIG9mIGEgbWlsbGlzZWNvbmQuXG4qL1xudmFyIFNlcnZlclRpbWluZyA9IGNsYXNzIHtcblx0dGltaW5ncyA9IHt9O1xuXHQvKipcblx0KiBTdGFydCBhIHRpbWluZy4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIHN0b3AgdGhlIHRpbWluZ1xuXHQqIGFuZCBhZGQgaXQgdG8gdGhlIGhlYWRlci5cblx0Ki9cblx0c3RhcnQobmFtZSwgZGVzY3JpcHRpb24pIHtcblx0XHRpZiAoIXRoaXMudGltaW5nc1tuYW1lXSkgdGhpcy50aW1pbmdzW25hbWVdID0ge1xuXHRcdFx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uID8/IFwiXCIsXG5cdFx0XHR0aW1lcnM6IFtdXG5cdFx0fTtcblx0XHRjb25zdCBpbmRleCA9IHRoaXMudGltaW5nc1tuYW1lXS50aW1lcnMucHVzaCh7IHN0YXJ0OiBEYXRlLm5vdygpIH0pIC0gMTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Y29uc3QgdGFyZ2V0ID0gdGhpcy50aW1pbmdzW25hbWVdO1xuXHRcdFx0aWYgKCF0YXJnZXQpIHJldHVybiBjb25zb2xlLndhcm4oYFRpbWluZyBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuXHRcdFx0Y29uc3QgdGltZXIgPSB0YXJnZXQudGltZXJzW2luZGV4XTtcblx0XHRcdGlmICghdGltZXIpIHJldHVybiBjb25zb2xlLndhcm4oYFRpbWVyICR7aW5kZXh9IGZvciB0aW1pbmcgXCIke25hbWV9XCIgZG9lcyBub3QgZXhpc3RgKTtcblx0XHRcdHRpbWVyLmVuZCA9IERhdGUubm93KCk7XG5cdFx0fTtcblx0fVxuXHQvKipcblx0KiBBZGQgYSBwaWVjZSBvZiBhcmJpdHJhcnksIHVudGltZWQgaW5mb3JtYXRpb24gdG8gdGhlIGhlYWRlci4gQ29tbW9uIHVzZVxuXHQqIGNhc2VzIHdvdWxkIGJlIGNhY2hlIG1pc3Nlcy5cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgXG5cdCogdGltZXIuYXBwZW5kKFwiY2FjaGVcIiwgXCJtaXNzXCIpO1xuXHQqIGBgYFxuXHQqL1xuXHRhcHBlbmQoa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMudGltaW5nc1trZXldID0ge1xuXHRcdFx0ZGVzY3JpcHRpb246IHZhbHVlLFxuXHRcdFx0dGltZXJzOiBbXVxuXHRcdH07XG5cdH1cblx0LyoqXG5cdCogV3JhcCBhIGZ1bmN0aW9uIGluIGEgdGltaW5nLiBUaGUgdGltaW5nIHdpbGwgYmUgc3RvcHBlZCBhbmQgYWRkZWQgdG8gdGhlXG5cdCogaGVhZGVyIHdoZW4gdGhlIGZ1bmN0aW9uIHJlc29sdmVzIG9yIHJlamVjdHMuXG5cdCpcblx0KiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhpcyBmdW5jdGlvbi5cblx0Ki9cblx0YXN5bmMgd3JhcChuYW1lLCBmbiwgZGVzY3JpcHRpb24pIHtcblx0XHRjb25zdCBzdG9wID0gdGhpcy5zdGFydChuYW1lLCBkZXNjcmlwdGlvbik7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBhd2FpdCBydW5Bc1Byb21pc2UoZm4pO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzdG9wKCk7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEdlbmVyYXRlIHRoZSBgU2VydmVyLVRpbWluZ2AgaGVhZGVyLlxuXHQqL1xuXHRnZXRIZWFkZXIoKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5lbnRyaWVzKHRoaXMudGltaW5ncykucmVkdWNlKChhY2MsIFtuYW1lLCB7IGRlc2NyaXB0aW9uLCB0aW1lcnMgfV0pID0+IHtcblx0XHRcdGlmICghdGltZXJzLnNvbWUoKHRpbWVyKSA9PiB0aW1lci5lbmQpKSByZXR1cm4gYWNjO1xuXHRcdFx0Y29uc3QgZHVyID0gdGltZXJzLnJlZHVjZSgoYWNjJDEsIHsgc3RhcnQsIGVuZCB9KSA9PiB7XG5cdFx0XHRcdGlmICghc3RhcnQgfHwgIWVuZCkgcmV0dXJuIGFjYyQxO1xuXHRcdFx0XHRyZXR1cm4gYWNjJDEgKyAoZW5kIC0gc3RhcnQpO1xuXHRcdFx0fSwgMCk7XG5cdFx0XHRjb25zdCBlbnRyeSA9IFtcblx0XHRcdFx0bmFtZSxcblx0XHRcdFx0ZGVzY3JpcHRpb24gPyBgZGVzYz1cIiR7ZGVzY3JpcHRpb259XCJgIDogXCJcIixcblx0XHRcdFx0ZHVyID8gYGR1cj0ke2R1cn1gIDogXCJcIlxuXHRcdFx0XS5maWx0ZXIoQm9vbGVhbikuam9pbihcIjtcIik7XG5cdFx0XHRyZXR1cm4gWy4uLmFjYywgZW50cnldO1xuXHRcdH0sIFtdKS5qb2luKFwiLCBcIik7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgU2VydmVyVGltaW5nLCBTZXJ2ZXJUaW1pbmdfZXhwb3J0cyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VydmVyVGltaW5nLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4cG9ydCIsInJ1bkFzUHJvbWlzZSIsIlNlcnZlclRpbWluZ19leHBvcnRzIiwiU2VydmVyVGltaW5nIiwic3RhcnQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJ0aW1pbmdzIiwidGltZXJzIiwiaW5kZXgiLCJwdXNoIiwiRGF0ZSIsIm5vdyIsInRhcmdldCIsImNvbnNvbGUiLCJ3YXJuIiwidGltZXIiLCJlbmQiLCJhcHBlbmQiLCJrZXkiLCJ2YWx1ZSIsIndyYXAiLCJmbiIsInN0b3AiLCJnZXRIZWFkZXIiLCJPYmplY3QiLCJlbnRyaWVzIiwicmVkdWNlIiwiYWNjIiwic29tZSIsImR1ciIsImFjYyQxIiwiZW50cnkiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/ServerTiming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/consts.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/consts.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExecutionVersion: () => (/* binding */ ExecutionVersion),\n/* harmony export */   debugPrefix: () => (/* binding */ debugPrefix),\n/* harmony export */   defaultDevServerHost: () => (/* binding */ defaultDevServerHost),\n/* harmony export */   defaultInngestApiBaseUrl: () => (/* binding */ defaultInngestApiBaseUrl),\n/* harmony export */   defaultInngestEventBaseUrl: () => (/* binding */ defaultInngestEventBaseUrl),\n/* harmony export */   defaultMaxRetries: () => (/* binding */ defaultMaxRetries),\n/* harmony export */   dummyEventKey: () => (/* binding */ dummyEventKey),\n/* harmony export */   envKeys: () => (/* binding */ envKeys),\n/* harmony export */   forwardedHeaders: () => (/* binding */ forwardedHeaders),\n/* harmony export */   headerKeys: () => (/* binding */ headerKeys),\n/* harmony export */   internalEvents: () => (/* binding */ internalEvents),\n/* harmony export */   logPrefix: () => (/* binding */ logPrefix),\n/* harmony export */   probe: () => (/* binding */ probe),\n/* harmony export */   queryKeys: () => (/* binding */ queryKeys),\n/* harmony export */   syncKind: () => (/* binding */ syncKind)\n/* harmony export */ });\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\");\n\n//#region src/helpers/consts.ts\n/**\n* Keys for accessing query parameters included in requests from Inngest to run\n* functions.\n*\n* Used internally to create handlers using `InngestCommHandler`, but can be\n* imported to be used if creating a custom handler outside of the package.\n*\n* @public\n*/ let queryKeys = /* @__PURE__ */ function(queryKeys$1) {\n    queryKeys$1[\"DeployId\"] = \"deployId\";\n    queryKeys$1[\"FnId\"] = \"fnId\";\n    queryKeys$1[\"Probe\"] = \"probe\";\n    queryKeys$1[\"StepId\"] = \"stepId\";\n    return queryKeys$1;\n}({});\nlet probe = /* @__PURE__ */ function(probe$1) {\n    probe$1[\"Trust\"] = \"trust\";\n    return probe$1;\n}({});\nlet envKeys = /* @__PURE__ */ function(envKeys$1) {\n    envKeys$1[\"InngestSigningKey\"] = \"INNGEST_SIGNING_KEY\";\n    envKeys$1[\"InngestSigningKeyFallback\"] = \"INNGEST_SIGNING_KEY_FALLBACK\";\n    envKeys$1[\"InngestEventKey\"] = \"INNGEST_EVENT_KEY\";\n    /**\n\t* @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.\n\t*/ envKeys$1[\"InngestDevServerUrl\"] = \"INNGEST_DEVSERVER_URL\";\n    envKeys$1[\"InngestEnvironment\"] = \"INNGEST_ENV\";\n    envKeys$1[\"InngestBaseUrl\"] = \"INNGEST_BASE_URL\";\n    envKeys$1[\"InngestEventApiBaseUrl\"] = \"INNGEST_EVENT_API_BASE_URL\";\n    envKeys$1[\"InngestApiBaseUrl\"] = \"INNGEST_API_BASE_URL\";\n    envKeys$1[\"InngestServeHost\"] = \"INNGEST_SERVE_HOST\";\n    envKeys$1[\"InngestServePath\"] = \"INNGEST_SERVE_PATH\";\n    envKeys$1[\"InngestLogLevel\"] = \"INNGEST_LOG_LEVEL\";\n    envKeys$1[\"InngestStreaming\"] = \"INNGEST_STREAMING\";\n    envKeys$1[\"InngestDevMode\"] = \"INNGEST_DEV\";\n    envKeys$1[\"InngestAllowInBandSync\"] = \"INNGEST_ALLOW_IN_BAND_SYNC\";\n    envKeys$1[\"InngestConnectMaxWorkerConcurrency\"] = \"INNGEST_CONNECT_MAX_WORKER_CONCURRENCY\";\n    /**\n\t* @deprecated It's unknown what this env var was used for, but we do not\n\t* provide explicit support for it. Prefer using `INNGEST_ENV` instead.\n\t*/ envKeys$1[\"BranchName\"] = \"BRANCH_NAME\";\n    /**\n\t* The git branch of the commit the deployment was triggered by. Example:\n\t* `improve-about-page`.\n\t*\n\t* {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}\n\t*/ envKeys$1[\"VercelBranch\"] = \"VERCEL_GIT_COMMIT_REF\";\n    /**\n\t* Expected to be `\"1\"` if defined.\n\t*/ envKeys$1[\"IsVercel\"] = \"VERCEL\";\n    /**\n\t* The branch name of the current deployment. May only be accessible at build\n\t* time, but included here just in case.\n\t*\n\t* {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}\n\t*/ envKeys$1[\"CloudflarePagesBranch\"] = \"CF_PAGES_BRANCH\";\n    /**\n\t* Expected to be `\"1\"` if defined.\n\t*/ envKeys$1[\"IsCloudflarePages\"] = \"CF_PAGES\";\n    /**\n\t* The branch name of the deployment from Git to Netlify, if available.\n\t*\n\t* {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}\n\t*/ envKeys$1[\"NetlifyBranch\"] = \"BRANCH\";\n    /**\n\t* Expected to be `\"true\"` if defined.\n\t*/ envKeys$1[\"IsNetlify\"] = \"NETLIFY\";\n    /**\n\t* The Git branch for a service or deploy.\n\t*\n\t* {@link https://render.com/docs/environment-variables#all-services}\n\t*/ envKeys$1[\"RenderBranch\"] = \"RENDER_GIT_BRANCH\";\n    /**\n\t* Expected to be `\"true\"` if defined.\n\t*/ envKeys$1[\"IsRender\"] = \"RENDER\";\n    /**\n\t* The branch that triggered the deployment. Example: `main`\n\t*\n\t* {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n\t*/ envKeys$1[\"RailwayBranch\"] = \"RAILWAY_GIT_BRANCH\";\n    /**\n\t* The railway environment for the deployment. Example: `production`\n\t*\n\t* {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n\t*/ envKeys$1[\"RailwayEnvironment\"] = \"RAILWAY_ENVIRONMENT\";\n    envKeys$1[\"VercelEnvKey\"] = \"VERCEL_ENV\";\n    envKeys$1[\"OpenAiApiKey\"] = \"OPENAI_API_KEY\";\n    envKeys$1[\"GeminiApiKey\"] = \"GEMINI_API_KEY\";\n    envKeys$1[\"AnthropicApiKey\"] = \"ANTHROPIC_API_KEY\";\n    return envKeys$1;\n}({});\n/**\n* Keys for accessing headers included in requests from Inngest to run\n* functions.\n*\n* Used internally to create handlers using `InngestCommHandler`, but can be\n* imported to be used if creating a custom handler outside of the package.\n*\n* @public\n*/ let headerKeys = /* @__PURE__ */ function(headerKeys$1) {\n    headerKeys$1[\"ContentType\"] = \"content-type\";\n    headerKeys$1[\"Host\"] = \"host\";\n    headerKeys$1[\"ForwardedFor\"] = \"x-forwarded-for\";\n    headerKeys$1[\"RealIp\"] = \"x-real-ip\";\n    headerKeys$1[\"Location\"] = \"location\";\n    headerKeys$1[\"ContentLength\"] = \"content-length\";\n    headerKeys$1[\"Signature\"] = \"x-inngest-signature\";\n    headerKeys$1[\"SdkVersion\"] = \"x-inngest-sdk\";\n    headerKeys$1[\"Environment\"] = \"x-inngest-env\";\n    headerKeys$1[\"Platform\"] = \"x-inngest-platform\";\n    headerKeys$1[\"Framework\"] = \"x-inngest-framework\";\n    headerKeys$1[\"NoRetry\"] = \"x-inngest-no-retry\";\n    headerKeys$1[\"RequestVersion\"] = \"x-inngest-req-version\";\n    headerKeys$1[\"RetryAfter\"] = \"retry-after\";\n    headerKeys$1[\"InngestServerKind\"] = \"x-inngest-server-kind\";\n    headerKeys$1[\"InngestExpectedServerKind\"] = \"x-inngest-expected-server-kind\";\n    headerKeys$1[\"InngestSyncKind\"] = \"x-inngest-sync-kind\";\n    headerKeys$1[\"EventIdSeed\"] = \"x-inngest-event-id-seed\";\n    headerKeys$1[\"TraceParent\"] = \"traceparent\";\n    headerKeys$1[\"TraceState\"] = \"tracestate\";\n    headerKeys$1[\"InngestRunId\"] = \"x-run-id\";\n    return headerKeys$1;\n}({});\n/**\n* Headers that are forwarded from the original request when an Inngest function\n* is invoked.\n*/ const forwardedHeaders = [\n    headerKeys.TraceParent,\n    headerKeys.TraceState\n];\nconst defaultInngestApiBaseUrl = \"https://api.inngest.com/\";\nconst defaultInngestEventBaseUrl = \"https://inn.gs/\";\nconst defaultDevServerHost = \"http://localhost:8288/\";\n/**\n* Events that Inngest may send internally that can be used to trigger\n* functions.\n*\n* @public\n*/ let internalEvents = /* @__PURE__ */ function(internalEvents$1) {\n    /**\n\t* A function has failed after exhausting all available retries. This event\n\t* will contain the original event and the error that caused the failure.\n\t*/ internalEvents$1[\"FunctionFailed\"] = \"inngest/function.failed\";\n    internalEvents$1[\"FunctionInvoked\"] = \"inngest/function.invoked\";\n    internalEvents$1[\"FunctionFinished\"] = \"inngest/function.finished\";\n    internalEvents$1[\"FunctionCancelled\"] = \"inngest/function.cancelled\";\n    internalEvents$1[\"ScheduledTimer\"] = \"inngest/scheduled.timer\";\n    return internalEvents$1;\n}({});\nconst logPrefix = chalk__WEBPACK_IMPORTED_MODULE_0__.magenta.bold(\"[Inngest]\");\nconst debugPrefix = \"inngest\";\nconst dummyEventKey = \"NO_EVENT_KEY_SET\";\nlet syncKind = /* @__PURE__ */ function(syncKind$1) {\n    syncKind$1[\"InBand\"] = \"in_band\";\n    syncKind$1[\"OutOfBand\"] = \"out_of_band\";\n    return syncKind$1;\n}({});\n/**\n* The execution models the SDK is aware of.\n*\n* This is used in a number of places to ensure all execution versions are\n* accounted for for a given operation.\n*/ let ExecutionVersion = /* @__PURE__ */ function(ExecutionVersion$1) {\n    /**\n\t* Very legacy, initial version of the executor. Uses hashed op objects and\n\t* `pos` to determine the order of execution and which ops to run.\n\t*\n\t* Very stubborn about determinism.\n\t*/ ExecutionVersion$1[ExecutionVersion$1[\"V0\"] = 0] = \"V0\";\n    /**\n\t* Uses a more flexible approach to execution and is more lenient about\n\t* determinism, allowing non-step async actions and non-determinism.\n\t*\n\t* Nowhere near as stubborn about determinism and so can silently migrate\n\t* between versions after bug fixes.\n\t*/ ExecutionVersion$1[ExecutionVersion$1[\"V1\"] = 1] = \"V1\";\n    /**\n\t* Identical to V1, but allows the Executor to optimize parallel calls, hugely\n\t* reducing traffic going to/from the SDK.\n\t*/ ExecutionVersion$1[ExecutionVersion$1[\"V2\"] = 2] = \"V2\";\n    return ExecutionVersion$1;\n}({});\n/**\n* Default maximum number of retries for function/step executions.\n*/ const defaultMaxRetries = 3;\n//#endregion\n //# sourceMappingURL=consts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NvbnN0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBCO0FBRTFCLCtCQUErQjtBQUMvQjs7Ozs7Ozs7QUFRQSxHQUNBLElBQUlDLFlBQVksYUFBYSxHQUFHLFNBQVNDLFdBQVc7SUFDbkRBLFdBQVcsQ0FBQyxXQUFXLEdBQUc7SUFDMUJBLFdBQVcsQ0FBQyxPQUFPLEdBQUc7SUFDdEJBLFdBQVcsQ0FBQyxRQUFRLEdBQUc7SUFDdkJBLFdBQVcsQ0FBQyxTQUFTLEdBQUc7SUFDeEIsT0FBT0E7QUFDUixFQUFFLENBQUM7QUFDSCxJQUFJQyxRQUFRLGFBQWEsR0FBRyxTQUFTQyxPQUFPO0lBQzNDQSxPQUFPLENBQUMsUUFBUSxHQUFHO0lBQ25CLE9BQU9BO0FBQ1IsRUFBRSxDQUFDO0FBQ0gsSUFBSUMsVUFBVSxhQUFhLEdBQUcsU0FBU0MsU0FBUztJQUMvQ0EsU0FBUyxDQUFDLG9CQUFvQixHQUFHO0lBQ2pDQSxTQUFTLENBQUMsNEJBQTRCLEdBQUc7SUFDekNBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRztJQUMvQjs7Q0FFQSxHQUNBQSxTQUFTLENBQUMsc0JBQXNCLEdBQUc7SUFDbkNBLFNBQVMsQ0FBQyxxQkFBcUIsR0FBRztJQUNsQ0EsU0FBUyxDQUFDLGlCQUFpQixHQUFHO0lBQzlCQSxTQUFTLENBQUMseUJBQXlCLEdBQUc7SUFDdENBLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRztJQUNqQ0EsU0FBUyxDQUFDLG1CQUFtQixHQUFHO0lBQ2hDQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7SUFDaENBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRztJQUMvQkEsU0FBUyxDQUFDLG1CQUFtQixHQUFHO0lBQ2hDQSxTQUFTLENBQUMsaUJBQWlCLEdBQUc7SUFDOUJBLFNBQVMsQ0FBQyx5QkFBeUIsR0FBRztJQUN0Q0EsU0FBUyxDQUFDLHFDQUFxQyxHQUFHO0lBQ2xEOzs7Q0FHQSxHQUNB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OztBQUtBLEdBQ0EsSUFBSUMsbUJBQW1CLGFBQWEsR0FBRyxTQUFTQyxrQkFBa0I7SUFDakU7Ozs7O0NBS0EsR0FDQUEsa0JBQWtCLENBQUNBLGtCQUFrQixDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDbkQ7Ozs7OztDQU1BLEdBQ0FBLGtCQUFrQixDQUFDQSxrQkFBa0IsQ0FBQyxLQUFLLEdBQUcsRUFBRSxHQUFHO0lBQ25EOzs7Q0FHQSxHQUNBQSxrQkFBa0IsQ0FBQ0Esa0JBQWtCLENBQUMsS0FBSyxHQUFHLEVBQUUsR0FBRztJQUNuRCxPQUFPQTtBQUNSLEVBQUUsQ0FBQztBQUNIOztBQUVBLEdBQ0EsTUFBTUMsb0JBQW9CO0FBRTFCLFlBQVk7QUFDeU8sQ0FDclAsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvY29uc3RzLmpzPzc2MDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuXG4vLyNyZWdpb24gc3JjL2hlbHBlcnMvY29uc3RzLnRzXG4vKipcbiogS2V5cyBmb3IgYWNjZXNzaW5nIHF1ZXJ5IHBhcmFtZXRlcnMgaW5jbHVkZWQgaW4gcmVxdWVzdHMgZnJvbSBJbm5nZXN0IHRvIHJ1blxuKiBmdW5jdGlvbnMuXG4qXG4qIFVzZWQgaW50ZXJuYWxseSB0byBjcmVhdGUgaGFuZGxlcnMgdXNpbmcgYElubmdlc3RDb21tSGFuZGxlcmAsIGJ1dCBjYW4gYmVcbiogaW1wb3J0ZWQgdG8gYmUgdXNlZCBpZiBjcmVhdGluZyBhIGN1c3RvbSBoYW5kbGVyIG91dHNpZGUgb2YgdGhlIHBhY2thZ2UuXG4qXG4qIEBwdWJsaWNcbiovXG5sZXQgcXVlcnlLZXlzID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKHF1ZXJ5S2V5cyQxKSB7XG5cdHF1ZXJ5S2V5cyQxW1wiRGVwbG95SWRcIl0gPSBcImRlcGxveUlkXCI7XG5cdHF1ZXJ5S2V5cyQxW1wiRm5JZFwiXSA9IFwiZm5JZFwiO1xuXHRxdWVyeUtleXMkMVtcIlByb2JlXCJdID0gXCJwcm9iZVwiO1xuXHRxdWVyeUtleXMkMVtcIlN0ZXBJZFwiXSA9IFwic3RlcElkXCI7XG5cdHJldHVybiBxdWVyeUtleXMkMTtcbn0oe30pO1xubGV0IHByb2JlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKHByb2JlJDEpIHtcblx0cHJvYmUkMVtcIlRydXN0XCJdID0gXCJ0cnVzdFwiO1xuXHRyZXR1cm4gcHJvYmUkMTtcbn0oe30pO1xubGV0IGVudktleXMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oZW52S2V5cyQxKSB7XG5cdGVudktleXMkMVtcIklubmdlc3RTaWduaW5nS2V5XCJdID0gXCJJTk5HRVNUX1NJR05JTkdfS0VZXCI7XG5cdGVudktleXMkMVtcIklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2tcIl0gPSBcIklOTkdFU1RfU0lHTklOR19LRVlfRkFMTEJBQ0tcIjtcblx0ZW52S2V5cyQxW1wiSW5uZ2VzdEV2ZW50S2V5XCJdID0gXCJJTk5HRVNUX0VWRU5UX0tFWVwiO1xuXHQvKipcblx0KiBAZGVwcmVjYXRlZCBSZW1vdmVkIGluIHYzLiBVc2Uge0BsaW5rIElubmdlc3RCYXNlVXJsfSBpbnN0ZWFkLlxuXHQqL1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0RGV2U2VydmVyVXJsXCJdID0gXCJJTk5HRVNUX0RFVlNFUlZFUl9VUkxcIjtcblx0ZW52S2V5cyQxW1wiSW5uZ2VzdEVudmlyb25tZW50XCJdID0gXCJJTk5HRVNUX0VOVlwiO1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0QmFzZVVybFwiXSA9IFwiSU5OR0VTVF9CQVNFX1VSTFwiO1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0RXZlbnRBcGlCYXNlVXJsXCJdID0gXCJJTk5HRVNUX0VWRU5UX0FQSV9CQVNFX1VSTFwiO1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0QXBpQmFzZVVybFwiXSA9IFwiSU5OR0VTVF9BUElfQkFTRV9VUkxcIjtcblx0ZW52S2V5cyQxW1wiSW5uZ2VzdFNlcnZlSG9zdFwiXSA9IFwiSU5OR0VTVF9TRVJWRV9IT1NUXCI7XG5cdGVudktleXMkMVtcIklubmdlc3RTZXJ2ZVBhdGhcIl0gPSBcIklOTkdFU1RfU0VSVkVfUEFUSFwiO1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0TG9nTGV2ZWxcIl0gPSBcIklOTkdFU1RfTE9HX0xFVkVMXCI7XG5cdGVudktleXMkMVtcIklubmdlc3RTdHJlYW1pbmdcIl0gPSBcIklOTkdFU1RfU1RSRUFNSU5HXCI7XG5cdGVudktleXMkMVtcIklubmdlc3REZXZNb2RlXCJdID0gXCJJTk5HRVNUX0RFVlwiO1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0QWxsb3dJbkJhbmRTeW5jXCJdID0gXCJJTk5HRVNUX0FMTE9XX0lOX0JBTkRfU1lOQ1wiO1xuXHRlbnZLZXlzJDFbXCJJbm5nZXN0Q29ubmVjdE1heFdvcmtlckNvbmN1cnJlbmN5XCJdID0gXCJJTk5HRVNUX0NPTk5FQ1RfTUFYX1dPUktFUl9DT05DVVJSRU5DWVwiO1xuXHQvKipcblx0KiBAZGVwcmVjYXRlZCBJdCdzIHVua25vd24gd2hhdCB0aGlzIGVudiB2YXIgd2FzIHVzZWQgZm9yLCBidXQgd2UgZG8gbm90XG5cdCogcHJvdmlkZSBleHBsaWNpdCBzdXBwb3J0IGZvciBpdC4gUHJlZmVyIHVzaW5nIGBJTk5HRVNUX0VOVmAgaW5zdGVhZC5cblx0Ki9cblx0ZW52S2V5cyQxW1wiQnJhbmNoTmFtZVwiXSA9IFwiQlJBTkNIX05BTUVcIjtcblx0LyoqXG5cdCogVGhlIGdpdCBicmFuY2ggb2YgdGhlIGNvbW1pdCB0aGUgZGVwbG95bWVudCB3YXMgdHJpZ2dlcmVkIGJ5LiBFeGFtcGxlOlxuXHQqIGBpbXByb3ZlLWFib3V0LXBhZ2VgLlxuXHQqXG5cdCoge0BsaW5rIGh0dHBzOi8vdmVyY2VsLmNvbS9kb2NzL2NvbmNlcHRzL3Byb2plY3RzL2Vudmlyb25tZW50LXZhcmlhYmxlcy9zeXN0ZW0tZW52aXJvbm1lbnQtdmFyaWFibGVzI3N5c3RlbS1lbnZpcm9ubWVudC12YXJpYWJsZXN9XG5cdCovXG5cdGVudktleXMkMVtcIlZlcmNlbEJyYW5jaFwiXSA9IFwiVkVSQ0VMX0dJVF9DT01NSVRfUkVGXCI7XG5cdC8qKlxuXHQqIEV4cGVjdGVkIHRvIGJlIGBcIjFcImAgaWYgZGVmaW5lZC5cblx0Ki9cblx0ZW52S2V5cyQxW1wiSXNWZXJjZWxcIl0gPSBcIlZFUkNFTFwiO1xuXHQvKipcblx0KiBUaGUgYnJhbmNoIG5hbWUgb2YgdGhlIGN1cnJlbnQgZGVwbG95bWVudC4gTWF5IG9ubHkgYmUgYWNjZXNzaWJsZSBhdCBidWlsZFxuXHQqIHRpbWUsIGJ1dCBpbmNsdWRlZCBoZXJlIGp1c3QgaW4gY2FzZS5cblx0KlxuXHQqIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuY2xvdWRmbGFyZS5jb20vcGFnZXMvcGxhdGZvcm0vYnVpbGQtY29uZmlndXJhdGlvbi8jZW52aXJvbm1lbnQtdmFyaWFibGVzfVxuXHQqL1xuXHRlbnZLZXlzJDFbXCJDbG91ZGZsYXJlUGFnZXNCcmFuY2hcIl0gPSBcIkNGX1BBR0VTX0JSQU5DSFwiO1xuXHQvKipcblx0KiBFeHBlY3RlZCB0byBiZSBgXCIxXCJgIGlmIGRlZmluZWQuXG5cdCovXG5cdGVudktleXMkMVtcIklzQ2xvdWRmbGFyZVBhZ2VzXCJdID0gXCJDRl9QQUdFU1wiO1xuXHQvKipcblx0KiBUaGUgYnJhbmNoIG5hbWUgb2YgdGhlIGRlcGxveW1lbnQgZnJvbSBHaXQgdG8gTmV0bGlmeSwgaWYgYXZhaWxhYmxlLlxuXHQqXG5cdCoge0BsaW5rIGh0dHBzOi8vZG9jcy5uZXRsaWZ5LmNvbS9jb25maWd1cmUtYnVpbGRzL2Vudmlyb25tZW50LXZhcmlhYmxlcy8jZ2l0LW1ldGFkYXRhfVxuXHQqL1xuXHRlbnZLZXlzJDFbXCJOZXRsaWZ5QnJhbmNoXCJdID0gXCJCUkFOQ0hcIjtcblx0LyoqXG5cdCogRXhwZWN0ZWQgdG8gYmUgYFwidHJ1ZVwiYCBpZiBkZWZpbmVkLlxuXHQqL1xuXHRlbnZLZXlzJDFbXCJJc05ldGxpZnlcIl0gPSBcIk5FVExJRllcIjtcblx0LyoqXG5cdCogVGhlIEdpdCBicmFuY2ggZm9yIGEgc2VydmljZSBvciBkZXBsb3kuXG5cdCpcblx0KiB7QGxpbmsgaHR0cHM6Ly9yZW5kZXIuY29tL2RvY3MvZW52aXJvbm1lbnQtdmFyaWFibGVzI2FsbC1zZXJ2aWNlc31cblx0Ki9cblx0ZW52S2V5cyQxW1wiUmVuZGVyQnJhbmNoXCJdID0gXCJSRU5ERVJfR0lUX0JSQU5DSFwiO1xuXHQvKipcblx0KiBFeHBlY3RlZCB0byBiZSBgXCJ0cnVlXCJgIGlmIGRlZmluZWQuXG5cdCovXG5cdGVudktleXMkMVtcIklzUmVuZGVyXCJdID0gXCJSRU5ERVJcIjtcblx0LyoqXG5cdCogVGhlIGJyYW5jaCB0aGF0IHRyaWdnZXJlZCB0aGUgZGVwbG95bWVudC4gRXhhbXBsZTogYG1haW5gXG5cdCpcblx0KiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnJhaWx3YXkuYXBwL2RldmVsb3AvdmFyaWFibGVzI3JhaWx3YXktcHJvdmlkZWQtdmFyaWFibGVzfVxuXHQqL1xuXHRlbnZLZXlzJDFbXCJSYWlsd2F5QnJhbmNoXCJdID0gXCJSQUlMV0FZX0dJVF9CUkFOQ0hcIjtcblx0LyoqXG5cdCogVGhlIHJhaWx3YXkgZW52aXJvbm1lbnQgZm9yIHRoZSBkZXBsb3ltZW50LiBFeGFtcGxlOiBgcHJvZHVjdGlvbmBcblx0KlxuXHQqIHtAbGluayBodHRwczovL2RvY3MucmFpbHdheS5hcHAvZGV2ZWxvcC92YXJpYWJsZXMjcmFpbHdheS1wcm92aWRlZC12YXJpYWJsZXN9XG5cdCovXG5cdGVudktleXMkMVtcIlJhaWx3YXlFbnZpcm9ubWVudFwiXSA9IFwiUkFJTFdBWV9FTlZJUk9OTUVOVFwiO1xuXHRlbnZLZXlzJDFbXCJWZXJjZWxFbnZLZXlcIl0gPSBcIlZFUkNFTF9FTlZcIjtcblx0ZW52S2V5cyQxW1wiT3BlbkFpQXBpS2V5XCJdID0gXCJPUEVOQUlfQVBJX0tFWVwiO1xuXHRlbnZLZXlzJDFbXCJHZW1pbmlBcGlLZXlcIl0gPSBcIkdFTUlOSV9BUElfS0VZXCI7XG5cdGVudktleXMkMVtcIkFudGhyb3BpY0FwaUtleVwiXSA9IFwiQU5USFJPUElDX0FQSV9LRVlcIjtcblx0cmV0dXJuIGVudktleXMkMTtcbn0oe30pO1xuLyoqXG4qIEtleXMgZm9yIGFjY2Vzc2luZyBoZWFkZXJzIGluY2x1ZGVkIGluIHJlcXVlc3RzIGZyb20gSW5uZ2VzdCB0byBydW5cbiogZnVuY3Rpb25zLlxuKlxuKiBVc2VkIGludGVybmFsbHkgdG8gY3JlYXRlIGhhbmRsZXJzIHVzaW5nIGBJbm5nZXN0Q29tbUhhbmRsZXJgLCBidXQgY2FuIGJlXG4qIGltcG9ydGVkIHRvIGJlIHVzZWQgaWYgY3JlYXRpbmcgYSBjdXN0b20gaGFuZGxlciBvdXRzaWRlIG9mIHRoZSBwYWNrYWdlLlxuKlxuKiBAcHVibGljXG4qL1xubGV0IGhlYWRlcktleXMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oaGVhZGVyS2V5cyQxKSB7XG5cdGhlYWRlcktleXMkMVtcIkNvbnRlbnRUeXBlXCJdID0gXCJjb250ZW50LXR5cGVcIjtcblx0aGVhZGVyS2V5cyQxW1wiSG9zdFwiXSA9IFwiaG9zdFwiO1xuXHRoZWFkZXJLZXlzJDFbXCJGb3J3YXJkZWRGb3JcIl0gPSBcIngtZm9yd2FyZGVkLWZvclwiO1xuXHRoZWFkZXJLZXlzJDFbXCJSZWFsSXBcIl0gPSBcIngtcmVhbC1pcFwiO1xuXHRoZWFkZXJLZXlzJDFbXCJMb2NhdGlvblwiXSA9IFwibG9jYXRpb25cIjtcblx0aGVhZGVyS2V5cyQxW1wiQ29udGVudExlbmd0aFwiXSA9IFwiY29udGVudC1sZW5ndGhcIjtcblx0aGVhZGVyS2V5cyQxW1wiU2lnbmF0dXJlXCJdID0gXCJ4LWlubmdlc3Qtc2lnbmF0dXJlXCI7XG5cdGhlYWRlcktleXMkMVtcIlNka1ZlcnNpb25cIl0gPSBcIngtaW5uZ2VzdC1zZGtcIjtcblx0aGVhZGVyS2V5cyQxW1wiRW52aXJvbm1lbnRcIl0gPSBcIngtaW5uZ2VzdC1lbnZcIjtcblx0aGVhZGVyS2V5cyQxW1wiUGxhdGZvcm1cIl0gPSBcIngtaW5uZ2VzdC1wbGF0Zm9ybVwiO1xuXHRoZWFkZXJLZXlzJDFbXCJGcmFtZXdvcmtcIl0gPSBcIngtaW5uZ2VzdC1mcmFtZXdvcmtcIjtcblx0aGVhZGVyS2V5cyQxW1wiTm9SZXRyeVwiXSA9IFwieC1pbm5nZXN0LW5vLXJldHJ5XCI7XG5cdGhlYWRlcktleXMkMVtcIlJlcXVlc3RWZXJzaW9uXCJdID0gXCJ4LWlubmdlc3QtcmVxLXZlcnNpb25cIjtcblx0aGVhZGVyS2V5cyQxW1wiUmV0cnlBZnRlclwiXSA9IFwicmV0cnktYWZ0ZXJcIjtcblx0aGVhZGVyS2V5cyQxW1wiSW5uZ2VzdFNlcnZlcktpbmRcIl0gPSBcIngtaW5uZ2VzdC1zZXJ2ZXIta2luZFwiO1xuXHRoZWFkZXJLZXlzJDFbXCJJbm5nZXN0RXhwZWN0ZWRTZXJ2ZXJLaW5kXCJdID0gXCJ4LWlubmdlc3QtZXhwZWN0ZWQtc2VydmVyLWtpbmRcIjtcblx0aGVhZGVyS2V5cyQxW1wiSW5uZ2VzdFN5bmNLaW5kXCJdID0gXCJ4LWlubmdlc3Qtc3luYy1raW5kXCI7XG5cdGhlYWRlcktleXMkMVtcIkV2ZW50SWRTZWVkXCJdID0gXCJ4LWlubmdlc3QtZXZlbnQtaWQtc2VlZFwiO1xuXHRoZWFkZXJLZXlzJDFbXCJUcmFjZVBhcmVudFwiXSA9IFwidHJhY2VwYXJlbnRcIjtcblx0aGVhZGVyS2V5cyQxW1wiVHJhY2VTdGF0ZVwiXSA9IFwidHJhY2VzdGF0ZVwiO1xuXHRoZWFkZXJLZXlzJDFbXCJJbm5nZXN0UnVuSWRcIl0gPSBcIngtcnVuLWlkXCI7XG5cdHJldHVybiBoZWFkZXJLZXlzJDE7XG59KHt9KTtcbi8qKlxuKiBIZWFkZXJzIHRoYXQgYXJlIGZvcndhcmRlZCBmcm9tIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdoZW4gYW4gSW5uZ2VzdCBmdW5jdGlvblxuKiBpcyBpbnZva2VkLlxuKi9cbmNvbnN0IGZvcndhcmRlZEhlYWRlcnMgPSBbaGVhZGVyS2V5cy5UcmFjZVBhcmVudCwgaGVhZGVyS2V5cy5UcmFjZVN0YXRlXTtcbmNvbnN0IGRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuaW5uZ2VzdC5jb20vXCI7XG5jb25zdCBkZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCA9IFwiaHR0cHM6Ly9pbm4uZ3MvXCI7XG5jb25zdCBkZWZhdWx0RGV2U2VydmVySG9zdCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4Mjg4L1wiO1xuLyoqXG4qIEV2ZW50cyB0aGF0IElubmdlc3QgbWF5IHNlbmQgaW50ZXJuYWxseSB0aGF0IGNhbiBiZSB1c2VkIHRvIHRyaWdnZXJcbiogZnVuY3Rpb25zLlxuKlxuKiBAcHVibGljXG4qL1xubGV0IGludGVybmFsRXZlbnRzID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKGludGVybmFsRXZlbnRzJDEpIHtcblx0LyoqXG5cdCogQSBmdW5jdGlvbiBoYXMgZmFpbGVkIGFmdGVyIGV4aGF1c3RpbmcgYWxsIGF2YWlsYWJsZSByZXRyaWVzLiBUaGlzIGV2ZW50XG5cdCogd2lsbCBjb250YWluIHRoZSBvcmlnaW5hbCBldmVudCBhbmQgdGhlIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBmYWlsdXJlLlxuXHQqL1xuXHRpbnRlcm5hbEV2ZW50cyQxW1wiRnVuY3Rpb25GYWlsZWRcIl0gPSBcImlubmdlc3QvZnVuY3Rpb24uZmFpbGVkXCI7XG5cdGludGVybmFsRXZlbnRzJDFbXCJGdW5jdGlvbkludm9rZWRcIl0gPSBcImlubmdlc3QvZnVuY3Rpb24uaW52b2tlZFwiO1xuXHRpbnRlcm5hbEV2ZW50cyQxW1wiRnVuY3Rpb25GaW5pc2hlZFwiXSA9IFwiaW5uZ2VzdC9mdW5jdGlvbi5maW5pc2hlZFwiO1xuXHRpbnRlcm5hbEV2ZW50cyQxW1wiRnVuY3Rpb25DYW5jZWxsZWRcIl0gPSBcImlubmdlc3QvZnVuY3Rpb24uY2FuY2VsbGVkXCI7XG5cdGludGVybmFsRXZlbnRzJDFbXCJTY2hlZHVsZWRUaW1lclwiXSA9IFwiaW5uZ2VzdC9zY2hlZHVsZWQudGltZXJcIjtcblx0cmV0dXJuIGludGVybmFsRXZlbnRzJDE7XG59KHt9KTtcbmNvbnN0IGxvZ1ByZWZpeCA9IGNoYWxrLm1hZ2VudGEuYm9sZChcIltJbm5nZXN0XVwiKTtcbmNvbnN0IGRlYnVnUHJlZml4ID0gXCJpbm5nZXN0XCI7XG5jb25zdCBkdW1teUV2ZW50S2V5ID0gXCJOT19FVkVOVF9LRVlfU0VUXCI7XG5sZXQgc3luY0tpbmQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oc3luY0tpbmQkMSkge1xuXHRzeW5jS2luZCQxW1wiSW5CYW5kXCJdID0gXCJpbl9iYW5kXCI7XG5cdHN5bmNLaW5kJDFbXCJPdXRPZkJhbmRcIl0gPSBcIm91dF9vZl9iYW5kXCI7XG5cdHJldHVybiBzeW5jS2luZCQxO1xufSh7fSk7XG4vKipcbiogVGhlIGV4ZWN1dGlvbiBtb2RlbHMgdGhlIFNESyBpcyBhd2FyZSBvZi5cbipcbiogVGhpcyBpcyB1c2VkIGluIGEgbnVtYmVyIG9mIHBsYWNlcyB0byBlbnN1cmUgYWxsIGV4ZWN1dGlvbiB2ZXJzaW9ucyBhcmVcbiogYWNjb3VudGVkIGZvciBmb3IgYSBnaXZlbiBvcGVyYXRpb24uXG4qL1xubGV0IEV4ZWN1dGlvblZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oRXhlY3V0aW9uVmVyc2lvbiQxKSB7XG5cdC8qKlxuXHQqIFZlcnkgbGVnYWN5LCBpbml0aWFsIHZlcnNpb24gb2YgdGhlIGV4ZWN1dG9yLiBVc2VzIGhhc2hlZCBvcCBvYmplY3RzIGFuZFxuXHQqIGBwb3NgIHRvIGRldGVybWluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uIGFuZCB3aGljaCBvcHMgdG8gcnVuLlxuXHQqXG5cdCogVmVyeSBzdHViYm9ybiBhYm91dCBkZXRlcm1pbmlzbS5cblx0Ki9cblx0RXhlY3V0aW9uVmVyc2lvbiQxW0V4ZWN1dGlvblZlcnNpb24kMVtcIlYwXCJdID0gMF0gPSBcIlYwXCI7XG5cdC8qKlxuXHQqIFVzZXMgYSBtb3JlIGZsZXhpYmxlIGFwcHJvYWNoIHRvIGV4ZWN1dGlvbiBhbmQgaXMgbW9yZSBsZW5pZW50IGFib3V0XG5cdCogZGV0ZXJtaW5pc20sIGFsbG93aW5nIG5vbi1zdGVwIGFzeW5jIGFjdGlvbnMgYW5kIG5vbi1kZXRlcm1pbmlzbS5cblx0KlxuXHQqIE5vd2hlcmUgbmVhciBhcyBzdHViYm9ybiBhYm91dCBkZXRlcm1pbmlzbSBhbmQgc28gY2FuIHNpbGVudGx5IG1pZ3JhdGVcblx0KiBiZXR3ZWVuIHZlcnNpb25zIGFmdGVyIGJ1ZyBmaXhlcy5cblx0Ki9cblx0RXhlY3V0aW9uVmVyc2lvbiQxW0V4ZWN1dGlvblZlcnNpb24kMVtcIlYxXCJdID0gMV0gPSBcIlYxXCI7XG5cdC8qKlxuXHQqIElkZW50aWNhbCB0byBWMSwgYnV0IGFsbG93cyB0aGUgRXhlY3V0b3IgdG8gb3B0aW1pemUgcGFyYWxsZWwgY2FsbHMsIGh1Z2VseVxuXHQqIHJlZHVjaW5nIHRyYWZmaWMgZ29pbmcgdG8vZnJvbSB0aGUgU0RLLlxuXHQqL1xuXHRFeGVjdXRpb25WZXJzaW9uJDFbRXhlY3V0aW9uVmVyc2lvbiQxW1wiVjJcIl0gPSAyXSA9IFwiVjJcIjtcblx0cmV0dXJuIEV4ZWN1dGlvblZlcnNpb24kMTtcbn0oe30pO1xuLyoqXG4qIERlZmF1bHQgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyBmb3IgZnVuY3Rpb24vc3RlcCBleGVjdXRpb25zLlxuKi9cbmNvbnN0IGRlZmF1bHRNYXhSZXRyaWVzID0gMztcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBFeGVjdXRpb25WZXJzaW9uLCBkZWJ1Z1ByZWZpeCwgZGVmYXVsdERldlNlcnZlckhvc3QsIGRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCwgZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwsIGRlZmF1bHRNYXhSZXRyaWVzLCBkdW1teUV2ZW50S2V5LCBlbnZLZXlzLCBmb3J3YXJkZWRIZWFkZXJzLCBoZWFkZXJLZXlzLCBpbnRlcm5hbEV2ZW50cywgbG9nUHJlZml4LCBwcm9iZSwgcXVlcnlLZXlzLCBzeW5jS2luZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RzLmpzLm1hcCJdLCJuYW1lcyI6WyJjaGFsayIsInF1ZXJ5S2V5cyIsInF1ZXJ5S2V5cyQxIiwicHJvYmUiLCJwcm9iZSQxIiwiZW52S2V5cyIsImVudktleXMkMSIsImhlYWRlcktleXMiLCJoZWFkZXJLZXlzJDEiLCJmb3J3YXJkZWRIZWFkZXJzIiwiVHJhY2VQYXJlbnQiLCJUcmFjZVN0YXRlIiwiZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsIiwiZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwiLCJkZWZhdWx0RGV2U2VydmVySG9zdCIsImludGVybmFsRXZlbnRzIiwiaW50ZXJuYWxFdmVudHMkMSIsImxvZ1ByZWZpeCIsIm1hZ2VudGEiLCJib2xkIiwiZGVidWdQcmVmaXgiLCJkdW1teUV2ZW50S2V5Iiwic3luY0tpbmQiLCJzeW5jS2luZCQxIiwiRXhlY3V0aW9uVmVyc2lvbiIsIkV4ZWN1dGlvblZlcnNpb24kMSIsImRlZmF1bHRNYXhSZXRyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/crypto.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/crypto.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEntropy: () => (/* binding */ createEntropy)\n/* harmony export */ });\n//#region src/helpers/crypto.ts\n/**\n* Create a cryptographically secure random value.\n*\n* @throws {Error} If the crypto module is not available.\n*/ function createEntropy(byteLength) {\n    const bytes = new Uint8Array(byteLength);\n    const { crypto } = globalThis;\n    if (!crypto) throw new Error(\"missing crypto module\");\n    if (!crypto.getRandomValues) throw new Error(\"missing crypto.getRandomValues\");\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\n//#endregion\n //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsK0JBQStCO0FBQy9COzs7O0FBSUEsR0FDQSxTQUFTQSxjQUFjQyxVQUFVO0lBQ2hDLE1BQU1DLFFBQVEsSUFBSUMsV0FBV0Y7SUFDN0IsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0M7SUFDbkIsSUFBSSxDQUFDRCxRQUFRLE1BQU0sSUFBSUUsTUFBTTtJQUM3QixJQUFJLENBQUNGLE9BQU9HLGVBQWUsRUFBRSxNQUFNLElBQUlELE1BQU07SUFDN0NGLE9BQU9HLGVBQWUsQ0FBQ0w7SUFDdkIsT0FBT0E7QUFDUjtBQUVBLFlBQVk7QUFDYSxDQUN6QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9jcnlwdG8uanM/MzYzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL2hlbHBlcnMvY3J5cHRvLnRzXG4vKipcbiogQ3JlYXRlIGEgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHJhbmRvbSB2YWx1ZS5cbipcbiogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjcnlwdG8gbW9kdWxlIGlzIG5vdCBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gY3JlYXRlRW50cm9weShieXRlTGVuZ3RoKSB7XG5cdGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG5cdGNvbnN0IHsgY3J5cHRvIH0gPSBnbG9iYWxUaGlzO1xuXHRpZiAoIWNyeXB0bykgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjcnlwdG8gbW9kdWxlXCIpO1xuXHRpZiAoIWNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wiKTtcblx0Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG5cdHJldHVybiBieXRlcztcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBjcmVhdGVFbnRyb3B5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZUVudHJvcHkiLCJieXRlTGVuZ3RoIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwiY3J5cHRvIiwiZ2xvYmFsVGhpcyIsIkVycm9yIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/devserver.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/devserver.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devServerAvailable: () => (/* binding */ devServerAvailable),\n/* harmony export */   devServerUrl: () => (/* binding */ devServerUrl)\n/* harmony export */ });\n/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n\n\n//#region src/helpers/devserver.ts\n/**\n* Attempts to contact the dev server, returning a boolean indicating whether or\n* not it was successful.\n*\n* @example devServerUrl(process.env[envKeys.DevServerUrl], \"/your-path\")\n*/ const devServerAvailable = async (host = _consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultDevServerHost, fetch)=>{\n    try {\n        await (await fetch(devServerUrl(host, \"/dev\").toString())).json();\n        return true;\n    } catch (_e) {\n        return false;\n    }\n};\n/**\n* devServerUrl returns a full URL for the given path name.\n*\n* Because Cloudflare/V8 platforms don't allow process.env, you are expected\n* to pass in the host from the dev server env key:\n*\n* @example devServerUrl(processEnv(envKeys.DevServerUrl), \"/your-path\")\n* @example devServerUrl(\"http://localhost:8288/\", \"/your-path\")\n*/ const devServerUrl = (host = devServerHost$1(), pathname = \"\")=>{\n    return new URL(pathname, host.includes(\"://\") ? host : `http://${host}`);\n};\n/**\n* devServerHost exports the development server's domain by inspecting env\n* variables, or returns the default development server URL.\n*\n* This guarantees a specific URL as a string, as opposed to the env export\n* which only returns a value of the env var is set.\n*/ const devServerHost$1 = ()=>(0,_env_js__WEBPACK_IMPORTED_MODULE_1__.devServerHost)() || _consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultDevServerHost;\n//#endregion\n //# sourceMappingURL=devserver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2RldnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBQ1Y7QUFFekMsa0NBQWtDO0FBQ2xDOzs7OztBQUtBLEdBQ0EsTUFBTUUscUJBQXFCLE9BQU9DLE9BQU9ILDREQUFvQixFQUFFSTtJQUM5RCxJQUFJO1FBQ0gsTUFBTSxDQUFDLE1BQU1BLE1BQU1DLGFBQWFGLE1BQU0sUUFBUUcsUUFBUSxHQUFFLEVBQUdDLElBQUk7UUFDL0QsT0FBTztJQUNSLEVBQUUsT0FBT0MsSUFBSTtRQUNaLE9BQU87SUFDUjtBQUNEO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNSCxlQUFlLENBQUNGLE9BQU9NLGlCQUFpQixFQUFFQyxXQUFXLEVBQUU7SUFDNUQsT0FBTyxJQUFJQyxJQUFJRCxVQUFVUCxLQUFLUyxRQUFRLENBQUMsU0FBU1QsT0FBTyxDQUFDLE9BQU8sRUFBRUEsS0FBSyxDQUFDO0FBQ3hFO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTU0sa0JBQWtCLElBQU1SLHNEQUFhQSxNQUFNRCw0REFBb0JBO0FBRXJFLFlBQVk7QUFDZ0MsQ0FDNUMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvZGV2c2VydmVyLmpzPzUxZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdERldlNlcnZlckhvc3QgfSBmcm9tIFwiLi9jb25zdHMuanNcIjtcbmltcG9ydCB7IGRldlNlcnZlckhvc3QgfSBmcm9tIFwiLi9lbnYuanNcIjtcblxuLy8jcmVnaW9uIHNyYy9oZWxwZXJzL2RldnNlcnZlci50c1xuLyoqXG4qIEF0dGVtcHRzIHRvIGNvbnRhY3QgdGhlIGRldiBzZXJ2ZXIsIHJldHVybmluZyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yXG4qIG5vdCBpdCB3YXMgc3VjY2Vzc2Z1bC5cbipcbiogQGV4YW1wbGUgZGV2U2VydmVyVXJsKHByb2Nlc3MuZW52W2VudktleXMuRGV2U2VydmVyVXJsXSwgXCIveW91ci1wYXRoXCIpXG4qL1xuY29uc3QgZGV2U2VydmVyQXZhaWxhYmxlID0gYXN5bmMgKGhvc3QgPSBkZWZhdWx0RGV2U2VydmVySG9zdCwgZmV0Y2gpID0+IHtcblx0dHJ5IHtcblx0XHRhd2FpdCAoYXdhaXQgZmV0Y2goZGV2U2VydmVyVXJsKGhvc3QsIFwiL2RldlwiKS50b1N0cmluZygpKSkuanNvbigpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChfZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbi8qKlxuKiBkZXZTZXJ2ZXJVcmwgcmV0dXJucyBhIGZ1bGwgVVJMIGZvciB0aGUgZ2l2ZW4gcGF0aCBuYW1lLlxuKlxuKiBCZWNhdXNlIENsb3VkZmxhcmUvVjggcGxhdGZvcm1zIGRvbid0IGFsbG93IHByb2Nlc3MuZW52LCB5b3UgYXJlIGV4cGVjdGVkXG4qIHRvIHBhc3MgaW4gdGhlIGhvc3QgZnJvbSB0aGUgZGV2IHNlcnZlciBlbnYga2V5OlxuKlxuKiBAZXhhbXBsZSBkZXZTZXJ2ZXJVcmwocHJvY2Vzc0VudihlbnZLZXlzLkRldlNlcnZlclVybCksIFwiL3lvdXItcGF0aFwiKVxuKiBAZXhhbXBsZSBkZXZTZXJ2ZXJVcmwoXCJodHRwOi8vbG9jYWxob3N0OjgyODgvXCIsIFwiL3lvdXItcGF0aFwiKVxuKi9cbmNvbnN0IGRldlNlcnZlclVybCA9IChob3N0ID0gZGV2U2VydmVySG9zdCQxKCksIHBhdGhuYW1lID0gXCJcIikgPT4ge1xuXHRyZXR1cm4gbmV3IFVSTChwYXRobmFtZSwgaG9zdC5pbmNsdWRlcyhcIjovL1wiKSA/IGhvc3QgOiBgaHR0cDovLyR7aG9zdH1gKTtcbn07XG4vKipcbiogZGV2U2VydmVySG9zdCBleHBvcnRzIHRoZSBkZXZlbG9wbWVudCBzZXJ2ZXIncyBkb21haW4gYnkgaW5zcGVjdGluZyBlbnZcbiogdmFyaWFibGVzLCBvciByZXR1cm5zIHRoZSBkZWZhdWx0IGRldmVsb3BtZW50IHNlcnZlciBVUkwuXG4qXG4qIFRoaXMgZ3VhcmFudGVlcyBhIHNwZWNpZmljIFVSTCBhcyBhIHN0cmluZywgYXMgb3Bwb3NlZCB0byB0aGUgZW52IGV4cG9ydFxuKiB3aGljaCBvbmx5IHJldHVybnMgYSB2YWx1ZSBvZiB0aGUgZW52IHZhciBpcyBzZXQuXG4qL1xuY29uc3QgZGV2U2VydmVySG9zdCQxID0gKCkgPT4gZGV2U2VydmVySG9zdCgpIHx8IGRlZmF1bHREZXZTZXJ2ZXJIb3N0O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGRldlNlcnZlckF2YWlsYWJsZSwgZGV2U2VydmVyVXJsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXZzZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHREZXZTZXJ2ZXJIb3N0IiwiZGV2U2VydmVySG9zdCIsImRldlNlcnZlckF2YWlsYWJsZSIsImhvc3QiLCJmZXRjaCIsImRldlNlcnZlclVybCIsInRvU3RyaW5nIiwianNvbiIsIl9lIiwiZGV2U2VydmVySG9zdCQxIiwicGF0aG5hbWUiLCJVUkwiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/devserver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/enum.js":
/*!**********************************************!*\
  !*** ./node_modules/inngest/helpers/enum.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   enumFromValue: () => (/* binding */ enumFromValue)\n/* harmony export */ });\n//#region src/helpers/enum.ts\n/**\n* Returns the value of an enum from a string value.\n*\n* If the value given is not a value from the enum, `undefined` is returned.\n*/ const enumFromValue = (enumType, value)=>{\n    if (Object.values(enumType).includes(value)) return value;\n};\n//#endregion\n //# sourceMappingURL=enum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2VudW0uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZCQUE2QjtBQUM3Qjs7OztBQUlBLEdBQ0EsTUFBTUEsZ0JBQWdCLENBQUNDLFVBQVVDO0lBQ2hDLElBQUlDLE9BQU9DLE1BQU0sQ0FBQ0gsVUFBVUksUUFBUSxDQUFDSCxRQUFRLE9BQU9BO0FBQ3JEO0FBRUEsWUFBWTtBQUNhLENBQ3pCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1hcHAvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2VudW0uanM/NmYxYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL2hlbHBlcnMvZW51bS50c1xuLyoqXG4qIFJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGVudW0gZnJvbSBhIHN0cmluZyB2YWx1ZS5cbipcbiogSWYgdGhlIHZhbHVlIGdpdmVuIGlzIG5vdCBhIHZhbHVlIGZyb20gdGhlIGVudW0sIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuKi9cbmNvbnN0IGVudW1Gcm9tVmFsdWUgPSAoZW51bVR5cGUsIHZhbHVlKSA9PiB7XG5cdGlmIChPYmplY3QudmFsdWVzKGVudW1UeXBlKS5pbmNsdWRlcyh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgZW51bUZyb21WYWx1ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiXSwibmFtZXMiOlsiZW51bUZyb21WYWx1ZSIsImVudW1UeXBlIiwidmFsdWUiLCJPYmplY3QiLCJ2YWx1ZXMiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/enum.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/env.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/env.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   allProcessEnv: () => (/* binding */ allProcessEnv),\n/* harmony export */   devServerHost: () => (/* binding */ devServerHost),\n/* harmony export */   getEnvironmentName: () => (/* binding */ getEnvironmentName),\n/* harmony export */   getFetch: () => (/* binding */ getFetch),\n/* harmony export */   getMode: () => (/* binding */ getMode),\n/* harmony export */   getPlatformName: () => (/* binding */ getPlatformName),\n/* harmony export */   getResponse: () => (/* binding */ getResponse),\n/* harmony export */   inngestHeaders: () => (/* binding */ inngestHeaders),\n/* harmony export */   parseAsBoolean: () => (/* binding */ parseAsBoolean),\n/* harmony export */   platformSupportsStreaming: () => (/* binding */ platformSupportsStreaming),\n/* harmony export */   processEnv: () => (/* binding */ processEnv)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\n/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n\n\n\n\n//#region src/helpers/env.ts\n/**\n* devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL\n* environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).\n*\n* If not found this returns undefined, indicating that the env var has not been set.\n*\n* @example devServerHost()\n*/ const devServerHost = (env = allProcessEnv())=>{\n    const prefixes = [\n        \"REACT_APP_\",\n        \"NEXT_PUBLIC_\"\n    ];\n    return [\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestBaseUrl,\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestDevMode\n    ].flatMap((key)=>{\n        return prefixes.map((prefix)=>{\n            return env[prefix + key];\n        });\n    }).find((v)=>{\n        if (!v) return;\n        try {\n            return Boolean(new URL(v));\n        } catch  {}\n    });\n};\nconst checkFns = ((checks)=>checks)({\n    equals: (actual, expected)=>actual === expected,\n    \"starts with\": (actual, expected)=>expected ? actual?.startsWith(expected) ?? false : false,\n    \"is truthy\": (actual)=>Boolean(actual),\n    \"is truthy but not\": (actual, expected)=>Boolean(actual) && actual !== expected\n});\nconst prodChecks = [\n    [\n        \"CF_PAGES\",\n        \"equals\",\n        \"1\"\n    ],\n    [\n        \"CONTEXT\",\n        \"starts with\",\n        \"prod\"\n    ],\n    [\n        \"ENVIRONMENT\",\n        \"starts with\",\n        \"prod\"\n    ],\n    [\n        \"NODE_ENV\",\n        \"starts with\",\n        \"prod\"\n    ],\n    [\n        \"VERCEL_ENV\",\n        \"starts with\",\n        \"prod\"\n    ],\n    [\n        \"DENO_DEPLOYMENT_ID\",\n        \"is truthy\"\n    ],\n    [\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.VercelEnvKey,\n        \"is truthy but not\",\n        \"development\"\n    ],\n    [\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsNetlify,\n        \"is truthy\"\n    ],\n    [\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsRender,\n        \"is truthy\"\n    ],\n    [\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.RailwayBranch,\n        \"is truthy\"\n    ],\n    [\n        _consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsCloudflarePages,\n        \"is truthy\"\n    ]\n];\nvar Mode = class {\n    constructor({ type, isExplicit, explicitDevUrl, env = allProcessEnv() }){\n        this.env = env;\n        this.type = type;\n        this.isExplicit = isExplicit || Boolean(explicitDevUrl);\n        this.explicitDevUrl = explicitDevUrl;\n    }\n    get isDev() {\n        return this.type === \"dev\";\n    }\n    get isCloud() {\n        return this.type === \"cloud\";\n    }\n    get isInferred() {\n        return !this.isExplicit;\n    }\n    /**\n\t* If we are explicitly in a particular mode, retrieve the URL that we are\n\t* sure we should be using, not considering any environment variables or other\n\t* influences.\n\t*/ getExplicitUrl(defaultCloudUrl) {\n        if (!this.isExplicit) return;\n        if (this.explicitDevUrl) return this.explicitDevUrl.href;\n        if (this.isCloud) return defaultCloudUrl;\n        if (this.isDev) return _consts_js__WEBPACK_IMPORTED_MODULE_0__.defaultDevServerHost;\n    }\n};\n/**\n* Returns the mode of the current environment, based off of either passed\n* environment variables or `process.env`, or explicit settings.\n*/ const getMode = ({ env = allProcessEnv(), client, explicitMode } = {})=>{\n    if (explicitMode) return new Mode({\n        type: explicitMode,\n        isExplicit: true,\n        env\n    });\n    if (client?.[\"mode\"].isExplicit) return client[\"mode\"];\n    if (_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestDevMode in env) {\n        if (typeof env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestDevMode] === \"string\") try {\n            return new Mode({\n                type: \"dev\",\n                isExplicit: true,\n                explicitDevUrl: new URL(env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestDevMode]),\n                env\n            });\n        } catch  {}\n        const envIsDev = parseAsBoolean(env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestDevMode]);\n        if (typeof envIsDev === \"boolean\") return new Mode({\n            type: envIsDev ? \"dev\" : \"cloud\",\n            isExplicit: true,\n            env\n        });\n    }\n    return new Mode({\n        type: prodChecks.some(([key, checkKey, expected])=>{\n            return checkFns[checkKey]((0,_strings_js__WEBPACK_IMPORTED_MODULE_1__.stringifyUnknown)(env[key]), expected);\n        }) ? \"cloud\" : \"dev\",\n        isExplicit: false,\n        env\n    });\n};\n/**\n* getEnvironmentName returns the suspected branch name for this environment by\n* searching through a set of common environment variables.\n*\n* This could be used to determine if we're on a branch deploy or not, though it\n* should be noted that we don't know if this is the default branch or not.\n*/ const getEnvironmentName = (env = allProcessEnv())=>{\n    /**\n\t* Order is important; more than one of these env vars may be set, so ensure\n\t* that we check the most specific, most reliable env vars first.\n\t*/ return env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.InngestEnvironment] || env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.BranchName] || env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.VercelBranch] || env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.NetlifyBranch] || env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.CloudflarePagesBranch] || env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.RenderBranch] || env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.RailwayBranch];\n};\nconst processEnv = (key)=>{\n    return allProcessEnv()[key];\n};\n/**\n* allProcessEnv returns the current process environment variables, or an empty\n* object if they cannot be read, making sure we support environments other than\n* Node such as Deno, too.\n*\n* Using this ensures we don't dangerously access `process.env` in environments\n* where it may not be defined, such as Deno or the browser.\n*/ const allProcessEnv = ()=>{\n    try {\n        if (process.env) return process.env;\n    } catch (_err) {}\n    try {\n        const env = Deno.env.toObject();\n        if (env) return env;\n    } catch (_err) {}\n    try {\n        const env = Netlify.env.toObject();\n        if (env) return env;\n    } catch (_err) {}\n    return {};\n};\n/**\n* Generate a standardised set of headers based on input and environment\n* variables.\n*\n*\n*/ const inngestHeaders = (opts)=>{\n    const sdkVersion = `inngest-js:v${_version_js__WEBPACK_IMPORTED_MODULE_2__.version}`;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": sdkVersion,\n        [_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.SdkVersion]: sdkVersion\n    };\n    if (opts?.framework) headers[_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.Framework] = opts.framework;\n    if (opts?.expectedServerKind) headers[_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;\n    const env = {\n        ...allProcessEnv(),\n        ...opts?.env\n    };\n    const inngestEnv = opts?.inngestEnv || getEnvironmentName(env);\n    if (inngestEnv) headers[_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.Environment] = inngestEnv;\n    const platform = getPlatformName(env);\n    if (platform) headers[_consts_js__WEBPACK_IMPORTED_MODULE_0__.headerKeys.Platform] = platform;\n    return {\n        ...headers,\n        ...opts?.client?.[\"headers\"],\n        ...opts?.extras\n    };\n};\n/**\n* A set of checks that, given an environment, will return `true` if the current\n* environment is running on the platform with the given name.\n*/ const platformChecks = {\n    vercel: (env)=>env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsVercel] === \"1\" || typeof EdgeRuntime === \"string\",\n    netlify: (env)=>env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsNetlify] === \"true\",\n    \"cloudflare-pages\": (env)=>env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsCloudflarePages] === \"1\",\n    render: (env)=>env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.IsRender] === \"true\",\n    railway: (env)=>Boolean(env[_consts_js__WEBPACK_IMPORTED_MODULE_0__.envKeys.RailwayEnvironment])\n};\n/**\n* A set of checks that, given an environment, will return `true` if the current\n* environment and platform supports streaming responses back to Inngest.\n*\n* Streaming capability is both framework and platform-based. Frameworks are\n* supported in serve handlers, and platforms are checked here.\n*\n* As such, this record declares which platforms we explicitly support for\n* streaming and is used by {@link platformSupportsStreaming}.\n*/ const streamingChecks = {\n    vercel: (_framework, _env)=>typeof EdgeRuntime === \"string\",\n    \"cloudflare-pages\": ()=>true\n};\nconst getPlatformName = (env)=>{\n    return Object.keys(platformChecks).find((key)=>{\n        return platformChecks[key](env);\n    });\n};\n/**\n* Returns `true` if we believe the current environment supports streaming\n* responses back to Inngest.\n*\n* We run a check directly related to the platform we believe we're running on,\n* usually based on environment variables.\n*/ const platformSupportsStreaming = (framework, env = allProcessEnv())=>{\n    return streamingChecks[getPlatformName(env)]?.(framework, env) ?? false;\n};\n/**\n* A unique symbol used to mark a custom fetch implementation. We wrap the\n* implementations to provide some extra control when handling errors.\n*/ const CUSTOM_FETCH_MARKER = Symbol(\"Custom fetch implementation\");\n/**\n* Given a potential fetch function, return the fetch function to use based on\n* this and the environment.\n*/ const getFetch = (givenFetch)=>{\n    /**\n\t* If we've explicitly been given a fetch function, use that.\n\t*/ if (givenFetch) {\n        if (CUSTOM_FETCH_MARKER in givenFetch) return givenFetch;\n        /**\n\t\t* We wrap the given fetch function to provide some extra control when\n\t\t* handling errors.\n\t\t*/ const customFetch = async (...args)=>{\n            try {\n                return await givenFetch(...args);\n            } catch (err) {\n                /**\n\t\t\t\t* Capture warnings that are not simple fetch failures and highlight\n\t\t\t\t* them for the user.\n\t\t\t\t*\n\t\t\t\t* We also use this opportunity to log the causing error, as code higher\n\t\t\t\t* up the stack will likely abstract this.\n\t\t\t\t*/ if (!(err instanceof Error) || !err.message?.startsWith(\"fetch failed\")) {\n                    console.warn(\"A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.\");\n                    console.error(err);\n                }\n                throw err;\n            }\n        };\n        /**\n\t\t* Mark the custom fetch implementation so that we can identify it later, in\n\t\t* addition to adding some runtime properties to it to make it seem as much\n\t\t* like the original fetch as possible.\n\t\t*/ Object.defineProperties(customFetch, {\n            [CUSTOM_FETCH_MARKER]: {},\n            name: {\n                value: givenFetch.name\n            },\n            length: {\n                value: givenFetch.length\n            }\n        });\n        return customFetch;\n    }\n    /**\n\t* Browser or Node 18+\n\t*/ try {\n        if (typeof globalThis !== \"undefined\" && \"fetch\" in globalThis) return fetch.bind(globalThis);\n    } catch (_err) {}\n    /**\n\t* Existing polyfilled fetch\n\t*/ if (typeof fetch !== \"undefined\") return fetch;\n    /**\n\t* Environments where fetch cannot be found and must be polyfilled\n\t*/ return (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_3__.__require)(\"cross-fetch\");\n};\n/**\n* If `Response` isn't included in this environment, it's probably an earlier\n* Node env that isn't already polyfilling. This function returns either the\n* native `Response` or a polyfilled one.\n*/ const getResponse = ()=>{\n    if (typeof Response !== \"undefined\") return Response;\n    return (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_3__.__require)(\"cross-fetch\").Response;\n};\n/**\n* Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n* environment variables that could be a selection of different values such as\n* `\"true\"`, `\"1\"`.\n*\n* If the value could not be confidently parsed as a `boolean` or was seen to be\n* `undefined`, this function returns `undefined`.\n*/ const parseAsBoolean = (value)=>{\n    if (typeof value === \"boolean\") return value;\n    if (typeof value === \"number\") return Boolean(value);\n    if (typeof value === \"string\") {\n        const trimmed = value.trim().toLowerCase();\n        if (trimmed === \"undefined\") return;\n        if ([\n            \"true\",\n            \"1\"\n        ].includes(trimmed)) return true;\n        return false;\n    }\n};\n//#endregion\n //# sourceMappingURL=env.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vudi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ3BCO0FBQ2dDO0FBQ3hCO0FBRWhELDRCQUE0QjtBQUM1Qjs7Ozs7OztBQU9BLEdBQ0EsTUFBTU0sZ0JBQWdCLENBQUNDLE1BQU1DLGVBQWU7SUFDM0MsTUFBTUMsV0FBVztRQUFDO1FBQWM7S0FBZTtJQUMvQyxPQUFPO1FBQUNOLCtDQUFPQSxDQUFDTyxjQUFjO1FBQUVQLCtDQUFPQSxDQUFDUSxjQUFjO0tBQUMsQ0FBQ0MsT0FBTyxDQUFDLENBQUNDO1FBQ2hFLE9BQU9KLFNBQVNLLEdBQUcsQ0FBQyxDQUFDQztZQUNwQixPQUFPUixHQUFHLENBQUNRLFNBQVNGLElBQUk7UUFDekI7SUFDRCxHQUFHRyxJQUFJLENBQUMsQ0FBQ0M7UUFDUixJQUFJLENBQUNBLEdBQUc7UUFDUixJQUFJO1lBQ0gsT0FBT0MsUUFBUSxJQUFJQyxJQUFJRjtRQUN4QixFQUFFLE9BQU0sQ0FBQztJQUNWO0FBQ0Q7QUFDQSxNQUFNRyxXQUFXLENBQUMsQ0FBQ0MsU0FBV0EsTUFBSyxFQUFHO0lBQ3JDQyxRQUFRLENBQUNDLFFBQVFDLFdBQWFELFdBQVdDO0lBQ3pDLGVBQWUsQ0FBQ0QsUUFBUUMsV0FBYUEsV0FBV0QsUUFBUUUsV0FBV0QsYUFBYSxRQUFRO0lBQ3hGLGFBQWEsQ0FBQ0QsU0FBV0wsUUFBUUs7SUFDakMscUJBQXFCLENBQUNBLFFBQVFDLFdBQWFOLFFBQVFLLFdBQVdBLFdBQVdDO0FBQzFFO0FBQ0EsTUFBTUUsYUFBYTtJQUNsQjtRQUNDO1FBQ0E7UUFDQTtLQUNBO0lBQ0Q7UUFDQztRQUNBO1FBQ0E7S0FDQTtJQUNEO1FBQ0M7UUFDQTtRQUNBO0tBQ0E7SUFDRDtRQUNDO1FBQ0E7UUFDQTtLQUNBO0lBQ0Q7UUFDQztRQUNBO1FBQ0E7S0FDQTtJQUNEO1FBQUM7UUFBc0I7S0FBWTtJQUNuQztRQUNDdkIsK0NBQU9BLENBQUN3QixZQUFZO1FBQ3BCO1FBQ0E7S0FDQTtJQUNEO1FBQUN4QiwrQ0FBT0EsQ0FBQ3lCLFNBQVM7UUFBRTtLQUFZO0lBQ2hDO1FBQUN6QiwrQ0FBT0EsQ0FBQzBCLFFBQVE7UUFBRTtLQUFZO0lBQy9CO1FBQUMxQiwrQ0FBT0EsQ0FBQzJCLGFBQWE7UUFBRTtLQUFZO0lBQ3BDO1FBQUMzQiwrQ0FBT0EsQ0FBQzRCLGlCQUFpQjtRQUFFO0tBQVk7Q0FDeEM7QUFDRCxJQUFJQyxPQUFPO0lBUVZDLFlBQVksRUFBRUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLGNBQWMsRUFBRTdCLE1BQU1DLGVBQWUsRUFBRSxDQUFFO1FBQ3hFLElBQUksQ0FBQ0QsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQzJCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFVBQVUsR0FBR0EsY0FBY2pCLFFBQVFrQjtRQUN4QyxJQUFJLENBQUNBLGNBQWMsR0FBR0E7SUFDdkI7SUFDQSxJQUFJQyxRQUFRO1FBQ1gsT0FBTyxJQUFJLENBQUNILElBQUksS0FBSztJQUN0QjtJQUNBLElBQUlJLFVBQVU7UUFDYixPQUFPLElBQUksQ0FBQ0osSUFBSSxLQUFLO0lBQ3RCO0lBQ0EsSUFBSUssYUFBYTtRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDSixVQUFVO0lBQ3hCO0lBQ0E7Ozs7Q0FJQSxHQUNBSyxlQUFlQyxlQUFlLEVBQUU7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ04sVUFBVSxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDQyxjQUFjLEVBQUUsT0FBTyxJQUFJLENBQUNBLGNBQWMsQ0FBQ00sSUFBSTtRQUN4RCxJQUFJLElBQUksQ0FBQ0osT0FBTyxFQUFFLE9BQU9HO1FBQ3pCLElBQUksSUFBSSxDQUFDSixLQUFLLEVBQUUsT0FBT25DLDREQUFvQkE7SUFDNUM7QUFDRDtBQUNBOzs7QUFHQSxHQUNBLE1BQU15QyxVQUFVLENBQUMsRUFBRXBDLE1BQU1DLGVBQWUsRUFBRW9DLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3BFLElBQUlBLGNBQWMsT0FBTyxJQUFJYixLQUFLO1FBQ2pDRSxNQUFNVztRQUNOVixZQUFZO1FBQ1o1QjtJQUNEO0lBQ0EsSUFBSXFDLFFBQVEsQ0FBQyxPQUFPLENBQUNULFlBQVksT0FBT1MsTUFBTSxDQUFDLE9BQU87SUFDdEQsSUFBSXpDLCtDQUFPQSxDQUFDUSxjQUFjLElBQUlKLEtBQUs7UUFDbEMsSUFBSSxPQUFPQSxHQUFHLENBQUNKLCtDQUFPQSxDQUFDUSxjQUFjLENBQUMsS0FBSyxVQUFVLElBQUk7WUFDeEQsT0FBTyxJQUFJcUIsS0FBSztnQkFDZkUsTUFBTTtnQkFDTkMsWUFBWTtnQkFDWkMsZ0JBQWdCLElBQUlqQixJQUFJWixHQUFHLENBQUNKLCtDQUFPQSxDQUFDUSxjQUFjLENBQUM7Z0JBQ25ESjtZQUNEO1FBQ0QsRUFBRSxPQUFNLENBQUM7UUFDVCxNQUFNdUMsV0FBV0MsZUFBZXhDLEdBQUcsQ0FBQ0osK0NBQU9BLENBQUNRLGNBQWMsQ0FBQztRQUMzRCxJQUFJLE9BQU9tQyxhQUFhLFdBQVcsT0FBTyxJQUFJZCxLQUFLO1lBQ2xERSxNQUFNWSxXQUFXLFFBQVE7WUFDekJYLFlBQVk7WUFDWjVCO1FBQ0Q7SUFDRDtJQUNBLE9BQU8sSUFBSXlCLEtBQUs7UUFDZkUsTUFBTVIsV0FBV3NCLElBQUksQ0FBQyxDQUFDLENBQUNuQyxLQUFLb0MsVUFBVXpCLFNBQVM7WUFDL0MsT0FBT0osUUFBUSxDQUFDNkIsU0FBUyxDQUFDNUMsNkRBQWdCQSxDQUFDRSxHQUFHLENBQUNNLElBQUksR0FBR1c7UUFDdkQsS0FBSyxVQUFVO1FBQ2ZXLFlBQVk7UUFDWjVCO0lBQ0Q7QUFDRDtBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU0yQyxxQkFBcUIsQ0FBQzNDLE1BQU1DLGVBQWU7SUFDaEQ7OztDQUdBLEdBQ0EsT0FBT0QsR0FBRyxDQUFDSiwrQ0FBT0EsQ0FBQ2dELGtCQUFrQixDQUFDLElBQUk1QyxHQUFHLENBQUNKLCtDQUFPQSxDQUFDaUQsVUFBVSxDQUFDLElBQUk3QyxHQUFHLENBQUNKLCtDQUFPQSxDQUFDa0QsWUFBWSxDQUFDLElBQUk5QyxHQUFHLENBQUNKLCtDQUFPQSxDQUFDbUQsYUFBYSxDQUFDLElBQUkvQyxHQUFHLENBQUNKLCtDQUFPQSxDQUFDb0QscUJBQXFCLENBQUMsSUFBSWhELEdBQUcsQ0FBQ0osK0NBQU9BLENBQUNxRCxZQUFZLENBQUMsSUFBSWpELEdBQUcsQ0FBQ0osK0NBQU9BLENBQUMyQixhQUFhLENBQUM7QUFDOU47QUFDQSxNQUFNMkIsYUFBYSxDQUFDNUM7SUFDbkIsT0FBT0wsZUFBZSxDQUFDSyxJQUFJO0FBQzVCO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU1MLGdCQUFnQjtJQUNyQixJQUFJO1FBQ0gsSUFBSWtELFFBQVFuRCxHQUFHLEVBQUUsT0FBT21ELFFBQVFuRCxHQUFHO0lBQ3BDLEVBQUUsT0FBT29ELE1BQU0sQ0FBQztJQUNoQixJQUFJO1FBQ0gsTUFBTXBELE1BQU1xRCxLQUFLckQsR0FBRyxDQUFDc0QsUUFBUTtRQUM3QixJQUFJdEQsS0FBSyxPQUFPQTtJQUNqQixFQUFFLE9BQU9vRCxNQUFNLENBQUM7SUFDaEIsSUFBSTtRQUNILE1BQU1wRCxNQUFNdUQsUUFBUXZELEdBQUcsQ0FBQ3NELFFBQVE7UUFDaEMsSUFBSXRELEtBQUssT0FBT0E7SUFDakIsRUFBRSxPQUFPb0QsTUFBTSxDQUFDO0lBQ2hCLE9BQU8sQ0FBQztBQUNUO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNSSxpQkFBaUIsQ0FBQ0M7SUFDdkIsTUFBTUMsYUFBYSxDQUFDLFlBQVksRUFBRWhFLGdEQUFPQSxDQUFDLENBQUM7SUFDM0MsTUFBTWlFLFVBQVU7UUFDZixnQkFBZ0I7UUFDaEIsY0FBY0Q7UUFDZCxDQUFDN0Qsa0RBQVVBLENBQUMrRCxVQUFVLENBQUMsRUFBRUY7SUFDMUI7SUFDQSxJQUFJRCxNQUFNSSxXQUFXRixPQUFPLENBQUM5RCxrREFBVUEsQ0FBQ2lFLFNBQVMsQ0FBQyxHQUFHTCxLQUFLSSxTQUFTO0lBQ25FLElBQUlKLE1BQU1NLG9CQUFvQkosT0FBTyxDQUFDOUQsa0RBQVVBLENBQUNtRSx5QkFBeUIsQ0FBQyxHQUFHUCxLQUFLTSxrQkFBa0I7SUFDckcsTUFBTS9ELE1BQU07UUFDWCxHQUFHQyxlQUFlO1FBQ2xCLEdBQUd3RCxNQUFNekQsR0FBRztJQUNiO0lBQ0EsTUFBTWlFLGFBQWFSLE1BQU1RLGNBQWN0QixtQkFBbUIzQztJQUMxRCxJQUFJaUUsWUFBWU4sT0FBTyxDQUFDOUQsa0RBQVVBLENBQUNxRSxXQUFXLENBQUMsR0FBR0Q7SUFDbEQsTUFBTUUsV0FBV0MsZ0JBQWdCcEU7SUFDakMsSUFBSW1FLFVBQVVSLE9BQU8sQ0FBQzlELGtEQUFVQSxDQUFDd0UsUUFBUSxDQUFDLEdBQUdGO0lBQzdDLE9BQU87UUFDTixHQUFHUixPQUFPO1FBQ1YsR0FBR0YsTUFBTXBCLFFBQVEsQ0FBQyxVQUFVO1FBQzVCLEdBQUdvQixNQUFNYSxNQUFNO0lBQ2hCO0FBQ0Q7QUFDQTs7O0FBR0EsR0FDQSxNQUFNQyxpQkFBaUI7SUFDdEJDLFFBQVEsQ0FBQ3hFLE1BQVFBLEdBQUcsQ0FBQ0osK0NBQU9BLENBQUM2RSxRQUFRLENBQUMsS0FBSyxPQUFPLE9BQU9DLGdCQUFnQjtJQUN6RUMsU0FBUyxDQUFDM0UsTUFBUUEsR0FBRyxDQUFDSiwrQ0FBT0EsQ0FBQ3lCLFNBQVMsQ0FBQyxLQUFLO0lBQzdDLG9CQUFvQixDQUFDckIsTUFBUUEsR0FBRyxDQUFDSiwrQ0FBT0EsQ0FBQzRCLGlCQUFpQixDQUFDLEtBQUs7SUFDaEVvRCxRQUFRLENBQUM1RSxNQUFRQSxHQUFHLENBQUNKLCtDQUFPQSxDQUFDMEIsUUFBUSxDQUFDLEtBQUs7SUFDM0N1RCxTQUFTLENBQUM3RSxNQUFRVyxRQUFRWCxHQUFHLENBQUNKLCtDQUFPQSxDQUFDa0Ysa0JBQWtCLENBQUM7QUFDMUQ7QUFDQTs7Ozs7Ozs7O0FBU0EsR0FDQSxNQUFNQyxrQkFBa0I7SUFDdkJQLFFBQVEsQ0FBQ1EsWUFBWUMsT0FBUyxPQUFPUCxnQkFBZ0I7SUFDckQsb0JBQW9CLElBQU07QUFDM0I7QUFDQSxNQUFNTixrQkFBa0IsQ0FBQ3BFO0lBQ3hCLE9BQU9rRixPQUFPQyxJQUFJLENBQUNaLGdCQUFnQjlELElBQUksQ0FBQyxDQUFDSDtRQUN4QyxPQUFPaUUsY0FBYyxDQUFDakUsSUFBSSxDQUFDTjtJQUM1QjtBQUNEO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTW9GLDRCQUE0QixDQUFDdkIsV0FBVzdELE1BQU1DLGVBQWU7SUFDbEUsT0FBTzhFLGVBQWUsQ0FBQ1gsZ0JBQWdCcEUsS0FBSyxHQUFHNkQsV0FBVzdELFFBQVE7QUFDbkU7QUFDQTs7O0FBR0EsR0FDQSxNQUFNcUYsc0JBQXNCQyxPQUFPO0FBQ25DOzs7QUFHQSxHQUNBLE1BQU1DLFdBQVcsQ0FBQ0M7SUFDakI7O0NBRUEsR0FDQSxJQUFJQSxZQUFZO1FBQ2YsSUFBSUgsdUJBQXVCRyxZQUFZLE9BQU9BO1FBQzlDOzs7RUFHQSxHQUNBLE1BQU1DLGNBQWMsT0FBTyxHQUFHQztZQUM3QixJQUFJO2dCQUNILE9BQU8sTUFBTUYsY0FBY0U7WUFDNUIsRUFBRSxPQUFPQyxLQUFLO2dCQUNiOzs7Ozs7SUFNQSxHQUNBLElBQUksQ0FBRUEsQ0FBQUEsZUFBZUMsS0FBSSxLQUFNLENBQUNELElBQUlFLE9BQU8sRUFBRTNFLFdBQVcsaUJBQWlCO29CQUN4RTRFLFFBQVFDLElBQUksQ0FBQztvQkFDYkQsUUFBUUUsS0FBSyxDQUFDTDtnQkFDZjtnQkFDQSxNQUFNQTtZQUNQO1FBQ0Q7UUFDQTs7OztFQUlBLEdBQ0FULE9BQU9lLGdCQUFnQixDQUFDUixhQUFhO1lBQ3BDLENBQUNKLG9CQUFvQixFQUFFLENBQUM7WUFDeEJhLE1BQU07Z0JBQUVDLE9BQU9YLFdBQVdVLElBQUk7WUFBQztZQUMvQkUsUUFBUTtnQkFBRUQsT0FBT1gsV0FBV1ksTUFBTTtZQUFDO1FBQ3BDO1FBQ0EsT0FBT1g7SUFDUjtJQUNBOztDQUVBLEdBQ0EsSUFBSTtRQUNILElBQUksT0FBT1ksZUFBZSxlQUFlLFdBQVdBLFlBQVksT0FBT0MsTUFBTUMsSUFBSSxDQUFDRjtJQUNuRixFQUFFLE9BQU9qRCxNQUFNLENBQUM7SUFDaEI7O0NBRUEsR0FDQSxJQUFJLE9BQU9rRCxVQUFVLGFBQWEsT0FBT0E7SUFDekM7O0NBRUEsR0FDQSxPQUFPN0csdUVBQVNBLENBQUM7QUFDbEI7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTStHLGNBQWM7SUFDbkIsSUFBSSxPQUFPQyxhQUFhLGFBQWEsT0FBT0E7SUFDNUMsT0FBT2hILHVFQUFTQSxDQUFDLGVBQWVnSCxRQUFRO0FBQ3pDO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU1qRSxpQkFBaUIsQ0FBQzJEO0lBQ3ZCLElBQUksT0FBT0EsVUFBVSxXQUFXLE9BQU9BO0lBQ3ZDLElBQUksT0FBT0EsVUFBVSxVQUFVLE9BQU94RixRQUFRd0Y7SUFDOUMsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDOUIsTUFBTU8sVUFBVVAsTUFBTVEsSUFBSSxHQUFHQyxXQUFXO1FBQ3hDLElBQUlGLFlBQVksYUFBYTtRQUM3QixJQUFJO1lBQUM7WUFBUTtTQUFJLENBQUNHLFFBQVEsQ0FBQ0gsVUFBVSxPQUFPO1FBQzVDLE9BQU87SUFDUjtBQUNEO0FBRUEsWUFBWTtBQUM4SyxDQUMxTCwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9lbnYuanM/ZjI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3JlcXVpcmUgfSBmcm9tIFwiLi4vX3ZpcnR1YWwvcm9sbGRvd25fcnVudGltZS5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi92ZXJzaW9uLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0RGV2U2VydmVySG9zdCwgZW52S2V5cywgaGVhZGVyS2V5cyB9IGZyb20gXCIuL2NvbnN0cy5qc1wiO1xuaW1wb3J0IHsgc3RyaW5naWZ5VW5rbm93biB9IGZyb20gXCIuL3N0cmluZ3MuanNcIjtcblxuLy8jcmVnaW9uIHNyYy9oZWxwZXJzL2Vudi50c1xuLyoqXG4qIGRldlNlcnZlckhvc3QgcmV0dXJucyB0aGUgZGV2IHNlcnZlciBob3N0IGJ5IHNlYXJjaGluZyBmb3IgdGhlIElOTkdFU1RfREVWU0VSVkVSX1VSTFxuKiBlbnZpcm9ubWVudCB2YXJpYWJsZSAocGx1cyBwcm9qZWN0IHByZWZpeGNlcyBmb3IgZWcuIHJlYWN0LCBzdWNoIGFzIFJFQUNUX0FQUF9JTk5HRVNUX0RFVlNFUlZFUl9VUkwpLlxuKlxuKiBJZiBub3QgZm91bmQgdGhpcyByZXR1cm5zIHVuZGVmaW5lZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBlbnYgdmFyIGhhcyBub3QgYmVlbiBzZXQuXG4qXG4qIEBleGFtcGxlIGRldlNlcnZlckhvc3QoKVxuKi9cbmNvbnN0IGRldlNlcnZlckhvc3QgPSAoZW52ID0gYWxsUHJvY2Vzc0VudigpKSA9PiB7XG5cdGNvbnN0IHByZWZpeGVzID0gW1wiUkVBQ1RfQVBQX1wiLCBcIk5FWFRfUFVCTElDX1wiXTtcblx0cmV0dXJuIFtlbnZLZXlzLklubmdlc3RCYXNlVXJsLCBlbnZLZXlzLklubmdlc3REZXZNb2RlXS5mbGF0TWFwKChrZXkpID0+IHtcblx0XHRyZXR1cm4gcHJlZml4ZXMubWFwKChwcmVmaXgpID0+IHtcblx0XHRcdHJldHVybiBlbnZbcHJlZml4ICsga2V5XTtcblx0XHR9KTtcblx0fSkuZmluZCgodikgPT4ge1xuXHRcdGlmICghdikgcmV0dXJuO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gQm9vbGVhbihuZXcgVVJMKHYpKTtcblx0XHR9IGNhdGNoIHt9XG5cdH0pO1xufTtcbmNvbnN0IGNoZWNrRm5zID0gKChjaGVja3MpID0+IGNoZWNrcykoe1xuXHRlcXVhbHM6IChhY3R1YWwsIGV4cGVjdGVkKSA9PiBhY3R1YWwgPT09IGV4cGVjdGVkLFxuXHRcInN0YXJ0cyB3aXRoXCI6IChhY3R1YWwsIGV4cGVjdGVkKSA9PiBleHBlY3RlZCA/IGFjdHVhbD8uc3RhcnRzV2l0aChleHBlY3RlZCkgPz8gZmFsc2UgOiBmYWxzZSxcblx0XCJpcyB0cnV0aHlcIjogKGFjdHVhbCkgPT4gQm9vbGVhbihhY3R1YWwpLFxuXHRcImlzIHRydXRoeSBidXQgbm90XCI6IChhY3R1YWwsIGV4cGVjdGVkKSA9PiBCb29sZWFuKGFjdHVhbCkgJiYgYWN0dWFsICE9PSBleHBlY3RlZFxufSk7XG5jb25zdCBwcm9kQ2hlY2tzID0gW1xuXHRbXG5cdFx0XCJDRl9QQUdFU1wiLFxuXHRcdFwiZXF1YWxzXCIsXG5cdFx0XCIxXCJcblx0XSxcblx0W1xuXHRcdFwiQ09OVEVYVFwiLFxuXHRcdFwic3RhcnRzIHdpdGhcIixcblx0XHRcInByb2RcIlxuXHRdLFxuXHRbXG5cdFx0XCJFTlZJUk9OTUVOVFwiLFxuXHRcdFwic3RhcnRzIHdpdGhcIixcblx0XHRcInByb2RcIlxuXHRdLFxuXHRbXG5cdFx0XCJOT0RFX0VOVlwiLFxuXHRcdFwic3RhcnRzIHdpdGhcIixcblx0XHRcInByb2RcIlxuXHRdLFxuXHRbXG5cdFx0XCJWRVJDRUxfRU5WXCIsXG5cdFx0XCJzdGFydHMgd2l0aFwiLFxuXHRcdFwicHJvZFwiXG5cdF0sXG5cdFtcIkRFTk9fREVQTE9ZTUVOVF9JRFwiLCBcImlzIHRydXRoeVwiXSxcblx0W1xuXHRcdGVudktleXMuVmVyY2VsRW52S2V5LFxuXHRcdFwiaXMgdHJ1dGh5IGJ1dCBub3RcIixcblx0XHRcImRldmVsb3BtZW50XCJcblx0XSxcblx0W2VudktleXMuSXNOZXRsaWZ5LCBcImlzIHRydXRoeVwiXSxcblx0W2VudktleXMuSXNSZW5kZXIsIFwiaXMgdHJ1dGh5XCJdLFxuXHRbZW52S2V5cy5SYWlsd2F5QnJhbmNoLCBcImlzIHRydXRoeVwiXSxcblx0W2VudktleXMuSXNDbG91ZGZsYXJlUGFnZXMsIFwiaXMgdHJ1dGh5XCJdXG5dO1xudmFyIE1vZGUgPSBjbGFzcyB7XG5cdHR5cGU7XG5cdC8qKlxuXHQqIFdoZXRoZXIgdGhlIG1vZGUgd2FzIGV4cGxpY2l0bHkgc2V0LCBvciBpbmZlcnJlZCBmcm9tIG90aGVyIHNvdXJjZXMuXG5cdCovXG5cdGlzRXhwbGljaXQ7XG5cdGV4cGxpY2l0RGV2VXJsO1xuXHRlbnY7XG5cdGNvbnN0cnVjdG9yKHsgdHlwZSwgaXNFeHBsaWNpdCwgZXhwbGljaXREZXZVcmwsIGVudiA9IGFsbFByb2Nlc3NFbnYoKSB9KSB7XG5cdFx0dGhpcy5lbnYgPSBlbnY7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmlzRXhwbGljaXQgPSBpc0V4cGxpY2l0IHx8IEJvb2xlYW4oZXhwbGljaXREZXZVcmwpO1xuXHRcdHRoaXMuZXhwbGljaXREZXZVcmwgPSBleHBsaWNpdERldlVybDtcblx0fVxuXHRnZXQgaXNEZXYoKSB7XG5cdFx0cmV0dXJuIHRoaXMudHlwZSA9PT0gXCJkZXZcIjtcblx0fVxuXHRnZXQgaXNDbG91ZCgpIHtcblx0XHRyZXR1cm4gdGhpcy50eXBlID09PSBcImNsb3VkXCI7XG5cdH1cblx0Z2V0IGlzSW5mZXJyZWQoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzRXhwbGljaXQ7XG5cdH1cblx0LyoqXG5cdCogSWYgd2UgYXJlIGV4cGxpY2l0bHkgaW4gYSBwYXJ0aWN1bGFyIG1vZGUsIHJldHJpZXZlIHRoZSBVUkwgdGhhdCB3ZSBhcmVcblx0KiBzdXJlIHdlIHNob3VsZCBiZSB1c2luZywgbm90IGNvbnNpZGVyaW5nIGFueSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb3Igb3RoZXJcblx0KiBpbmZsdWVuY2VzLlxuXHQqL1xuXHRnZXRFeHBsaWNpdFVybChkZWZhdWx0Q2xvdWRVcmwpIHtcblx0XHRpZiAoIXRoaXMuaXNFeHBsaWNpdCkgcmV0dXJuO1xuXHRcdGlmICh0aGlzLmV4cGxpY2l0RGV2VXJsKSByZXR1cm4gdGhpcy5leHBsaWNpdERldlVybC5ocmVmO1xuXHRcdGlmICh0aGlzLmlzQ2xvdWQpIHJldHVybiBkZWZhdWx0Q2xvdWRVcmw7XG5cdFx0aWYgKHRoaXMuaXNEZXYpIHJldHVybiBkZWZhdWx0RGV2U2VydmVySG9zdDtcblx0fVxufTtcbi8qKlxuKiBSZXR1cm5zIHRoZSBtb2RlIG9mIHRoZSBjdXJyZW50IGVudmlyb25tZW50LCBiYXNlZCBvZmYgb2YgZWl0aGVyIHBhc3NlZFxuKiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb3IgYHByb2Nlc3MuZW52YCwgb3IgZXhwbGljaXQgc2V0dGluZ3MuXG4qL1xuY29uc3QgZ2V0TW9kZSA9ICh7IGVudiA9IGFsbFByb2Nlc3NFbnYoKSwgY2xpZW50LCBleHBsaWNpdE1vZGUgfSA9IHt9KSA9PiB7XG5cdGlmIChleHBsaWNpdE1vZGUpIHJldHVybiBuZXcgTW9kZSh7XG5cdFx0dHlwZTogZXhwbGljaXRNb2RlLFxuXHRcdGlzRXhwbGljaXQ6IHRydWUsXG5cdFx0ZW52XG5cdH0pO1xuXHRpZiAoY2xpZW50Py5bXCJtb2RlXCJdLmlzRXhwbGljaXQpIHJldHVybiBjbGllbnRbXCJtb2RlXCJdO1xuXHRpZiAoZW52S2V5cy5Jbm5nZXN0RGV2TW9kZSBpbiBlbnYpIHtcblx0XHRpZiAodHlwZW9mIGVudltlbnZLZXlzLklubmdlc3REZXZNb2RlXSA9PT0gXCJzdHJpbmdcIikgdHJ5IHtcblx0XHRcdHJldHVybiBuZXcgTW9kZSh7XG5cdFx0XHRcdHR5cGU6IFwiZGV2XCIsXG5cdFx0XHRcdGlzRXhwbGljaXQ6IHRydWUsXG5cdFx0XHRcdGV4cGxpY2l0RGV2VXJsOiBuZXcgVVJMKGVudltlbnZLZXlzLklubmdlc3REZXZNb2RlXSksXG5cdFx0XHRcdGVudlxuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCB7fVxuXHRcdGNvbnN0IGVudklzRGV2ID0gcGFyc2VBc0Jvb2xlYW4oZW52W2VudktleXMuSW5uZ2VzdERldk1vZGVdKTtcblx0XHRpZiAodHlwZW9mIGVudklzRGV2ID09PSBcImJvb2xlYW5cIikgcmV0dXJuIG5ldyBNb2RlKHtcblx0XHRcdHR5cGU6IGVudklzRGV2ID8gXCJkZXZcIiA6IFwiY2xvdWRcIixcblx0XHRcdGlzRXhwbGljaXQ6IHRydWUsXG5cdFx0XHRlbnZcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gbmV3IE1vZGUoe1xuXHRcdHR5cGU6IHByb2RDaGVja3Muc29tZSgoW2tleSwgY2hlY2tLZXksIGV4cGVjdGVkXSkgPT4ge1xuXHRcdFx0cmV0dXJuIGNoZWNrRm5zW2NoZWNrS2V5XShzdHJpbmdpZnlVbmtub3duKGVudltrZXldKSwgZXhwZWN0ZWQpO1xuXHRcdH0pID8gXCJjbG91ZFwiIDogXCJkZXZcIixcblx0XHRpc0V4cGxpY2l0OiBmYWxzZSxcblx0XHRlbnZcblx0fSk7XG59O1xuLyoqXG4qIGdldEVudmlyb25tZW50TmFtZSByZXR1cm5zIHRoZSBzdXNwZWN0ZWQgYnJhbmNoIG5hbWUgZm9yIHRoaXMgZW52aXJvbm1lbnQgYnlcbiogc2VhcmNoaW5nIHRocm91Z2ggYSBzZXQgb2YgY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbipcbiogVGhpcyBjb3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB3ZSdyZSBvbiBhIGJyYW5jaCBkZXBsb3kgb3Igbm90LCB0aG91Z2ggaXRcbiogc2hvdWxkIGJlIG5vdGVkIHRoYXQgd2UgZG9uJ3Qga25vdyBpZiB0aGlzIGlzIHRoZSBkZWZhdWx0IGJyYW5jaCBvciBub3QuXG4qL1xuY29uc3QgZ2V0RW52aXJvbm1lbnROYW1lID0gKGVudiA9IGFsbFByb2Nlc3NFbnYoKSkgPT4ge1xuXHQvKipcblx0KiBPcmRlciBpcyBpbXBvcnRhbnQ7IG1vcmUgdGhhbiBvbmUgb2YgdGhlc2UgZW52IHZhcnMgbWF5IGJlIHNldCwgc28gZW5zdXJlXG5cdCogdGhhdCB3ZSBjaGVjayB0aGUgbW9zdCBzcGVjaWZpYywgbW9zdCByZWxpYWJsZSBlbnYgdmFycyBmaXJzdC5cblx0Ki9cblx0cmV0dXJuIGVudltlbnZLZXlzLklubmdlc3RFbnZpcm9ubWVudF0gfHwgZW52W2VudktleXMuQnJhbmNoTmFtZV0gfHwgZW52W2VudktleXMuVmVyY2VsQnJhbmNoXSB8fCBlbnZbZW52S2V5cy5OZXRsaWZ5QnJhbmNoXSB8fCBlbnZbZW52S2V5cy5DbG91ZGZsYXJlUGFnZXNCcmFuY2hdIHx8IGVudltlbnZLZXlzLlJlbmRlckJyYW5jaF0gfHwgZW52W2VudktleXMuUmFpbHdheUJyYW5jaF07XG59O1xuY29uc3QgcHJvY2Vzc0VudiA9IChrZXkpID0+IHtcblx0cmV0dXJuIGFsbFByb2Nlc3NFbnYoKVtrZXldO1xufTtcbi8qKlxuKiBhbGxQcm9jZXNzRW52IHJldHVybnMgdGhlIGN1cnJlbnQgcHJvY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIG9yIGFuIGVtcHR5XG4qIG9iamVjdCBpZiB0aGV5IGNhbm5vdCBiZSByZWFkLCBtYWtpbmcgc3VyZSB3ZSBzdXBwb3J0IGVudmlyb25tZW50cyBvdGhlciB0aGFuXG4qIE5vZGUgc3VjaCBhcyBEZW5vLCB0b28uXG4qXG4qIFVzaW5nIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBkYW5nZXJvdXNseSBhY2Nlc3MgYHByb2Nlc3MuZW52YCBpbiBlbnZpcm9ubWVudHNcbiogd2hlcmUgaXQgbWF5IG5vdCBiZSBkZWZpbmVkLCBzdWNoIGFzIERlbm8gb3IgdGhlIGJyb3dzZXIuXG4qL1xuY29uc3QgYWxsUHJvY2Vzc0VudiA9ICgpID0+IHtcblx0dHJ5IHtcblx0XHRpZiAocHJvY2Vzcy5lbnYpIHJldHVybiBwcm9jZXNzLmVudjtcblx0fSBjYXRjaCAoX2Vycikge31cblx0dHJ5IHtcblx0XHRjb25zdCBlbnYgPSBEZW5vLmVudi50b09iamVjdCgpO1xuXHRcdGlmIChlbnYpIHJldHVybiBlbnY7XG5cdH0gY2F0Y2ggKF9lcnIpIHt9XG5cdHRyeSB7XG5cdFx0Y29uc3QgZW52ID0gTmV0bGlmeS5lbnYudG9PYmplY3QoKTtcblx0XHRpZiAoZW52KSByZXR1cm4gZW52O1xuXHR9IGNhdGNoIChfZXJyKSB7fVxuXHRyZXR1cm4ge307XG59O1xuLyoqXG4qIEdlbmVyYXRlIGEgc3RhbmRhcmRpc2VkIHNldCBvZiBoZWFkZXJzIGJhc2VkIG9uIGlucHV0IGFuZCBlbnZpcm9ubWVudFxuKiB2YXJpYWJsZXMuXG4qXG4qXG4qL1xuY29uc3QgaW5uZ2VzdEhlYWRlcnMgPSAob3B0cykgPT4ge1xuXHRjb25zdCBzZGtWZXJzaW9uID0gYGlubmdlc3QtanM6diR7dmVyc2lvbn1gO1xuXHRjb25zdCBoZWFkZXJzID0ge1xuXHRcdFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuXHRcdFwiVXNlci1BZ2VudFwiOiBzZGtWZXJzaW9uLFxuXHRcdFtoZWFkZXJLZXlzLlNka1ZlcnNpb25dOiBzZGtWZXJzaW9uXG5cdH07XG5cdGlmIChvcHRzPy5mcmFtZXdvcmspIGhlYWRlcnNbaGVhZGVyS2V5cy5GcmFtZXdvcmtdID0gb3B0cy5mcmFtZXdvcms7XG5cdGlmIChvcHRzPy5leHBlY3RlZFNlcnZlcktpbmQpIGhlYWRlcnNbaGVhZGVyS2V5cy5Jbm5nZXN0RXhwZWN0ZWRTZXJ2ZXJLaW5kXSA9IG9wdHMuZXhwZWN0ZWRTZXJ2ZXJLaW5kO1xuXHRjb25zdCBlbnYgPSB7XG5cdFx0Li4uYWxsUHJvY2Vzc0VudigpLFxuXHRcdC4uLm9wdHM/LmVudlxuXHR9O1xuXHRjb25zdCBpbm5nZXN0RW52ID0gb3B0cz8uaW5uZ2VzdEVudiB8fCBnZXRFbnZpcm9ubWVudE5hbWUoZW52KTtcblx0aWYgKGlubmdlc3RFbnYpIGhlYWRlcnNbaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0gPSBpbm5nZXN0RW52O1xuXHRjb25zdCBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtTmFtZShlbnYpO1xuXHRpZiAocGxhdGZvcm0pIGhlYWRlcnNbaGVhZGVyS2V5cy5QbGF0Zm9ybV0gPSBwbGF0Zm9ybTtcblx0cmV0dXJuIHtcblx0XHQuLi5oZWFkZXJzLFxuXHRcdC4uLm9wdHM/LmNsaWVudD8uW1wiaGVhZGVyc1wiXSxcblx0XHQuLi5vcHRzPy5leHRyYXNcblx0fTtcbn07XG4vKipcbiogQSBzZXQgb2YgY2hlY2tzIHRoYXQsIGdpdmVuIGFuIGVudmlyb25tZW50LCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnRcbiogZW52aXJvbm1lbnQgaXMgcnVubmluZyBvbiB0aGUgcGxhdGZvcm0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiovXG5jb25zdCBwbGF0Zm9ybUNoZWNrcyA9IHtcblx0dmVyY2VsOiAoZW52KSA9PiBlbnZbZW52S2V5cy5Jc1ZlcmNlbF0gPT09IFwiMVwiIHx8IHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIixcblx0bmV0bGlmeTogKGVudikgPT4gZW52W2VudktleXMuSXNOZXRsaWZ5XSA9PT0gXCJ0cnVlXCIsXG5cdFwiY2xvdWRmbGFyZS1wYWdlc1wiOiAoZW52KSA9PiBlbnZbZW52S2V5cy5Jc0Nsb3VkZmxhcmVQYWdlc10gPT09IFwiMVwiLFxuXHRyZW5kZXI6IChlbnYpID0+IGVudltlbnZLZXlzLklzUmVuZGVyXSA9PT0gXCJ0cnVlXCIsXG5cdHJhaWx3YXk6IChlbnYpID0+IEJvb2xlYW4oZW52W2VudktleXMuUmFpbHdheUVudmlyb25tZW50XSlcbn07XG4vKipcbiogQSBzZXQgb2YgY2hlY2tzIHRoYXQsIGdpdmVuIGFuIGVudmlyb25tZW50LCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnRcbiogZW52aXJvbm1lbnQgYW5kIHBsYXRmb3JtIHN1cHBvcnRzIHN0cmVhbWluZyByZXNwb25zZXMgYmFjayB0byBJbm5nZXN0LlxuKlxuKiBTdHJlYW1pbmcgY2FwYWJpbGl0eSBpcyBib3RoIGZyYW1ld29yayBhbmQgcGxhdGZvcm0tYmFzZWQuIEZyYW1ld29ya3MgYXJlXG4qIHN1cHBvcnRlZCBpbiBzZXJ2ZSBoYW5kbGVycywgYW5kIHBsYXRmb3JtcyBhcmUgY2hlY2tlZCBoZXJlLlxuKlxuKiBBcyBzdWNoLCB0aGlzIHJlY29yZCBkZWNsYXJlcyB3aGljaCBwbGF0Zm9ybXMgd2UgZXhwbGljaXRseSBzdXBwb3J0IGZvclxuKiBzdHJlYW1pbmcgYW5kIGlzIHVzZWQgYnkge0BsaW5rIHBsYXRmb3JtU3VwcG9ydHNTdHJlYW1pbmd9LlxuKi9cbmNvbnN0IHN0cmVhbWluZ0NoZWNrcyA9IHtcblx0dmVyY2VsOiAoX2ZyYW1ld29yaywgX2VudikgPT4gdHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiLFxuXHRcImNsb3VkZmxhcmUtcGFnZXNcIjogKCkgPT4gdHJ1ZVxufTtcbmNvbnN0IGdldFBsYXRmb3JtTmFtZSA9IChlbnYpID0+IHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHBsYXRmb3JtQ2hlY2tzKS5maW5kKChrZXkpID0+IHtcblx0XHRyZXR1cm4gcGxhdGZvcm1DaGVja3Nba2V5XShlbnYpO1xuXHR9KTtcbn07XG4vKipcbiogUmV0dXJucyBgdHJ1ZWAgaWYgd2UgYmVsaWV2ZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBzdXBwb3J0cyBzdHJlYW1pbmdcbiogcmVzcG9uc2VzIGJhY2sgdG8gSW5uZ2VzdC5cbipcbiogV2UgcnVuIGEgY2hlY2sgZGlyZWN0bHkgcmVsYXRlZCB0byB0aGUgcGxhdGZvcm0gd2UgYmVsaWV2ZSB3ZSdyZSBydW5uaW5nIG9uLFxuKiB1c3VhbGx5IGJhc2VkIG9uIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiovXG5jb25zdCBwbGF0Zm9ybVN1cHBvcnRzU3RyZWFtaW5nID0gKGZyYW1ld29yaywgZW52ID0gYWxsUHJvY2Vzc0VudigpKSA9PiB7XG5cdHJldHVybiBzdHJlYW1pbmdDaGVja3NbZ2V0UGxhdGZvcm1OYW1lKGVudildPy4oZnJhbWV3b3JrLCBlbnYpID8/IGZhbHNlO1xufTtcbi8qKlxuKiBBIHVuaXF1ZSBzeW1ib2wgdXNlZCB0byBtYXJrIGEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uLiBXZSB3cmFwIHRoZVxuKiBpbXBsZW1lbnRhdGlvbnMgdG8gcHJvdmlkZSBzb21lIGV4dHJhIGNvbnRyb2wgd2hlbiBoYW5kbGluZyBlcnJvcnMuXG4qL1xuY29uc3QgQ1VTVE9NX0ZFVENIX01BUktFUiA9IFN5bWJvbChcIkN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuKiBHaXZlbiBhIHBvdGVudGlhbCBmZXRjaCBmdW5jdGlvbiwgcmV0dXJuIHRoZSBmZXRjaCBmdW5jdGlvbiB0byB1c2UgYmFzZWQgb25cbiogdGhpcyBhbmQgdGhlIGVudmlyb25tZW50LlxuKi9cbmNvbnN0IGdldEZldGNoID0gKGdpdmVuRmV0Y2gpID0+IHtcblx0LyoqXG5cdCogSWYgd2UndmUgZXhwbGljaXRseSBiZWVuIGdpdmVuIGEgZmV0Y2ggZnVuY3Rpb24sIHVzZSB0aGF0LlxuXHQqL1xuXHRpZiAoZ2l2ZW5GZXRjaCkge1xuXHRcdGlmIChDVVNUT01fRkVUQ0hfTUFSS0VSIGluIGdpdmVuRmV0Y2gpIHJldHVybiBnaXZlbkZldGNoO1xuXHRcdC8qKlxuXHRcdCogV2Ugd3JhcCB0aGUgZ2l2ZW4gZmV0Y2ggZnVuY3Rpb24gdG8gcHJvdmlkZSBzb21lIGV4dHJhIGNvbnRyb2wgd2hlblxuXHRcdCogaGFuZGxpbmcgZXJyb3JzLlxuXHRcdCovXG5cdFx0Y29uc3QgY3VzdG9tRmV0Y2ggPSBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIGF3YWl0IGdpdmVuRmV0Y2goLi4uYXJncyk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0LyoqXG5cdFx0XHRcdCogQ2FwdHVyZSB3YXJuaW5ncyB0aGF0IGFyZSBub3Qgc2ltcGxlIGZldGNoIGZhaWx1cmVzIGFuZCBoaWdobGlnaHRcblx0XHRcdFx0KiB0aGVtIGZvciB0aGUgdXNlci5cblx0XHRcdFx0KlxuXHRcdFx0XHQqIFdlIGFsc28gdXNlIHRoaXMgb3Bwb3J0dW5pdHkgdG8gbG9nIHRoZSBjYXVzaW5nIGVycm9yLCBhcyBjb2RlIGhpZ2hlclxuXHRcdFx0XHQqIHVwIHRoZSBzdGFjayB3aWxsIGxpa2VseSBhYnN0cmFjdCB0aGlzLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikgfHwgIWVyci5tZXNzYWdlPy5zdGFydHNXaXRoKFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKFwiQSByZXF1ZXN0IGZhaWxlZCB3aGVuIHVzaW5nIGEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uOyB0aGlzIG1heSBiZSBhIG1pc2NvbmZpZ3VyYXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgZmV0Y2ggY2xpZW50IGlzIGNvcnJlY3RseSBib3VuZCB0byB0aGUgZ2xvYmFsIHNjb3BlLlwiKTtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0LyoqXG5cdFx0KiBNYXJrIHRoZSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24gc28gdGhhdCB3ZSBjYW4gaWRlbnRpZnkgaXQgbGF0ZXIsIGluXG5cdFx0KiBhZGRpdGlvbiB0byBhZGRpbmcgc29tZSBydW50aW1lIHByb3BlcnRpZXMgdG8gaXQgdG8gbWFrZSBpdCBzZWVtIGFzIG11Y2hcblx0XHQqIGxpa2UgdGhlIG9yaWdpbmFsIGZldGNoIGFzIHBvc3NpYmxlLlxuXHRcdCovXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3VzdG9tRmV0Y2gsIHtcblx0XHRcdFtDVVNUT01fRkVUQ0hfTUFSS0VSXToge30sXG5cdFx0XHRuYW1lOiB7IHZhbHVlOiBnaXZlbkZldGNoLm5hbWUgfSxcblx0XHRcdGxlbmd0aDogeyB2YWx1ZTogZ2l2ZW5GZXRjaC5sZW5ndGggfVxuXHRcdH0pO1xuXHRcdHJldHVybiBjdXN0b21GZXRjaDtcblx0fVxuXHQvKipcblx0KiBCcm93c2VyIG9yIE5vZGUgMTgrXG5cdCovXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiZmV0Y2hcIiBpbiBnbG9iYWxUaGlzKSByZXR1cm4gZmV0Y2guYmluZChnbG9iYWxUaGlzKTtcblx0fSBjYXRjaCAoX2Vycikge31cblx0LyoqXG5cdCogRXhpc3RpbmcgcG9seWZpbGxlZCBmZXRjaFxuXHQqL1xuXHRpZiAodHlwZW9mIGZldGNoICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmV0Y2g7XG5cdC8qKlxuXHQqIEVudmlyb25tZW50cyB3aGVyZSBmZXRjaCBjYW5ub3QgYmUgZm91bmQgYW5kIG11c3QgYmUgcG9seWZpbGxlZFxuXHQqL1xuXHRyZXR1cm4gX19yZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIik7XG59O1xuLyoqXG4qIElmIGBSZXNwb25zZWAgaXNuJ3QgaW5jbHVkZWQgaW4gdGhpcyBlbnZpcm9ubWVudCwgaXQncyBwcm9iYWJseSBhbiBlYXJsaWVyXG4qIE5vZGUgZW52IHRoYXQgaXNuJ3QgYWxyZWFkeSBwb2x5ZmlsbGluZy4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGVpdGhlciB0aGVcbiogbmF0aXZlIGBSZXNwb25zZWAgb3IgYSBwb2x5ZmlsbGVkIG9uZS5cbiovXG5jb25zdCBnZXRSZXNwb25zZSA9ICgpID0+IHtcblx0aWYgKHR5cGVvZiBSZXNwb25zZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFJlc3BvbnNlO1xuXHRyZXR1cm4gX19yZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIikuUmVzcG9uc2U7XG59O1xuLyoqXG4qIEdpdmVuIGFuIHVua25vd24gdmFsdWUsIHRyeSB0byBwYXJzZSBpdCBhcyBhIGBib29sZWFuYC4gVXNlZnVsIGZvciBwYXJzaW5nXG4qIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IGNvdWxkIGJlIGEgc2VsZWN0aW9uIG9mIGRpZmZlcmVudCB2YWx1ZXMgc3VjaCBhc1xuKiBgXCJ0cnVlXCJgLCBgXCIxXCJgLlxuKlxuKiBJZiB0aGUgdmFsdWUgY291bGQgbm90IGJlIGNvbmZpZGVudGx5IHBhcnNlZCBhcyBhIGBib29sZWFuYCBvciB3YXMgc2VlbiB0byBiZVxuKiBgdW5kZWZpbmVkYCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLlxuKi9cbmNvbnN0IHBhcnNlQXNCb29sZWFuID0gKHZhbHVlKSA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gdmFsdWU7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHJldHVybiBCb29sZWFuKHZhbHVlKTtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodHJpbW1lZCA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuXHRcdGlmIChbXCJ0cnVlXCIsIFwiMVwiXS5pbmNsdWRlcyh0cmltbWVkKSkgcmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IE1vZGUsIGFsbFByb2Nlc3NFbnYsIGRldlNlcnZlckhvc3QsIGdldEVudmlyb25tZW50TmFtZSwgZ2V0RmV0Y2gsIGdldE1vZGUsIGdldFBsYXRmb3JtTmFtZSwgZ2V0UmVzcG9uc2UsIGlubmdlc3RIZWFkZXJzLCBwYXJzZUFzQm9vbGVhbiwgcGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZywgcHJvY2Vzc0VudiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCJdLCJuYW1lcyI6WyJfX3JlcXVpcmUiLCJ2ZXJzaW9uIiwiZGVmYXVsdERldlNlcnZlckhvc3QiLCJlbnZLZXlzIiwiaGVhZGVyS2V5cyIsInN0cmluZ2lmeVVua25vd24iLCJkZXZTZXJ2ZXJIb3N0IiwiZW52IiwiYWxsUHJvY2Vzc0VudiIsInByZWZpeGVzIiwiSW5uZ2VzdEJhc2VVcmwiLCJJbm5nZXN0RGV2TW9kZSIsImZsYXRNYXAiLCJrZXkiLCJtYXAiLCJwcmVmaXgiLCJmaW5kIiwidiIsIkJvb2xlYW4iLCJVUkwiLCJjaGVja0ZucyIsImNoZWNrcyIsImVxdWFscyIsImFjdHVhbCIsImV4cGVjdGVkIiwic3RhcnRzV2l0aCIsInByb2RDaGVja3MiLCJWZXJjZWxFbnZLZXkiLCJJc05ldGxpZnkiLCJJc1JlbmRlciIsIlJhaWx3YXlCcmFuY2giLCJJc0Nsb3VkZmxhcmVQYWdlcyIsIk1vZGUiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJpc0V4cGxpY2l0IiwiZXhwbGljaXREZXZVcmwiLCJpc0RldiIsImlzQ2xvdWQiLCJpc0luZmVycmVkIiwiZ2V0RXhwbGljaXRVcmwiLCJkZWZhdWx0Q2xvdWRVcmwiLCJocmVmIiwiZ2V0TW9kZSIsImNsaWVudCIsImV4cGxpY2l0TW9kZSIsImVudklzRGV2IiwicGFyc2VBc0Jvb2xlYW4iLCJzb21lIiwiY2hlY2tLZXkiLCJnZXRFbnZpcm9ubWVudE5hbWUiLCJJbm5nZXN0RW52aXJvbm1lbnQiLCJCcmFuY2hOYW1lIiwiVmVyY2VsQnJhbmNoIiwiTmV0bGlmeUJyYW5jaCIsIkNsb3VkZmxhcmVQYWdlc0JyYW5jaCIsIlJlbmRlckJyYW5jaCIsInByb2Nlc3NFbnYiLCJwcm9jZXNzIiwiX2VyciIsIkRlbm8iLCJ0b09iamVjdCIsIk5ldGxpZnkiLCJpbm5nZXN0SGVhZGVycyIsIm9wdHMiLCJzZGtWZXJzaW9uIiwiaGVhZGVycyIsIlNka1ZlcnNpb24iLCJmcmFtZXdvcmsiLCJGcmFtZXdvcmsiLCJleHBlY3RlZFNlcnZlcktpbmQiLCJJbm5nZXN0RXhwZWN0ZWRTZXJ2ZXJLaW5kIiwiaW5uZ2VzdEVudiIsIkVudmlyb25tZW50IiwicGxhdGZvcm0iLCJnZXRQbGF0Zm9ybU5hbWUiLCJQbGF0Zm9ybSIsImV4dHJhcyIsInBsYXRmb3JtQ2hlY2tzIiwidmVyY2VsIiwiSXNWZXJjZWwiLCJFZGdlUnVudGltZSIsIm5ldGxpZnkiLCJyZW5kZXIiLCJyYWlsd2F5IiwiUmFpbHdheUVudmlyb25tZW50Iiwic3RyZWFtaW5nQ2hlY2tzIiwiX2ZyYW1ld29yayIsIl9lbnYiLCJPYmplY3QiLCJrZXlzIiwicGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyIsIkNVU1RPTV9GRVRDSF9NQVJLRVIiLCJTeW1ib2wiLCJnZXRGZXRjaCIsImdpdmVuRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJlcnIiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwiZGVmaW5lUHJvcGVydGllcyIsIm5hbWUiLCJ2YWx1ZSIsImxlbmd0aCIsImdsb2JhbFRoaXMiLCJmZXRjaCIsImJpbmQiLCJnZXRSZXNwb25zZSIsIlJlc3BvbnNlIiwidHJpbW1lZCIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/errors.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/errors.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrCode: () => (/* binding */ ErrCode),\n/* harmony export */   deserializeError: () => (/* binding */ deserializeError$1),\n/* harmony export */   errors_exports: () => (/* binding */ errors_exports),\n/* harmony export */   fixEventKeyMissingSteps: () => (/* binding */ fixEventKeyMissingSteps),\n/* harmony export */   functionStoppedRunningErr: () => (/* binding */ functionStoppedRunningErr),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   minifyPrettyError: () => (/* binding */ minifyPrettyError),\n/* harmony export */   prettyError: () => (/* binding */ prettyError),\n/* harmony export */   rethrowError: () => (/* binding */ rethrowError),\n/* harmony export */   serializeError: () => (/* binding */ serializeError$1)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var _components_NonRetriableError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var chalk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\");\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\");\n/* harmony import */ var serialize_error_cjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! serialize-error-cjs */ \"(rsc)/./node_modules/serialize-error-cjs/dist/index.js\");\n/* harmony import */ var strip_ansi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! strip-ansi */ \"(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js\");\n\n\n\n\n\n\n\n//#region src/helpers/errors.ts\nvar errors_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_4__.__export)({\n    ErrCode: ()=>ErrCode,\n    OutgoingResultError: ()=>OutgoingResultError,\n    deserializeError: ()=>deserializeError$1,\n    fixEventKeyMissingSteps: ()=>fixEventKeyMissingSteps,\n    functionStoppedRunningErr: ()=>functionStoppedRunningErr,\n    getErrorMessage: ()=>getErrorMessage,\n    isSerializedError: ()=>isSerializedError,\n    minifyPrettyError: ()=>minifyPrettyError,\n    prettyError: ()=>prettyError,\n    prettyErrorSplitter: ()=>prettyErrorSplitter,\n    rethrowError: ()=>rethrowError,\n    serializeError: ()=>serializeError$1\n});\nconst SERIALIZED_KEY = \"__serialized\";\nconst SERIALIZED_VALUE = true;\n/**\n* Add first-class support for certain errors that we control, in addition to\n* built-in errors such as `TypeError`.\n*\n* Adding these allows these non-standard errors to be correctly serialized,\n* sent to Inngest, then deserialized back into the correct error type for users\n* to react to correctly.\n*\n* Note that these errors only support `message?: string | undefined` as the\n* input; more custom errors are not supported with this current strategy.\n*/ serialize_error_cjs__WEBPACK_IMPORTED_MODULE_2__.errorConstructors.set(\"NonRetriableError\", _components_NonRetriableError_js__WEBPACK_IMPORTED_MODULE_5__.NonRetriableError);\n/**\n* Serialise an error to a serialized JSON string.\n*\n* Errors do not serialise nicely to JSON, so we use this function to convert\n* them to a serialized JSON string. Doing this is also non-trivial for some\n* errors, so we use the `serialize-error` package to do it for us.\n*\n* See {@link https://www.npmjs.com/package/serialize-error}\n*\n* This function is a small wrapper around that package to also add a `type`\n* property to the serialised error, so that we can distinguish between\n* serialised errors and other objects.\n*\n* Will not reserialise existing serialised errors.\n*/ const serializeError$1 = (subject, allowUnknown = false)=>{\n    try {\n        const existingSerializedError = isSerializedError(subject);\n        if (existingSerializedError) return existingSerializedError;\n        if (typeof subject === \"object\" && subject !== null) {\n            const serializedErr = (0,serialize_error_cjs__WEBPACK_IMPORTED_MODULE_2__.serializeError)(subject);\n            if (!serializedErr.name && allowUnknown) return subject;\n            const ret = {\n                ...serializedErr,\n                name: serializedErr.name || \"Error\",\n                message: serializedErr.message || json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__(subject) || \"Unknown error; error serialization could not find a message.\",\n                stack: serializedErr.stack || \"\",\n                [SERIALIZED_KEY]: SERIALIZED_VALUE\n            };\n            let target = ret;\n            const maxDepth = 5;\n            for(let i = 0; i < maxDepth; i++){\n                if (typeof target === \"object\" && target !== null && \"cause\" in target && target.cause) {\n                    target = target.cause = serializeError$1(target.cause, true);\n                    continue;\n                }\n                break;\n            }\n            return ret;\n        }\n        throw new Error(\"Error is not an object; strange throw value.\");\n    } catch  {\n        if (allowUnknown) return subject;\n        try {\n            return {\n                ...serializeError$1(new Error(typeof subject === \"string\" ? subject : json_stringify_safe__WEBPACK_IMPORTED_MODULE_1__(subject)), false),\n                stack: \"\",\n                [SERIALIZED_KEY]: SERIALIZED_VALUE\n            };\n        } catch  {\n            return {\n                name: \"Could not serialize source error\",\n                message: \"Serializing the source error failed.\",\n                stack: \"\",\n                [SERIALIZED_KEY]: SERIALIZED_VALUE\n            };\n        }\n    }\n};\n/**\n* Check if an object or a string is a serialised error created by\n* {@link serializeError}.\n*/ const isSerializedError = (value)=>{\n    try {\n        if (typeof value === \"string\") {\n            const parsed = zod_v3__WEBPACK_IMPORTED_MODULE_6__.object({\n                [SERIALIZED_KEY]: zod_v3__WEBPACK_IMPORTED_MODULE_6__.literal(SERIALIZED_VALUE),\n                name: zod_v3__WEBPACK_IMPORTED_MODULE_6__[\"enum\"]([\n                    ...Array.from(serialize_error_cjs__WEBPACK_IMPORTED_MODULE_2__.errorConstructors.keys())\n                ]),\n                message: zod_v3__WEBPACK_IMPORTED_MODULE_6__.string(),\n                stack: zod_v3__WEBPACK_IMPORTED_MODULE_6__.string()\n            }).passthrough().safeParse(JSON.parse(value));\n            if (parsed.success) return parsed.data;\n        }\n        if (typeof value === \"object\" && value !== null) {\n            if (Object.hasOwn(value, SERIALIZED_KEY) && value[SERIALIZED_KEY] === SERIALIZED_VALUE) return value;\n        }\n    } catch  {}\n};\n/**\n* Deserialise an error created by {@link serializeError}.\n*\n* Ensures we only deserialise errors that meet a minimum level of\n* applicability, inclusive of error handling to ensure that badly serialized\n* errors are still handled.\n*/ const deserializeError$1 = (subject, allowUnknown = false)=>{\n    const requiredFields = [\n        \"name\",\n        \"message\"\n    ];\n    try {\n        if (!requiredFields.every((field)=>{\n            return Object.hasOwn(subject, field);\n        })) throw new Error();\n        const deserializedErr = (0,serialize_error_cjs__WEBPACK_IMPORTED_MODULE_2__.deserializeError)(subject);\n        if (\"cause\" in deserializedErr) deserializedErr.cause = deserializeError$1(deserializedErr.cause, true);\n        return deserializedErr;\n    } catch  {\n        if (allowUnknown) return subject;\n        const err = /* @__PURE__ */ new Error(\"Unknown error; could not reserialize\");\n        /**\n\t\t* Remove the stack so that it's not misleadingly shown as the Inngest\n\t\t* internals.\n\t\t*/ err.stack = void 0;\n        return err;\n    }\n};\nlet ErrCode = /* @__PURE__ */ function(ErrCode$1) {\n    ErrCode$1[\"NESTING_STEPS\"] = \"NESTING_STEPS\";\n    /**\n\t* Legacy v0 execution error code for when a function has changed and no\n\t* longer matches its in-progress state.\n\t*\n\t* @deprecated Not for use in latest execution method.\n\t*/ ErrCode$1[\"NON_DETERMINISTIC_FUNCTION\"] = \"NON_DETERMINISTIC_FUNCTION\";\n    /**\n\t* Legacy v0 execution error code for when a function is found to be using\n\t* async actions after memoziation has occurred, which v0 doesn't support.\n\t*\n\t* @deprecated Not for use in latest execution method.\n\t*/ ErrCode$1[\"ASYNC_DETECTED_AFTER_MEMOIZATION\"] = \"ASYNC_DETECTED_AFTER_MEMOIZATION\";\n    /**\n\t* Legacy v0 execution error code for when a function is found to be using\n\t* steps after a non-step async action has occurred.\n\t*\n\t* @deprecated Not for use in latest execution method.\n\t*/ ErrCode$1[\"STEP_USED_AFTER_ASYNC\"] = \"STEP_USED_AFTER_ASYNC\";\n    ErrCode$1[\"AUTOMATIC_PARALLEL_INDEXING\"] = \"AUTOMATIC_PARALLEL_INDEXING\";\n    return ErrCode$1;\n}({});\nconst prettyErrorSplitter = \"=================================================\";\n/**\n* Given an unknown `err`, mutate it to minify any pretty errors that it\n* contains.\n*/ const minifyPrettyError = (err)=>{\n    try {\n        if (!isError(err)) return err;\n        if (!err.message.includes(prettyErrorSplitter)) return err;\n        const sanitizedMessage = strip_ansi__WEBPACK_IMPORTED_MODULE_3__(err.message);\n        const message = sanitizedMessage.split(\"  \")[1]?.split(\"\\n\")[0]?.trim() || err.message;\n        err.message = [\n            sanitizedMessage.split(\"\\n\\nCode: \")[1]?.split(\"\\n\\n\")[0]?.trim() || void 0,\n            message\n        ].filter(Boolean).join(\" - \");\n        if (err.stack) {\n            const stackRest = strip_ansi__WEBPACK_IMPORTED_MODULE_3__(err.stack).split(`${prettyErrorSplitter}\\n`).slice(2).join(\"\\n\");\n            err.stack = `${err.name}: ${err.message}\\n${stackRest}`;\n        }\n        return err;\n    } catch (_noopErr) {\n        return err;\n    }\n};\n/**\n* Given an `err`, return a boolean representing whether it is in the shape of\n* an `Error` or not.\n*/ const isError = (err)=>{\n    try {\n        if (err instanceof Error) return true;\n        if (typeof err !== \"object\" || err === null) return false;\n        return Object.hasOwn(err, \"name\") && Object.hasOwn(err, \"message\");\n    } catch (_noopErr) {\n        return false;\n    }\n};\n/**\n* Given an `unknown` object, retrieve the `message` property from it, or fall\n* back to the `fallback` string if it doesn't exist or is empty.\n*/ const getErrorMessage = (err, fallback)=>{\n    const { message } = zod_v3__WEBPACK_IMPORTED_MODULE_6__.object({\n        message: zod_v3__WEBPACK_IMPORTED_MODULE_6__.string().min(1)\n    }).catch({\n        message: fallback\n    }).parse(err);\n    return message;\n};\n/**\n* Given a {@link PrettyError}, return a nicely-formatted string ready to log\n* or throw.\n*\n* Useful for ensuring that errors are logged in a consistent, helpful format\n* across the SDK by prompting for key pieces of information.\n*/ const prettyError = ({ type = \"error\", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code })=>{\n    const { icon, colorFn } = {\n        error: {\n            icon: \"\",\n            colorFn: chalk__WEBPACK_IMPORTED_MODULE_0__.red\n        },\n        warn: {\n            icon: \"\",\n            colorFn: chalk__WEBPACK_IMPORTED_MODULE_0__.yellow\n        }\n    }[type];\n    let header = `${icon}  ${chalk__WEBPACK_IMPORTED_MODULE_0__.bold.underline(whatHappened.trim())}`;\n    if (stack) header += \"\\n\" + [\n        .../* @__PURE__ */ new Error().stack?.split(\"\\n\").slice(1).filter(Boolean) || []\n    ].join(\"\\n\");\n    let toFixNowStr = (Array.isArray(toFixNow) ? toFixNow.map((s)=>s.trim()).filter(Boolean).map((s, i)=>`\\t${i + 1}. ${s}`).join(\"\\n\") : toFixNow?.trim()) ?? \"\";\n    if (Array.isArray(toFixNow) && toFixNowStr) toFixNowStr = `To fix this, you can take one of the following courses of action:\\n\\n${toFixNowStr}`;\n    let body = [\n        reassurance?.trim(),\n        why?.trim(),\n        consequences?.trim()\n    ].filter(Boolean).join(\" \");\n    body += body ? `\\n\\n${toFixNowStr}` : toFixNowStr;\n    const trailer = [\n        otherwise?.trim()\n    ].filter(Boolean).join(\" \");\n    return colorFn([\n        prettyErrorSplitter,\n        header,\n        body,\n        trailer,\n        code ? `Code: ${code}` : \"\",\n        prettyErrorSplitter\n    ].filter(Boolean).join(\"\\n\\n\"));\n};\nconst fixEventKeyMissingSteps = [\n    \"Set the `INNGEST_EVENT_KEY` environment variable\",\n    `Pass a key to the \\`new Inngest()\\` constructor using the \\`eventKey\\` option`,\n    `Use \\`inngest.setEventKey()\\` at runtime`\n];\n/**\n* An error that, when thrown, indicates internally that an outgoing operation\n* contains an error.\n*\n* We use this because serialized `data` sent back to Inngest may differ from\n* the error instance itself due to middleware.\n*\n* @internal\n*/ var OutgoingResultError = class extends Error {\n    constructor(result){\n        super(\"OutgoingOpError\");\n        this.result = result;\n    }\n};\n/**\n* Create a function that will rethrow an error with a prefix added to the\n* message.\n*\n* Useful for adding context to errors that are rethrown.\n*\n* @example\n* ```ts\n* await doSomeAction().catch(rethrowError(\"Failed to do some action\"));\n* ```\n*/ const rethrowError = (prefix)=>{\n    return (err)=>{\n        try {\n            err.message &&= `${prefix}; ${err.message}`;\n        } catch (_noopErr) {} finally{\n            throw err;\n        }\n    };\n};\n/**\n* Legacy v0 execution error for functions that don't support mixing steps and\n* regular async actions.\n*/ const functionStoppedRunningErr = (code)=>{\n    return prettyError({\n        whatHappened: \"Your function was stopped from running\",\n        why: \"We detected a mix of asynchronous logic, some using step tooling and some not.\",\n        consequences: \"This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!\",\n        stack: true,\n        toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n        otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n        code\n    });\n};\n//#endregion\n //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyRDtBQUNZO0FBQzVDO0FBQ0Q7QUFDa0I7QUFDOEM7QUFDdkQ7QUFFbkMsK0JBQStCO0FBQy9CLElBQUlTLGlCQUFpQixhQUFhLEdBQUdULHNFQUFRQSxDQUFDO0lBQzdDVSxTQUFTLElBQU1BO0lBQ2ZDLHFCQUFxQixJQUFNQTtJQUMzQk4sa0JBQWtCLElBQU1PO0lBQ3hCQyx5QkFBeUIsSUFBTUE7SUFDL0JDLDJCQUEyQixJQUFNQTtJQUNqQ0MsaUJBQWlCLElBQU1BO0lBQ3ZCQyxtQkFBbUIsSUFBTUE7SUFDekJDLG1CQUFtQixJQUFNQTtJQUN6QkMsYUFBYSxJQUFNQTtJQUNuQkMscUJBQXFCLElBQU1BO0lBQzNCQyxjQUFjLElBQU1BO0lBQ3BCYixnQkFBZ0IsSUFBTWM7QUFDdkI7QUFDQSxNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsbUJBQW1CO0FBQ3pCOzs7Ozs7Ozs7O0FBVUEsR0FDQWpCLGtFQUFpQkEsQ0FBQ2tCLEdBQUcsQ0FBQyxxQkFBcUJ2QiwrRUFBaUJBO0FBQzVEOzs7Ozs7Ozs7Ozs7OztBQWNBLEdBQ0EsTUFBTW9CLG1CQUFtQixDQUFDSSxTQUFTQyxlQUFlLEtBQUs7SUFDdEQsSUFBSTtRQUNILE1BQU1DLDBCQUEwQlgsa0JBQWtCUztRQUNsRCxJQUFJRSx5QkFBeUIsT0FBT0E7UUFDcEMsSUFBSSxPQUFPRixZQUFZLFlBQVlBLFlBQVksTUFBTTtZQUNwRCxNQUFNRyxnQkFBZ0JyQixtRUFBY0EsQ0FBQ2tCO1lBQ3JDLElBQUksQ0FBQ0csY0FBY0MsSUFBSSxJQUFJSCxjQUFjLE9BQU9EO1lBQ2hELE1BQU1LLE1BQU07Z0JBQ1gsR0FBR0YsYUFBYTtnQkFDaEJDLE1BQU1ELGNBQWNDLElBQUksSUFBSTtnQkFDNUJFLFNBQVNILGNBQWNHLE9BQU8sSUFBSTNCLGdEQUFTQSxDQUFDcUIsWUFB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O1lBQ0hBLElBQUk1QixPQUFPLEtBQUssQ0FBQyxFQUFFcUUsT0FBTyxFQUFFLEVBQUV6QyxJQUFJNUIsT0FBTyxDQUFDLENBQUM7UUFDNUMsRUFBRSxPQUFPd0MsVUFBVSxDQUFDLFNBQVU7WUFDN0IsTUFBTVo7UUFDUDtJQUNEO0FBQ0Q7QUFDQTs7O0FBR0EsR0FDQSxNQUFNN0MsNEJBQTRCLENBQUNvRTtJQUNsQyxPQUFPaEUsWUFBWTtRQUNsQjBELGNBQWM7UUFDZEksS0FBSztRQUNMQyxjQUFjO1FBQ2RqRCxPQUFPO1FBQ1ArQyxVQUFVO1FBQ1ZGLFdBQVc7UUFDWEs7SUFDRDtBQUNEO0FBRUEsWUFBWTtBQUNzTixDQUNsTyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9lcnJvcnMuanM/YmEzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2V4cG9ydCB9IGZyb20gXCIuLi9fdmlydHVhbC9yb2xsZG93bl9ydW50aW1lLmpzXCI7XG5pbXBvcnQgeyBOb25SZXRyaWFibGVFcnJvciB9IGZyb20gXCIuLi9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZC92M1wiO1xuaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tIFwianNvbi1zdHJpbmdpZnktc2FmZVwiO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVFcnJvciwgZXJyb3JDb25zdHJ1Y3RvcnMsIHNlcmlhbGl6ZUVycm9yIH0gZnJvbSBcInNlcmlhbGl6ZS1lcnJvci1janNcIjtcbmltcG9ydCBzdHJpcEFuc2kgZnJvbSBcInN0cmlwLWFuc2lcIjtcblxuLy8jcmVnaW9uIHNyYy9oZWxwZXJzL2Vycm9ycy50c1xudmFyIGVycm9yc19leHBvcnRzID0gLyogQF9fUFVSRV9fICovIF9fZXhwb3J0KHtcblx0RXJyQ29kZTogKCkgPT4gRXJyQ29kZSxcblx0T3V0Z29pbmdSZXN1bHRFcnJvcjogKCkgPT4gT3V0Z29pbmdSZXN1bHRFcnJvcixcblx0ZGVzZXJpYWxpemVFcnJvcjogKCkgPT4gZGVzZXJpYWxpemVFcnJvciQxLFxuXHRmaXhFdmVudEtleU1pc3NpbmdTdGVwczogKCkgPT4gZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMsXG5cdGZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnI6ICgpID0+IGZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIsXG5cdGdldEVycm9yTWVzc2FnZTogKCkgPT4gZ2V0RXJyb3JNZXNzYWdlLFxuXHRpc1NlcmlhbGl6ZWRFcnJvcjogKCkgPT4gaXNTZXJpYWxpemVkRXJyb3IsXG5cdG1pbmlmeVByZXR0eUVycm9yOiAoKSA9PiBtaW5pZnlQcmV0dHlFcnJvcixcblx0cHJldHR5RXJyb3I6ICgpID0+IHByZXR0eUVycm9yLFxuXHRwcmV0dHlFcnJvclNwbGl0dGVyOiAoKSA9PiBwcmV0dHlFcnJvclNwbGl0dGVyLFxuXHRyZXRocm93RXJyb3I6ICgpID0+IHJldGhyb3dFcnJvcixcblx0c2VyaWFsaXplRXJyb3I6ICgpID0+IHNlcmlhbGl6ZUVycm9yJDFcbn0pO1xuY29uc3QgU0VSSUFMSVpFRF9LRVkgPSBcIl9fc2VyaWFsaXplZFwiO1xuY29uc3QgU0VSSUFMSVpFRF9WQUxVRSA9IHRydWU7XG4vKipcbiogQWRkIGZpcnN0LWNsYXNzIHN1cHBvcnQgZm9yIGNlcnRhaW4gZXJyb3JzIHRoYXQgd2UgY29udHJvbCwgaW4gYWRkaXRpb24gdG9cbiogYnVpbHQtaW4gZXJyb3JzIHN1Y2ggYXMgYFR5cGVFcnJvcmAuXG4qXG4qIEFkZGluZyB0aGVzZSBhbGxvd3MgdGhlc2Ugbm9uLXN0YW5kYXJkIGVycm9ycyB0byBiZSBjb3JyZWN0bHkgc2VyaWFsaXplZCxcbiogc2VudCB0byBJbm5nZXN0LCB0aGVuIGRlc2VyaWFsaXplZCBiYWNrIGludG8gdGhlIGNvcnJlY3QgZXJyb3IgdHlwZSBmb3IgdXNlcnNcbiogdG8gcmVhY3QgdG8gY29ycmVjdGx5LlxuKlxuKiBOb3RlIHRoYXQgdGhlc2UgZXJyb3JzIG9ubHkgc3VwcG9ydCBgbWVzc2FnZT86IHN0cmluZyB8IHVuZGVmaW5lZGAgYXMgdGhlXG4qIGlucHV0OyBtb3JlIGN1c3RvbSBlcnJvcnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGlzIGN1cnJlbnQgc3RyYXRlZ3kuXG4qL1xuZXJyb3JDb25zdHJ1Y3RvcnMuc2V0KFwiTm9uUmV0cmlhYmxlRXJyb3JcIiwgTm9uUmV0cmlhYmxlRXJyb3IpO1xuLyoqXG4qIFNlcmlhbGlzZSBhbiBlcnJvciB0byBhIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmcuXG4qXG4qIEVycm9ycyBkbyBub3Qgc2VyaWFsaXNlIG5pY2VseSB0byBKU09OLCBzbyB3ZSB1c2UgdGhpcyBmdW5jdGlvbiB0byBjb252ZXJ0XG4qIHRoZW0gdG8gYSBzZXJpYWxpemVkIEpTT04gc3RyaW5nLiBEb2luZyB0aGlzIGlzIGFsc28gbm9uLXRyaXZpYWwgZm9yIHNvbWVcbiogZXJyb3JzLCBzbyB3ZSB1c2UgdGhlIGBzZXJpYWxpemUtZXJyb3JgIHBhY2thZ2UgdG8gZG8gaXQgZm9yIHVzLlxuKlxuKiBTZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3NlcmlhbGl6ZS1lcnJvcn1cbipcbiogVGhpcyBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIHRoYXQgcGFja2FnZSB0byBhbHNvIGFkZCBhIGB0eXBlYFxuKiBwcm9wZXJ0eSB0byB0aGUgc2VyaWFsaXNlZCBlcnJvciwgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuKiBzZXJpYWxpc2VkIGVycm9ycyBhbmQgb3RoZXIgb2JqZWN0cy5cbipcbiogV2lsbCBub3QgcmVzZXJpYWxpc2UgZXhpc3Rpbmcgc2VyaWFsaXNlZCBlcnJvcnMuXG4qL1xuY29uc3Qgc2VyaWFsaXplRXJyb3IkMSA9IChzdWJqZWN0LCBhbGxvd1Vua25vd24gPSBmYWxzZSkgPT4ge1xuXHR0cnkge1xuXHRcdGNvbnN0IGV4aXN0aW5nU2VyaWFsaXplZEVycm9yID0gaXNTZXJpYWxpemVkRXJyb3Ioc3ViamVjdCk7XG5cdFx0aWYgKGV4aXN0aW5nU2VyaWFsaXplZEVycm9yKSByZXR1cm4gZXhpc3RpbmdTZXJpYWxpemVkRXJyb3I7XG5cdFx0aWYgKHR5cGVvZiBzdWJqZWN0ID09PSBcIm9iamVjdFwiICYmIHN1YmplY3QgIT09IG51bGwpIHtcblx0XHRcdGNvbnN0IHNlcmlhbGl6ZWRFcnIgPSBzZXJpYWxpemVFcnJvcihzdWJqZWN0KTtcblx0XHRcdGlmICghc2VyaWFsaXplZEVyci5uYW1lICYmIGFsbG93VW5rbm93bikgcmV0dXJuIHN1YmplY3Q7XG5cdFx0XHRjb25zdCByZXQgPSB7XG5cdFx0XHRcdC4uLnNlcmlhbGl6ZWRFcnIsXG5cdFx0XHRcdG5hbWU6IHNlcmlhbGl6ZWRFcnIubmFtZSB8fCBcIkVycm9yXCIsXG5cdFx0XHRcdG1lc3NhZ2U6IHNlcmlhbGl6ZWRFcnIubWVzc2FnZSB8fCBzdHJpbmdpZnkoc3ViamVjdCkgfHwgXCJVbmtub3duIGVycm9yOyBlcnJvciBzZXJpYWxpemF0aW9uIGNvdWxkIG5vdCBmaW5kIGEgbWVzc2FnZS5cIixcblx0XHRcdFx0c3RhY2s6IHNlcmlhbGl6ZWRFcnIuc3RhY2sgfHwgXCJcIixcblx0XHRcdFx0W1NFUklBTElaRURfS0VZXTogU0VSSUFMSVpFRF9WQUxVRVxuXHRcdFx0fTtcblx0XHRcdGxldCB0YXJnZXQgPSByZXQ7XG5cdFx0XHRjb25zdCBtYXhEZXB0aCA9IDU7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1heERlcHRoOyBpKyspIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIgJiYgdGFyZ2V0ICE9PSBudWxsICYmIFwiY2F1c2VcIiBpbiB0YXJnZXQgJiYgdGFyZ2V0LmNhdXNlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LmNhdXNlID0gc2VyaWFsaXplRXJyb3IkMSh0YXJnZXQuY2F1c2UsIHRydWUpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaXMgbm90IGFuIG9iamVjdDsgc3RyYW5nZSB0aHJvdyB2YWx1ZS5cIik7XG5cdH0gY2F0Y2gge1xuXHRcdGlmIChhbGxvd1Vua25vd24pIHJldHVybiBzdWJqZWN0O1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHQuLi5zZXJpYWxpemVFcnJvciQxKG5ldyBFcnJvcih0eXBlb2Ygc3ViamVjdCA9PT0gXCJzdHJpbmdcIiA/IHN1YmplY3QgOiBzdHJpbmdpZnkoc3ViamVjdCkpLCBmYWxzZSksXG5cdFx0XHRcdHN0YWNrOiBcIlwiLFxuXHRcdFx0XHRbU0VSSUFMSVpFRF9LRVldOiBTRVJJQUxJWkVEX1ZBTFVFXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bmFtZTogXCJDb3VsZCBub3Qgc2VyaWFsaXplIHNvdXJjZSBlcnJvclwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcIlNlcmlhbGl6aW5nIHRoZSBzb3VyY2UgZXJyb3IgZmFpbGVkLlwiLFxuXHRcdFx0XHRzdGFjazogXCJcIixcblx0XHRcdFx0W1NFUklBTElaRURfS0VZXTogU0VSSUFMSVpFRF9WQUxVRVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cbn07XG4vKipcbiogQ2hlY2sgaWYgYW4gb2JqZWN0IG9yIGEgc3RyaW5nIGlzIGEgc2VyaWFsaXNlZCBlcnJvciBjcmVhdGVkIGJ5XG4qIHtAbGluayBzZXJpYWxpemVFcnJvcn0uXG4qL1xuY29uc3QgaXNTZXJpYWxpemVkRXJyb3IgPSAodmFsdWUpID0+IHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRjb25zdCBwYXJzZWQgPSB6Lm9iamVjdCh7XG5cdFx0XHRcdFtTRVJJQUxJWkVEX0tFWV06IHoubGl0ZXJhbChTRVJJQUxJWkVEX1ZBTFVFKSxcblx0XHRcdFx0bmFtZTogei5lbnVtKFsuLi5BcnJheS5mcm9tKGVycm9yQ29uc3RydWN0b3JzLmtleXMoKSldKSxcblx0XHRcdFx0bWVzc2FnZTogei5zdHJpbmcoKSxcblx0XHRcdFx0c3RhY2s6IHouc3RyaW5nKClcblx0XHRcdH0pLnBhc3N0aHJvdWdoKCkuc2FmZVBhcnNlKEpTT04ucGFyc2UodmFsdWUpKTtcblx0XHRcdGlmIChwYXJzZWQuc3VjY2VzcykgcmV0dXJuIHBhcnNlZC5kYXRhO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoT2JqZWN0Lmhhc093bih2YWx1ZSwgU0VSSUFMSVpFRF9LRVkpICYmIHZhbHVlW1NFUklBTElaRURfS0VZXSA9PT0gU0VSSUFMSVpFRF9WQUxVRSkgcmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSBjYXRjaCB7fVxufTtcbi8qKlxuKiBEZXNlcmlhbGlzZSBhbiBlcnJvciBjcmVhdGVkIGJ5IHtAbGluayBzZXJpYWxpemVFcnJvcn0uXG4qXG4qIEVuc3VyZXMgd2Ugb25seSBkZXNlcmlhbGlzZSBlcnJvcnMgdGhhdCBtZWV0IGEgbWluaW11bSBsZXZlbCBvZlxuKiBhcHBsaWNhYmlsaXR5LCBpbmNsdXNpdmUgb2YgZXJyb3IgaGFuZGxpbmcgdG8gZW5zdXJlIHRoYXQgYmFkbHkgc2VyaWFsaXplZFxuKiBlcnJvcnMgYXJlIHN0aWxsIGhhbmRsZWQuXG4qL1xuY29uc3QgZGVzZXJpYWxpemVFcnJvciQxID0gKHN1YmplY3QsIGFsbG93VW5rbm93biA9IGZhbHNlKSA9PiB7XG5cdGNvbnN0IHJlcXVpcmVkRmllbGRzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIl07XG5cdHRyeSB7XG5cdFx0aWYgKCFyZXF1aXJlZEZpZWxkcy5ldmVyeSgoZmllbGQpID0+IHtcblx0XHRcdHJldHVybiBPYmplY3QuaGFzT3duKHN1YmplY3QsIGZpZWxkKTtcblx0XHR9KSkgdGhyb3cgbmV3IEVycm9yKCk7XG5cdFx0Y29uc3QgZGVzZXJpYWxpemVkRXJyID0gZGVzZXJpYWxpemVFcnJvcihzdWJqZWN0KTtcblx0XHRpZiAoXCJjYXVzZVwiIGluIGRlc2VyaWFsaXplZEVycikgZGVzZXJpYWxpemVkRXJyLmNhdXNlID0gZGVzZXJpYWxpemVFcnJvciQxKGRlc2VyaWFsaXplZEVyci5jYXVzZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIGRlc2VyaWFsaXplZEVycjtcblx0fSBjYXRjaCB7XG5cdFx0aWYgKGFsbG93VW5rbm93bikgcmV0dXJuIHN1YmplY3Q7XG5cdFx0Y29uc3QgZXJyID0gLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcihcIlVua25vd24gZXJyb3I7IGNvdWxkIG5vdCByZXNlcmlhbGl6ZVwiKTtcblx0XHQvKipcblx0XHQqIFJlbW92ZSB0aGUgc3RhY2sgc28gdGhhdCBpdCdzIG5vdCBtaXNsZWFkaW5nbHkgc2hvd24gYXMgdGhlIElubmdlc3Rcblx0XHQqIGludGVybmFscy5cblx0XHQqL1xuXHRcdGVyci5zdGFjayA9IHZvaWQgMDtcblx0XHRyZXR1cm4gZXJyO1xuXHR9XG59O1xubGV0IEVyckNvZGUgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oRXJyQ29kZSQxKSB7XG5cdEVyckNvZGUkMVtcIk5FU1RJTkdfU1RFUFNcIl0gPSBcIk5FU1RJTkdfU1RFUFNcIjtcblx0LyoqXG5cdCogTGVnYWN5IHYwIGV4ZWN1dGlvbiBlcnJvciBjb2RlIGZvciB3aGVuIGEgZnVuY3Rpb24gaGFzIGNoYW5nZWQgYW5kIG5vXG5cdCogbG9uZ2VyIG1hdGNoZXMgaXRzIGluLXByb2dyZXNzIHN0YXRlLlxuXHQqXG5cdCogQGRlcHJlY2F0ZWQgTm90IGZvciB1c2UgaW4gbGF0ZXN0IGV4ZWN1dGlvbiBtZXRob2QuXG5cdCovXG5cdEVyckNvZGUkMVtcIk5PTl9ERVRFUk1JTklTVElDX0ZVTkNUSU9OXCJdID0gXCJOT05fREVURVJNSU5JU1RJQ19GVU5DVElPTlwiO1xuXHQvKipcblx0KiBMZWdhY3kgdjAgZXhlY3V0aW9uIGVycm9yIGNvZGUgZm9yIHdoZW4gYSBmdW5jdGlvbiBpcyBmb3VuZCB0byBiZSB1c2luZ1xuXHQqIGFzeW5jIGFjdGlvbnMgYWZ0ZXIgbWVtb3ppYXRpb24gaGFzIG9jY3VycmVkLCB3aGljaCB2MCBkb2Vzbid0IHN1cHBvcnQuXG5cdCpcblx0KiBAZGVwcmVjYXRlZCBOb3QgZm9yIHVzZSBpbiBsYXRlc3QgZXhlY3V0aW9uIG1ldGhvZC5cblx0Ki9cblx0RXJyQ29kZSQxW1wiQVNZTkNfREVURUNURURfQUZURVJfTUVNT0laQVRJT05cIl0gPSBcIkFTWU5DX0RFVEVDVEVEX0FGVEVSX01FTU9JWkFUSU9OXCI7XG5cdC8qKlxuXHQqIExlZ2FjeSB2MCBleGVjdXRpb24gZXJyb3IgY29kZSBmb3Igd2hlbiBhIGZ1bmN0aW9uIGlzIGZvdW5kIHRvIGJlIHVzaW5nXG5cdCogc3RlcHMgYWZ0ZXIgYSBub24tc3RlcCBhc3luYyBhY3Rpb24gaGFzIG9jY3VycmVkLlxuXHQqXG5cdCogQGRlcHJlY2F0ZWQgTm90IGZvciB1c2UgaW4gbGF0ZXN0IGV4ZWN1dGlvbiBtZXRob2QuXG5cdCovXG5cdEVyckNvZGUkMVtcIlNURVBfVVNFRF9BRlRFUl9BU1lOQ1wiXSA9IFwiU1RFUF9VU0VEX0FGVEVSX0FTWU5DXCI7XG5cdEVyckNvZGUkMVtcIkFVVE9NQVRJQ19QQVJBTExFTF9JTkRFWElOR1wiXSA9IFwiQVVUT01BVElDX1BBUkFMTEVMX0lOREVYSU5HXCI7XG5cdHJldHVybiBFcnJDb2RlJDE7XG59KHt9KTtcbmNvbnN0IHByZXR0eUVycm9yU3BsaXR0ZXIgPSBcIj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIjtcbi8qKlxuKiBHaXZlbiBhbiB1bmtub3duIGBlcnJgLCBtdXRhdGUgaXQgdG8gbWluaWZ5IGFueSBwcmV0dHkgZXJyb3JzIHRoYXQgaXRcbiogY29udGFpbnMuXG4qL1xuY29uc3QgbWluaWZ5UHJldHR5RXJyb3IgPSAoZXJyKSA9PiB7XG5cdHRyeSB7XG5cdFx0aWYgKCFpc0Vycm9yKGVycikpIHJldHVybiBlcnI7XG5cdFx0aWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcyhwcmV0dHlFcnJvclNwbGl0dGVyKSkgcmV0dXJuIGVycjtcblx0XHRjb25zdCBzYW5pdGl6ZWRNZXNzYWdlID0gc3RyaXBBbnNpKGVyci5tZXNzYWdlKTtcblx0XHRjb25zdCBtZXNzYWdlID0gc2FuaXRpemVkTWVzc2FnZS5zcGxpdChcIiAgXCIpWzFdPy5zcGxpdChcIlxcblwiKVswXT8udHJpbSgpIHx8IGVyci5tZXNzYWdlO1xuXHRcdGVyci5tZXNzYWdlID0gW3Nhbml0aXplZE1lc3NhZ2Uuc3BsaXQoXCJcXG5cXG5Db2RlOiBcIilbMV0/LnNwbGl0KFwiXFxuXFxuXCIpWzBdPy50cmltKCkgfHwgdm9pZCAwLCBtZXNzYWdlXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiAtIFwiKTtcblx0XHRpZiAoZXJyLnN0YWNrKSB7XG5cdFx0XHRjb25zdCBzdGFja1Jlc3QgPSBzdHJpcEFuc2koZXJyLnN0YWNrKS5zcGxpdChgJHtwcmV0dHlFcnJvclNwbGl0dGVyfVxcbmApLnNsaWNlKDIpLmpvaW4oXCJcXG5cIik7XG5cdFx0XHRlcnIuc3RhY2sgPSBgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9XFxuJHtzdGFja1Jlc3R9YDtcblx0XHR9XG5cdFx0cmV0dXJuIGVycjtcblx0fSBjYXRjaCAoX25vb3BFcnIpIHtcblx0XHRyZXR1cm4gZXJyO1xuXHR9XG59O1xuLyoqXG4qIEdpdmVuIGFuIGBlcnJgLCByZXR1cm4gYSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIGl0IGlzIGluIHRoZSBzaGFwZSBvZlxuKiBhbiBgRXJyb3JgIG9yIG5vdC5cbiovXG5jb25zdCBpc0Vycm9yID0gKGVycikgPT4ge1xuXHR0cnkge1xuXHRcdGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHRydWU7XG5cdFx0aWYgKHR5cGVvZiBlcnIgIT09IFwib2JqZWN0XCIgfHwgZXJyID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIE9iamVjdC5oYXNPd24oZXJyLCBcIm5hbWVcIikgJiYgT2JqZWN0Lmhhc093bihlcnIsIFwibWVzc2FnZVwiKTtcblx0fSBjYXRjaCAoX25vb3BFcnIpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG4vKipcbiogR2l2ZW4gYW4gYHVua25vd25gIG9iamVjdCwgcmV0cmlldmUgdGhlIGBtZXNzYWdlYCBwcm9wZXJ0eSBmcm9tIGl0LCBvciBmYWxsXG4qIGJhY2sgdG8gdGhlIGBmYWxsYmFja2Agc3RyaW5nIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaXMgZW1wdHkuXG4qL1xuY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKGVyciwgZmFsbGJhY2spID0+IHtcblx0Y29uc3QgeyBtZXNzYWdlIH0gPSB6Lm9iamVjdCh7IG1lc3NhZ2U6IHouc3RyaW5nKCkubWluKDEpIH0pLmNhdGNoKHsgbWVzc2FnZTogZmFsbGJhY2sgfSkucGFyc2UoZXJyKTtcblx0cmV0dXJuIG1lc3NhZ2U7XG59O1xuLyoqXG4qIEdpdmVuIGEge0BsaW5rIFByZXR0eUVycm9yfSwgcmV0dXJuIGEgbmljZWx5LWZvcm1hdHRlZCBzdHJpbmcgcmVhZHkgdG8gbG9nXG4qIG9yIHRocm93LlxuKlxuKiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgZXJyb3JzIGFyZSBsb2dnZWQgaW4gYSBjb25zaXN0ZW50LCBoZWxwZnVsIGZvcm1hdFxuKiBhY3Jvc3MgdGhlIFNESyBieSBwcm9tcHRpbmcgZm9yIGtleSBwaWVjZXMgb2YgaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgcHJldHR5RXJyb3IgPSAoeyB0eXBlID0gXCJlcnJvclwiLCB3aGF0SGFwcGVuZWQsIG90aGVyd2lzZSwgcmVhc3N1cmFuY2UsIHRvRml4Tm93LCB3aHksIGNvbnNlcXVlbmNlcywgc3RhY2ssIGNvZGUgfSkgPT4ge1xuXHRjb25zdCB7IGljb24sIGNvbG9yRm4gfSA9IHtcblx0XHRlcnJvcjoge1xuXHRcdFx0aWNvbjogXCLinYxcIixcblx0XHRcdGNvbG9yRm46IGNoYWxrLnJlZFxuXHRcdH0sXG5cdFx0d2Fybjoge1xuXHRcdFx0aWNvbjogXCLimqDvuI9cIixcblx0XHRcdGNvbG9yRm46IGNoYWxrLnllbGxvd1xuXHRcdH1cblx0fVt0eXBlXTtcblx0bGV0IGhlYWRlciA9IGAke2ljb259ICAke2NoYWxrLmJvbGQudW5kZXJsaW5lKHdoYXRIYXBwZW5lZC50cmltKCkpfWA7XG5cdGlmIChzdGFjaykgaGVhZGVyICs9IFwiXFxuXCIgKyBbLi4uKC8qIEBfX1BVUkVfXyAqLyBuZXcgRXJyb3IoKSkuc3RhY2s/LnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEpLmZpbHRlcihCb29sZWFuKSB8fCBbXV0uam9pbihcIlxcblwiKTtcblx0bGV0IHRvRml4Tm93U3RyID0gKEFycmF5LmlzQXJyYXkodG9GaXhOb3cpID8gdG9GaXhOb3cubWFwKChzKSA9PiBzLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pLm1hcCgocywgaSkgPT4gYFxcdCR7aSArIDF9LiAke3N9YCkuam9pbihcIlxcblwiKSA6IHRvRml4Tm93Py50cmltKCkpID8/IFwiXCI7XG5cdGlmIChBcnJheS5pc0FycmF5KHRvRml4Tm93KSAmJiB0b0ZpeE5vd1N0cikgdG9GaXhOb3dTdHIgPSBgVG8gZml4IHRoaXMsIHlvdSBjYW4gdGFrZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBjb3Vyc2VzIG9mIGFjdGlvbjpcXG5cXG4ke3RvRml4Tm93U3RyfWA7XG5cdGxldCBib2R5ID0gW1xuXHRcdHJlYXNzdXJhbmNlPy50cmltKCksXG5cdFx0d2h5Py50cmltKCksXG5cdFx0Y29uc2VxdWVuY2VzPy50cmltKClcblx0XS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG5cdGJvZHkgKz0gYm9keSA/IGBcXG5cXG4ke3RvRml4Tm93U3RyfWAgOiB0b0ZpeE5vd1N0cjtcblx0Y29uc3QgdHJhaWxlciA9IFtvdGhlcndpc2U/LnRyaW0oKV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuXHRyZXR1cm4gY29sb3JGbihbXG5cdFx0cHJldHR5RXJyb3JTcGxpdHRlcixcblx0XHRoZWFkZXIsXG5cdFx0Ym9keSxcblx0XHR0cmFpbGVyLFxuXHRcdGNvZGUgPyBgQ29kZTogJHtjb2RlfWAgOiBcIlwiLFxuXHRcdHByZXR0eUVycm9yU3BsaXR0ZXJcblx0XS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblxcblwiKSk7XG59O1xuY29uc3QgZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMgPSBbXG5cdFwiU2V0IHRoZSBgSU5OR0VTVF9FVkVOVF9LRVlgIGVudmlyb25tZW50IHZhcmlhYmxlXCIsXG5cdGBQYXNzIGEga2V5IHRvIHRoZSBcXGBuZXcgSW5uZ2VzdCgpXFxgIGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBcXGBldmVudEtleVxcYCBvcHRpb25gLFxuXHRgVXNlIFxcYGlubmdlc3Quc2V0RXZlbnRLZXkoKVxcYCBhdCBydW50aW1lYFxuXTtcbi8qKlxuKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIGludGVybmFsbHkgdGhhdCBhbiBvdXRnb2luZyBvcGVyYXRpb25cbiogY29udGFpbnMgYW4gZXJyb3IuXG4qXG4qIFdlIHVzZSB0aGlzIGJlY2F1c2Ugc2VyaWFsaXplZCBgZGF0YWAgc2VudCBiYWNrIHRvIElubmdlc3QgbWF5IGRpZmZlciBmcm9tXG4qIHRoZSBlcnJvciBpbnN0YW5jZSBpdHNlbGYgZHVlIHRvIG1pZGRsZXdhcmUuXG4qXG4qIEBpbnRlcm5hbFxuKi9cbnZhciBPdXRnb2luZ1Jlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdHJlc3VsdDtcblx0Y29uc3RydWN0b3IocmVzdWx0KSB7XG5cdFx0c3VwZXIoXCJPdXRnb2luZ09wRXJyb3JcIik7XG5cdFx0dGhpcy5yZXN1bHQgPSByZXN1bHQ7XG5cdH1cbn07XG4vKipcbiogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldGhyb3cgYW4gZXJyb3Igd2l0aCBhIHByZWZpeCBhZGRlZCB0byB0aGVcbiogbWVzc2FnZS5cbipcbiogVXNlZnVsIGZvciBhZGRpbmcgY29udGV4dCB0byBlcnJvcnMgdGhhdCBhcmUgcmV0aHJvd24uXG4qXG4qIEBleGFtcGxlXG4qIGBgYHRzXG4qIGF3YWl0IGRvU29tZUFjdGlvbigpLmNhdGNoKHJldGhyb3dFcnJvcihcIkZhaWxlZCB0byBkbyBzb21lIGFjdGlvblwiKSk7XG4qIGBgYFxuKi9cbmNvbnN0IHJldGhyb3dFcnJvciA9IChwcmVmaXgpID0+IHtcblx0cmV0dXJuIChlcnIpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0ZXJyLm1lc3NhZ2UgJiY9IGAke3ByZWZpeH07ICR7ZXJyLm1lc3NhZ2V9YDtcblx0XHR9IGNhdGNoIChfbm9vcEVycikge30gZmluYWxseSB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fVxuXHR9O1xufTtcbi8qKlxuKiBMZWdhY3kgdjAgZXhlY3V0aW9uIGVycm9yIGZvciBmdW5jdGlvbnMgdGhhdCBkb24ndCBzdXBwb3J0IG1peGluZyBzdGVwcyBhbmRcbiogcmVndWxhciBhc3luYyBhY3Rpb25zLlxuKi9cbmNvbnN0IGZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIgPSAoY29kZSkgPT4ge1xuXHRyZXR1cm4gcHJldHR5RXJyb3Ioe1xuXHRcdHdoYXRIYXBwZW5lZDogXCJZb3VyIGZ1bmN0aW9uIHdhcyBzdG9wcGVkIGZyb20gcnVubmluZ1wiLFxuXHRcdHdoeTogXCJXZSBkZXRlY3RlZCBhIG1peCBvZiBhc3luY2hyb25vdXMgbG9naWMsIHNvbWUgdXNpbmcgc3RlcCB0b29saW5nIGFuZCBzb21lIG5vdC5cIixcblx0XHRjb25zZXF1ZW5jZXM6IFwiVGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgd2hlbiBhIGZ1bmN0aW9uIGlzIHBhdXNlZCBhbmQgcmVzdW1lZCBhbmQgaXMgdGhlcmVmb3JlIHN0cm9uZ2x5IGRpc2NvdXJhZ2VkOyB3ZSBzdG9wcGVkIHlvdXIgZnVuY3Rpb24gdG8gZW5zdXJlIG5vdGhpbmcgdW5leHBlY3RlZCBoYXBwZW5lZCFcIixcblx0XHRzdGFjazogdHJ1ZSxcblx0XHR0b0ZpeE5vdzogXCJFbnN1cmUgdGhhdCB5b3VyIGZ1bmN0aW9uIGlzIGVpdGhlciBlbnRpcmVseSBzdGVwLWJhc2VkIG9yIGVudGlyZWx5IG5vbi1zdGVwLWJhc2VkLCBieSBlaXRoZXIgd3JhcHBpbmcgYWxsIGFzeW5jaHJvbm91cyBsb2dpYyBpbiBgc3RlcC5ydW4oKWAgY2FsbHMgb3IgYnkgcmVtb3ZpbmcgYWxsIGBzdGVwLiooKWAgY2FsbHMuXCIsXG5cdFx0b3RoZXJ3aXNlOiBcIkZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoeSBzdGVwIGZ1bmN0aW9ucyB3b3JrIGluIHRoaXMgbWFubmVyLCBzZWUgaHR0cHM6Ly93d3cuaW5uZ2VzdC5jb20vZG9jcy9mdW5jdGlvbnMvbXVsdGktc3RlcCNnb3RjaGFzXCIsXG5cdFx0Y29kZVxuXHR9KTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgRXJyQ29kZSwgZGVzZXJpYWxpemVFcnJvciQxIGFzIGRlc2VyaWFsaXplRXJyb3IsIGVycm9yc19leHBvcnRzLCBmaXhFdmVudEtleU1pc3NpbmdTdGVwcywgZnVuY3Rpb25TdG9wcGVkUnVubmluZ0VyciwgZ2V0RXJyb3JNZXNzYWdlLCBtaW5pZnlQcmV0dHlFcnJvciwgcHJldHR5RXJyb3IsIHJldGhyb3dFcnJvciwgc2VyaWFsaXplRXJyb3IkMSBhcyBzZXJpYWxpemVFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2V4cG9ydCIsIk5vblJldHJpYWJsZUVycm9yIiwieiIsImNoYWxrIiwic3RyaW5naWZ5IiwiZGVzZXJpYWxpemVFcnJvciIsImVycm9yQ29uc3RydWN0b3JzIiwic2VyaWFsaXplRXJyb3IiLCJzdHJpcEFuc2kiLCJlcnJvcnNfZXhwb3J0cyIsIkVyckNvZGUiLCJPdXRnb2luZ1Jlc3VsdEVycm9yIiwiZGVzZXJpYWxpemVFcnJvciQxIiwiZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMiLCJmdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyIiwiZ2V0RXJyb3JNZXNzYWdlIiwiaXNTZXJpYWxpemVkRXJyb3IiLCJtaW5pZnlQcmV0dHlFcnJvciIsInByZXR0eUVycm9yIiwicHJldHR5RXJyb3JTcGxpdHRlciIsInJldGhyb3dFcnJvciIsInNlcmlhbGl6ZUVycm9yJDEiLCJTRVJJQUxJWkVEX0tFWSIsIlNFUklBTElaRURfVkFMVUUiLCJzZXQiLCJzdWJqZWN0IiwiYWxsb3dVbmtub3duIiwiZXhpc3RpbmdTZXJpYWxpemVkRXJyb3IiLCJzZXJpYWxpemVkRXJyIiwibmFtZSIsInJldCIsIm1lc3NhZ2UiLCJzdGFjayIsInRhcmdldCIsIm1heERlcHRoIiwiaSIsImNhdXNlIiwiRXJyb3IiLCJ2YWx1ZSIsInBhcnNlZCIsIm9iamVjdCIsImxpdGVyYWwiLCJlbnVtIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInN0cmluZyIsInBhc3N0aHJvdWdoIiwic2FmZVBhcnNlIiwiSlNPTiIsInBhcnNlIiwic3VjY2VzcyIsImRhdGEiLCJPYmplY3QiLCJoYXNPd24iLCJyZXF1aXJlZEZpZWxkcyIsImV2ZXJ5IiwiZmllbGQiLCJkZXNlcmlhbGl6ZWRFcnIiLCJlcnIiLCJFcnJDb2RlJDEiLCJpc0Vycm9yIiwiaW5jbHVkZXMiLCJzYW5pdGl6ZWRNZXNzYWdlIiwic3BsaXQiLCJ0cmltIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJzdGFja1Jlc3QiLCJzbGljZSIsIl9ub29wRXJyIiwiZmFsbGJhY2siLCJtaW4iLCJjYXRjaCIsInR5cGUiLCJ3aGF0SGFwcGVuZWQiLCJvdGhlcndpc2UiLCJyZWFzc3VyYW5jZSIsInRvRml4Tm93Iiwid2h5IiwiY29uc2VxdWVuY2VzIiwiY29kZSIsImljb24iLCJjb2xvckZuIiwiZXJyb3IiLCJyZWQiLCJ3YXJuIiwieWVsbG93IiwiaGVhZGVyIiwiYm9sZCIsInVuZGVybGluZSIsInRvRml4Tm93U3RyIiwiaXNBcnJheSIsIm1hcCIsInMiLCJib2R5IiwidHJhaWxlciIsImNvbnN0cnVjdG9yIiwicmVzdWx0IiwicHJlZml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/functions.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/functions.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheFn: () => (/* binding */ cacheFn),\n/* harmony export */   fetchAllFnData: () => (/* binding */ fetchAllFnData),\n/* harmony export */   parseFnData: () => (/* binding */ parseFnData),\n/* harmony export */   undefinedToNull: () => (/* binding */ undefinedToNull),\n/* harmony export */   waterfall: () => (/* binding */ waterfall)\n/* harmony export */ });\n/* harmony import */ var _consts_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/* harmony import */ var _api_schema_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../api/schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\n/* harmony import */ var _components_execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/ZodError.js\");\n\n\n\n\n\n\n//#region src/helpers/functions.ts\n/**\n* Wraps a function with a cache. When the returned function is run, it will\n* cache the result and return it on subsequent calls.\n*/ const cacheFn = (fn)=>{\n    const key = \"value\";\n    const cache = /* @__PURE__ */ new Map();\n    return (...args)=>{\n        if (!cache.has(key)) cache.set(key, fn(...args));\n        return cache.get(key);\n    };\n};\n/**\n* Given an array of functions, return a new function that will run each\n* function in series and return the result of the final function. Regardless of\n* if the functions are synchronous or asynchronous, they'll be made into an\n* async promise chain.\n*\n* If an error is thrown, the waterfall will stop and return the error.\n*\n* Because this needs to support both sync and async functions, it only allows\n* functions that accept a single argument.\n*/ const waterfall = (fns, transform)=>{\n    return (...args)=>{\n        return fns.reduce(async (acc, fn)=>{\n            const prev = await acc;\n            const output = await fn(prev);\n            if (transform) return await transform(prev, output);\n            if (typeof output === \"undefined\") return prev;\n            return output;\n        }, Promise.resolve(args[0]));\n    };\n};\n/**\n* Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n*/ const undefinedToNull = (v)=>{\n    return typeof v === \"undefined\" ? null : v;\n};\nconst fnDataVersionSchema = zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n    version: zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(-1).or(zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(0)).or(zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(1)).or(zod_v3__WEBPACK_IMPORTED_MODULE_0__.literal(2)).optional().transform((v)=>{\n        if (typeof v === \"undefined\") {\n            console.debug(`No request version specified by executor; defaulting to v${_components_execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_1__.PREFERRED_EXECUTION_VERSION}`);\n            return _components_execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_1__.PREFERRED_EXECUTION_VERSION;\n        }\n        return v === -1 ? _components_execution_InngestExecution_js__WEBPACK_IMPORTED_MODULE_1__.PREFERRED_EXECUTION_VERSION : v;\n    })\n});\nconst parseFnData = (data)=>{\n    let version;\n    try {\n        ({ version } = fnDataVersionSchema.parse(data));\n        return ({\n            [_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V0]: ()=>({\n                    version: _consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V0,\n                    ...zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                        event: zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any()),\n                        events: zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any())).default([]),\n                        steps: _api_schema_js__WEBPACK_IMPORTED_MODULE_3__.stepsSchemas[_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V0],\n                        ctx: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                            run_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string(),\n                            attempt: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number().default(0),\n                            stack: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                                stack: zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),\n                                current: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number()\n                            }).passthrough().optional().nullable()\n                        }).optional().nullable(),\n                        use_api: zod_v3__WEBPACK_IMPORTED_MODULE_0__.boolean().default(false)\n                    }).parse(data)\n                }),\n            [_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V1]: ()=>({\n                    version: _consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V1,\n                    ...zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                        event: zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any()),\n                        events: zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any())).default([]),\n                        steps: _api_schema_js__WEBPACK_IMPORTED_MODULE_3__.stepsSchemas[_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V1],\n                        ctx: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                            run_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string(),\n                            attempt: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number().default(0),\n                            max_attempts: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n                            disable_immediate_execution: zod_v3__WEBPACK_IMPORTED_MODULE_0__.boolean().default(false),\n                            use_api: zod_v3__WEBPACK_IMPORTED_MODULE_0__.boolean().default(false),\n                            stack: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                                stack: zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),\n                                current: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number()\n                            }).passthrough().optional().nullable()\n                        }).optional().nullable()\n                    }).parse(data)\n                }),\n            [_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V2]: ()=>({\n                    version: _consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V2,\n                    ...zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                        event: zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any()),\n                        events: zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.record(zod_v3__WEBPACK_IMPORTED_MODULE_0__.any())).default([]),\n                        steps: _api_schema_js__WEBPACK_IMPORTED_MODULE_3__.stepsSchemas[_consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V2],\n                        ctx: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                            run_id: zod_v3__WEBPACK_IMPORTED_MODULE_0__.string(),\n                            attempt: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number().default(0),\n                            max_attempts: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n                            disable_immediate_execution: zod_v3__WEBPACK_IMPORTED_MODULE_0__.boolean().default(false),\n                            use_api: zod_v3__WEBPACK_IMPORTED_MODULE_0__.boolean().default(false),\n                            stack: zod_v3__WEBPACK_IMPORTED_MODULE_0__.object({\n                                stack: zod_v3__WEBPACK_IMPORTED_MODULE_0__.array(zod_v3__WEBPACK_IMPORTED_MODULE_0__.string()).nullable().transform((v)=>Array.isArray(v) ? v : []),\n                                current: zod_v3__WEBPACK_IMPORTED_MODULE_0__.number()\n                            }).passthrough().optional().nullable()\n                        }).optional().nullable()\n                    }).parse(data)\n                })\n        })[version]();\n    } catch (err$1) {\n        throw new Error(parseFailureErr(err$1));\n    }\n};\nconst fetchAllFnData = async ({ data, api, version })=>{\n    const result = {\n        ...data\n    };\n    try {\n        if (result.version === _consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V0 && result.use_api || result.version === _consts_js__WEBPACK_IMPORTED_MODULE_2__.ExecutionVersion.V1 && result.ctx?.use_api) {\n            if (!result.ctx?.run_id) return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)((0,_errors_js__WEBPACK_IMPORTED_MODULE_5__.prettyError)({\n                whatHappened: \"failed to attempt retrieving data from API\",\n                consequences: \"function execution can't continue\",\n                why: \"run_id is missing from context\",\n                stack: true\n            }));\n            const [evtResp, stepResp] = await Promise.all([\n                api.getRunBatch(result.ctx.run_id),\n                api.getRunSteps(result.ctx.run_id, version)\n            ]);\n            if (evtResp.ok) result.events = evtResp.value;\n            else return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)((0,_errors_js__WEBPACK_IMPORTED_MODULE_5__.prettyError)({\n                whatHappened: \"failed to retrieve list of events\",\n                consequences: \"function execution can't continue\",\n                why: evtResp.error?.error,\n                stack: true\n            }));\n            if (stepResp.ok) result.steps = stepResp.value;\n            else return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)((0,_errors_js__WEBPACK_IMPORTED_MODULE_5__.prettyError)({\n                whatHappened: \"failed to retrieve steps for function run\",\n                consequences: \"function execution can't continue\",\n                why: stepResp.error?.error,\n                stack: true\n            }));\n        }\n        const stepIds = Object.keys(result.steps || {});\n        if (stepIds.length && !result.ctx?.stack?.length) result.ctx = {\n            ...result.ctx,\n            stack: {\n                stack: stepIds,\n                current: stepIds.length - 1\n            }\n        };\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.ok)(result);\n    } catch (error) {\n        console.error(error);\n        return (0,_types_js__WEBPACK_IMPORTED_MODULE_4__.err)(parseFailureErr(error));\n    }\n};\nconst parseFailureErr = (err$1)=>{\n    let why;\n    if (err$1 instanceof zod_v3__WEBPACK_IMPORTED_MODULE_6__.ZodError) why = err$1.toString();\n    return (0,_errors_js__WEBPACK_IMPORTED_MODULE_5__.prettyError)({\n        whatHappened: \"Failed to parse data from executor.\",\n        consequences: \"Function execution can't continue.\",\n        toFixNow: \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n        stack: true,\n        why\n    });\n};\n//#endregion\n //# sourceMappingURL=functions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Z1bmN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDVDtBQUNVO0FBQzBDO0FBQ2hEO0FBQ0w7QUFFckMsa0NBQWtDO0FBQ2xDOzs7QUFHQSxHQUNBLE1BQU1RLFVBQVUsQ0FBQ0M7SUFDaEIsTUFBTUMsTUFBTTtJQUNaLE1BQU1DLFFBQVEsYUFBYSxHQUFHLElBQUlDO0lBQ2xDLE9BQVEsQ0FBQyxHQUFHQztRQUNYLElBQUksQ0FBQ0YsTUFBTUcsR0FBRyxDQUFDSixNQUFNQyxNQUFNSSxHQUFHLENBQUNMLEtBQUtELE1BQU1JO1FBQzFDLE9BQU9GLE1BQU1LLEdBQUcsQ0FBQ047SUFDbEI7QUFDRDtBQUNBOzs7Ozs7Ozs7O0FBVUEsR0FDQSxNQUFNTyxZQUFZLENBQUNDLEtBQUtDO0lBQ3ZCLE9BQU8sQ0FBQyxHQUFHTjtRQUNWLE9BQU9LLElBQUlFLE1BQU0sQ0FBQyxPQUFPQyxLQUFLWjtZQUM3QixNQUFNYSxPQUFPLE1BQU1EO1lBQ25CLE1BQU1FLFNBQVMsTUFBTWQsR0FBR2E7WUFDeEIsSUFBSUgsV0FBVyxPQUFPLE1BQU1BLFVBQVVHLE1BQU1DO1lBQzVDLElBQUksT0FBT0EsV0FBVyxhQUFhLE9BQU9EO1lBQzFDLE9BQU9DO1FBQ1IsR0FBR0MsUUFBUUMsT0FBTyxDQUFDWixJQUFJLENBQUMsRUFBRTtJQUMzQjtBQUNEO0FBQ0E7O0FBRUEsR0FDQSxNQUFNYSxrQkFBa0IsQ0FBQ0M7SUFDeEIsT0FBTyxPQUFPQSxNQUFNLGNBQWMsT0FBT0E7QUFDMUM7QUFDQSxNQUFNQyxzQkFBc0JyQiwwQ0FBUSxDQUFDO0lBQUV1QixTQUFTdkIsMkNBQVMsQ0FBQyxDQUFDLEdBQUd5QixFQUFFLENBQUN6QiwyQ0FBUyxDQUFDLElBQUl5QixFQUFFLENBQUN6QiwyQ0FBUyxDQUFDLElBQUl5QixFQUFFLENBQUN6QiwyQ0FBUyxDQUFDLElBQUkwQixRQUFRLEdBQUdkLFNBQVMsQ0FBQyxDQUFDUTtRQUN0SSxJQUFJLE9BQU9BLE1BQU0sYUFBYTtZQUM3Qk8sUUFBUUMsS0FBSyxDQUFDLENBQUMseURBQXlELEVBQUUvQixrR0FBMkJBLENBQUMsQ0FBQztZQUN2RyxPQUFPQSxrR0FBMkJBO1FBQ25DO1FBQ0EsT0FBT3VCLE1BQU0sQ0FBQyxJQUFJdkIsa0dBQTJCQSxHQUFHdUI7SUFDakQ7QUFBRztBQUNILE1BQU1TLGNBQWMsQ0FBQ0M7SUFDcEIsSUFBSVA7SUFDSixJQUFJO1FBQ0YsR0FBQ0EsT0FBTyxFQUFDLEdBQUdGLG9CQUFvQlUsS0FBSyxDQUFDRCxLQUFJO1FBQzNDLE9BQU87WUFDTixDQUFDckMsd0RBQWdCQSxDQUFDdUMsRUFBRSxDQUFDLEVBQUUsSUFBTztvQkFDN0JULFNBQVM5Qix3REFBZ0JBLENBQUN1QyxFQUFFO29CQUM1QixHQUFHaEMsMENBQVEsQ0FBQzt3QkFDWGlDLE9BQU9qQywwQ0FBUSxDQUFDQSx1Q0FBSzt3QkFDckJvQyxRQUFRcEMseUNBQU8sQ0FBQ0EsMENBQVEsQ0FBQ0EsdUNBQUssS0FBS3NDLE9BQU8sQ0FBQyxFQUFFO3dCQUM3Q0MsT0FBTzNDLHdEQUFZLENBQUNILHdEQUFnQkEsQ0FBQ3VDLEVBQUUsQ0FBQzt3QkFDeENRLEtBQUt4QywwQ0FBUSxDQUFDOzRCQUNieUMsUUFBUXpDLDBDQUFROzRCQUNoQjJDLFNBQVMzQywwQ0FBUSxHQUFHc0MsT0FBTyxDQUFDOzRCQUM1Qk8sT0FBTzdDLDBDQUFRLENBQUM7Z0NBQ2Y2QyxPQUFPN0MseUNBQU8sQ0FBQ0EsMENBQVEsSUFBSThDLFFBQVEsR0FBR2xDLFNBQVMsQ0FBQyxDQUFDUSxJQUFNMkIsTUFBTUMsT0FBTyxDQUFDNUIsS0FBS0EsSUFBSSxFQUFFO2dDQUNoRjZCLFNBQVNqRCwwQ0FBUTs0QkFDbEIsR0FBR2tELFdBQVcsR0FBR3hCLFFBQVEsR0FBR29CLFFBQVE7d0JBQ3JDLEdBQUdwQixRQUFRLEdBQUdvQixRQUFRO3dCQUN0QkssU0FBU25ELDJDQUFTLEdBQUdzQyxPQUFPLENBQUM7b0JBQzlCLEdBQUdQLEtBQUssQ0FBQ0QsS0FBSztnQkFDZjtZQUNBLENBQUNyQyx3REFBZ0JBLENBQUM0RCxFQUFFLENBQUMsRUFBRSxJQUFPO29CQUM3QjlCLFNBQVM5Qix3REFBZ0JBLENBQUM0RCxFQUFFO29CQUM1QixHQUFHckQsMENBQVEsQ0FBQzt3QkFDWGlDLE9BQU9qQywwQ0FBUSxDQUFDQSx1Q0FBSzt3QkFDckJvQyxRQUFRcEMseUNBQU8sQ0FBQ0EsMENBQVEsQ0FBQ0EsdUNBQUssS0FBS3NDLE9BQU8sQ0FBQyxFQUFFO3dCQUM3Q0MsT0FBTzNDLHdEQUFZLENBQUNILHdEQUFnQkEsQ0FBQzRELEVBQUUsQ0FBQzt3QkFDeENiLEtBQUt4QywwQ0FBUSxDQUFDOzRCQUNieUMsUUFBUXpDLDBDQUFROzRCQUNoQjJDLFNBQVMzQywwQ0FBUSxHQUFHc0MsT0FBTyxDQUFDOzRCQUM1QmdCLGNBQWN0RCwwQ0FBUSxHQUFHMEIsUUFBUTs0QkFDakM2Qiw2QkFBNkJ2RCwyQ0FBUyxHQUFHc0MsT0FBTyxDQUFDOzRCQUNqRGEsU0FBU25ELDJDQUFTLEdBQUdzQyxPQUFPLENBQUM7NEJBQzdCTyxPQUFPN0MsMENBQVEsQ0FBQztnQ0FDZjZDLE9BQU83Qyx5Q0FBTyxDQUFDQSwwQ0FBUSxJQUFJOEMsUUFBUSxHQUFHbEMsU0FBUyxDQUFDLENBQUNRLElBQU0yQixNQUFNQyxPQUFPLENBQUM1QixLQUFLQSxJQUFJLEVBQUU7Z0NBQ2hGNkIsU0FBU2pELDBDQUFROzRCQUNsQixHQUFHa0QsV0FBVyxHQUFHeEIsUUFBUSxHQUFHb0IsUUFBUTt3QkFDckMsR0FBR3BCLFFBQVEsR0FBR29CLFFBQVE7b0JBQ3ZCLEdBQUdmLEtBQUssQ0FBQ0QsS0FBSztnQkFDZjtZQUNBLENBQUNyQyx3REFBZ0JBLENBQUMrRCxFQUFFLENBQUMsRUFBRSxJQUFPO29CQUM3QmpDLFNBQVM5Qix3REFBZ0JBLENBQUMrRCxFQUFFO29CQUM1QixHQUFHeEQsMENBQVEsQ0FBQzt3QkFDWGlDLE9BQU9qQywwQ0FBUSxDQUFDQSx1Q0FBSzt3QkFDckJvQyxRQUFRcEMseUNBQU8sQ0FBQ0EsMENBQVEsQ0FBQ0EsdUNBQUssS0FBS3NDLE9BQU8sQ0FBQyxFQUFFO3dCQUM3Q0MsT0FBTzNDLHdEQUFZLENBQUNILHdEQUFnQkEsQ0FBQytELEVBQUUsQ0FBQzt3QkFDeENoQixLQUFLeEMsMENBQVEsQ0FBQzs0QkFDYnlDLFFBQVF6QywwQ0FBUTs0QkFDaEIyQyxTQUFTM0MsMENBQVEsR0FBR3NDLE9BQU8sQ0FBQzs0QkFDNUJnQixjQUFjdEQsMENBQVEsR0FBRzBCLFFBQVE7NEJBQ2pDNkIsNkJBQTZCdkQsMkNBQVMsR0FBR3NDLE9BQU8sQ0FBQzs0QkFDakRhLFNBQVNuRCwyQ0FBUyxHQUFHc0MsT0FBTyxDQUFDOzRCQUM3Qk8sT0FBTzdDLDBDQUFRLENBQUM7Z0NBQ2Y2QyxPQUFPN0MseUNBQU8sQ0FBQ0EsMENBQVEsSUFBSThDLFFBQVEsR0FBR2xDLFNBQVMsQ0FBQyxDQUFDUSxJQUFNMkIsTUFBTUMsT0FBTyxDQUFDNUIsS0FBS0EsSUFBSSxFQUFFO2dDQUNoRjZCLFNBQVNqRCwwQ0FBUTs0QkFDbEIsR0FBR2tELFdBQVcsR0FBR3hCLFFBQVEsR0FBR29CLFFBQVE7d0JBQ3JDLEdBQUdwQixRQUFRLEdBQUdvQixRQUFRO29CQUN2QixHQUFHZixLQUFLLENBQUNELEtBQUs7Z0JBQ2Y7UUFDRCxFQUFDLENBQUNQLFFBQVE7SUFDWCxFQUFFLE9BQU9rQyxPQUFPO1FBQ2YsTUFBTSxJQUFJQyxNQUFNQyxnQkFBZ0JGO0lBQ2pDO0FBQ0Q7QUFDQSxNQUFNRyxpQkFBaUIsT0FBTyxFQUFFOUIsSUFBSSxFQUFFK0IsR0FBRyxFQUFFdEMsT0FBTyxFQUFFO0lBQ25ELE1BQU11QyxTQUFTO1FBQUUsR0FBR2hDLElBQUk7SUFBQztJQUN6QixJQUFJO1FBQ0gsSUFBSWdDLE9BQU92QyxPQUFPLEtBQUs5Qix3REFBZ0JBLENBQUN1QyxFQUFFLElBQUk4QixPQUFPWCxPQUFPLElBQUlXLE9BQU92QyxPQUFPLEtBQUs5Qix3REFBZ0JBLENBQUM0RCxFQUFFLElBQUlTLE9BQU90QixHQUFHLEVBQUVXLFNBQVM7WUFDOUgsSUFBSSxDQUFDVyxPQUFPdEIsR0FBRyxFQUFFQyxRQUFRLE9BQU8vQyw4Q0FBR0EsQ0FBQ0ksdURBQVdBLENBQUM7Z0JBQy9DaUUsY0FBYztnQkFDZEMsY0FBYztnQkFDZEMsS0FBSztnQkFDTHBCLE9BQU87WUFDUjtZQUNBLE1BQU0sQ0FBQ3FCLFNBQVNDLFNBQVMsR0FBRyxNQUFNbEQsUUFBUW1ELEdBQUcsQ0FBQztnQkFBQ1AsSUFBSVEsV0FBVyxDQUFDUCxPQUFPdEIsR0FBRyxDQUFDQyxNQUFNO2dCQUFHb0IsSUFBSVMsV0FBVyxDQUFDUixPQUFPdEIsR0FBRyxDQUFDQyxNQUFNLEVBQUVsQjthQUFTO1lBQy9ILElBQUkyQyxRQUFRdkUsRUFBRSxFQUFFbUUsT0FBTzFCLE1BQU0sR0FBRzhCLFFBQVFLLEtBQUs7aUJBQ3hDLE9BQU83RSw4Q0FBR0EsQ0FBQ0ksdURBQVdBLENBQUM7Z0JBQzNCaUUsY0FBYztnQkFDZEMsY0FBYztnQkFDZEMsS0FBS0MsUUFBUU0sS0FBSyxFQUFFQTtnQkFDcEIzQixPQUFPO1lBQ1I7WUFDQSxJQUFJc0IsU0FBU3hFLEVBQUUsRUFBRW1FLE9BQU92QixLQUFLLEdBQUc0QixTQUFTSSxLQUFLO2lCQUN6QyxPQUFPN0UsOENBQUdBLENBQUNJLHVEQUFXQSxDQUFDO2dCQUMzQmlFLGNBQWM7Z0JBQ2RDLGNBQWM7Z0JBQ2RDLEtBQUtFLFNBQVNLLEtBQUssRUFBRUE7Z0JBQ3JCM0IsT0FBTztZQUNSO1FBQ0Q7UUFDQSxNQUFNNEIsVUFBVUMsT0FBT0MsSUFBSSxDQUFDYixPQUFPdkIsS0FBSyxJQUFJLENBQUM7UUFDN0MsSUFBSWtDLFFBQVFHLE1BQU0sSUFBSSxDQUFDZCxPQUFPdEIsR0FBRyxFQUFFSyxPQUFPK0IsUUFBUWQsT0FBT3RCLEdBQUcsR0FBRztZQUM5RCxHQUFHc0IsT0FBT3RCLEdBQUc7WUFDYkssT0FBTztnQkFDTkEsT0FBTzRCO2dCQUNQeEIsU0FBU3dCLFFBQVFHLE1BQU0sR0FBRztZQUMzQjtRQUNEO1FBQ0EsT0FBT2pGLDZDQUFFQSxDQUFDbUU7SUFDWCxFQUFFLE9BQU9VLE9BQU87UUFDZjdDLFFBQVE2QyxLQUFLLENBQUNBO1FBQ2QsT0FBTzlFLDhDQUFHQSxDQUFDaUUsZ0JBQWdCYTtJQUM1QjtBQUNEO0FBQ0EsTUFBTWIsa0JBQWtCLENBQUNGO0lBQ3hCLElBQUlRO0lBQ0osSUFBSVIsaUJBQWlCMUQsNENBQVFBLEVBQUVrRSxNQUFNUixNQUFNb0IsUUFBUTtJQUNuRCxPQUFPL0UsdURBQVdBLENBQUM7UUFDbEJpRSxjQUFjO1FBQ2RDLGNBQWM7UUFDZGMsVUFBVTtRQUNWakMsT0FBTztRQUNQb0I7SUFDRDtBQUNEO0FBRUEsWUFBWTtBQUNnRSxDQUM1RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9mdW5jdGlvbnMuanM/ZjBiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeGVjdXRpb25WZXJzaW9uIH0gZnJvbSBcIi4vY29uc3RzLmpzXCI7XG5pbXBvcnQgeyBlcnIsIG9rIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBzdGVwc1NjaGVtYXMgfSBmcm9tIFwiLi4vYXBpL3NjaGVtYS5qc1wiO1xuaW1wb3J0IHsgUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvZXhlY3V0aW9uL0lubmdlc3RFeGVjdXRpb24uanNcIjtcbmltcG9ydCB7IHByZXR0eUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBab2RFcnJvciwgeiB9IGZyb20gXCJ6b2QvdjNcIjtcblxuLy8jcmVnaW9uIHNyYy9oZWxwZXJzL2Z1bmN0aW9ucy50c1xuLyoqXG4qIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIGNhY2hlLiBXaGVuIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBpcyBydW4sIGl0IHdpbGxcbiogY2FjaGUgdGhlIHJlc3VsdCBhbmQgcmV0dXJuIGl0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4qL1xuY29uc3QgY2FjaGVGbiA9IChmbikgPT4ge1xuXHRjb25zdCBrZXkgPSBcInZhbHVlXCI7XG5cdGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblx0cmV0dXJuICgoLi4uYXJncykgPT4ge1xuXHRcdGlmICghY2FjaGUuaGFzKGtleSkpIGNhY2hlLnNldChrZXksIGZuKC4uLmFyZ3MpKTtcblx0XHRyZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG5cdH0pO1xufTtcbi8qKlxuKiBHaXZlbiBhbiBhcnJheSBvZiBmdW5jdGlvbnMsIHJldHVybiBhIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuIGVhY2hcbiogZnVuY3Rpb24gaW4gc2VyaWVzIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgZmluYWwgZnVuY3Rpb24uIFJlZ2FyZGxlc3Mgb2ZcbiogaWYgdGhlIGZ1bmN0aW9ucyBhcmUgc3luY2hyb25vdXMgb3IgYXN5bmNocm9ub3VzLCB0aGV5J2xsIGJlIG1hZGUgaW50byBhblxuKiBhc3luYyBwcm9taXNlIGNoYWluLlxuKlxuKiBJZiBhbiBlcnJvciBpcyB0aHJvd24sIHRoZSB3YXRlcmZhbGwgd2lsbCBzdG9wIGFuZCByZXR1cm4gdGhlIGVycm9yLlxuKlxuKiBCZWNhdXNlIHRoaXMgbmVlZHMgdG8gc3VwcG9ydCBib3RoIHN5bmMgYW5kIGFzeW5jIGZ1bmN0aW9ucywgaXQgb25seSBhbGxvd3NcbiogZnVuY3Rpb25zIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFyZ3VtZW50LlxuKi9cbmNvbnN0IHdhdGVyZmFsbCA9IChmbnMsIHRyYW5zZm9ybSkgPT4ge1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IHtcblx0XHRyZXR1cm4gZm5zLnJlZHVjZShhc3luYyAoYWNjLCBmbikgPT4ge1xuXHRcdFx0Y29uc3QgcHJldiA9IGF3YWl0IGFjYztcblx0XHRcdGNvbnN0IG91dHB1dCA9IGF3YWl0IGZuKHByZXYpO1xuXHRcdFx0aWYgKHRyYW5zZm9ybSkgcmV0dXJuIGF3YWl0IHRyYW5zZm9ybShwcmV2LCBvdXRwdXQpO1xuXHRcdFx0aWYgKHR5cGVvZiBvdXRwdXQgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBwcmV2O1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9LCBQcm9taXNlLnJlc29sdmUoYXJnc1swXSkpO1xuXHR9O1xufTtcbi8qKlxuKiBHaXZlbiBhIHZhbHVlIGB2YCwgcmV0dXJuIGB2YCBpZiBpdCdzIG5vdCB1bmRlZmluZWQsIG90aGVyd2lzZSByZXR1cm4gYG51bGxgLlxuKi9cbmNvbnN0IHVuZGVmaW5lZFRvTnVsbCA9ICh2KSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiB2O1xufTtcbmNvbnN0IGZuRGF0YVZlcnNpb25TY2hlbWEgPSB6Lm9iamVjdCh7IHZlcnNpb246IHoubGl0ZXJhbCgtMSkub3Ioei5saXRlcmFsKDApKS5vcih6LmxpdGVyYWwoMSkpLm9yKHoubGl0ZXJhbCgyKSkub3B0aW9uYWwoKS50cmFuc2Zvcm0oKHYpID0+IHtcblx0aWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0Y29uc29sZS5kZWJ1ZyhgTm8gcmVxdWVzdCB2ZXJzaW9uIHNwZWNpZmllZCBieSBleGVjdXRvcjsgZGVmYXVsdGluZyB0byB2JHtQUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT059YCk7XG5cdFx0cmV0dXJuIFBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTjtcblx0fVxuXHRyZXR1cm4gdiA9PT0gLTEgPyBQUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gOiB2O1xufSkgfSk7XG5jb25zdCBwYXJzZUZuRGF0YSA9IChkYXRhKSA9PiB7XG5cdGxldCB2ZXJzaW9uO1xuXHR0cnkge1xuXHRcdCh7dmVyc2lvbn0gPSBmbkRhdGFWZXJzaW9uU2NoZW1hLnBhcnNlKGRhdGEpKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0W0V4ZWN1dGlvblZlcnNpb24uVjBdOiAoKSA9PiAoe1xuXHRcdFx0XHR2ZXJzaW9uOiBFeGVjdXRpb25WZXJzaW9uLlYwLFxuXHRcdFx0XHQuLi56Lm9iamVjdCh7XG5cdFx0XHRcdFx0ZXZlbnQ6IHoucmVjb3JkKHouYW55KCkpLFxuXHRcdFx0XHRcdGV2ZW50czogei5hcnJheSh6LnJlY29yZCh6LmFueSgpKSkuZGVmYXVsdChbXSksXG5cdFx0XHRcdFx0c3RlcHM6IHN0ZXBzU2NoZW1hc1tFeGVjdXRpb25WZXJzaW9uLlYwXSxcblx0XHRcdFx0XHRjdHg6IHoub2JqZWN0KHtcblx0XHRcdFx0XHRcdHJ1bl9pZDogei5zdHJpbmcoKSxcblx0XHRcdFx0XHRcdGF0dGVtcHQ6IHoubnVtYmVyKCkuZGVmYXVsdCgwKSxcblx0XHRcdFx0XHRcdHN0YWNrOiB6Lm9iamVjdCh7XG5cdFx0XHRcdFx0XHRcdHN0YWNrOiB6LmFycmF5KHouc3RyaW5nKCkpLm51bGxhYmxlKCkudHJhbnNmb3JtKCh2KSA9PiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFtdKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudDogei5udW1iZXIoKVxuXHRcdFx0XHRcdFx0fSkucGFzc3Rocm91Z2goKS5vcHRpb25hbCgpLm51bGxhYmxlKClcblx0XHRcdFx0XHR9KS5vcHRpb25hbCgpLm51bGxhYmxlKCksXG5cdFx0XHRcdFx0dXNlX2FwaTogei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSlcblx0XHRcdFx0fSkucGFyc2UoZGF0YSlcblx0XHRcdH0pLFxuXHRcdFx0W0V4ZWN1dGlvblZlcnNpb24uVjFdOiAoKSA9PiAoe1xuXHRcdFx0XHR2ZXJzaW9uOiBFeGVjdXRpb25WZXJzaW9uLlYxLFxuXHRcdFx0XHQuLi56Lm9iamVjdCh7XG5cdFx0XHRcdFx0ZXZlbnQ6IHoucmVjb3JkKHouYW55KCkpLFxuXHRcdFx0XHRcdGV2ZW50czogei5hcnJheSh6LnJlY29yZCh6LmFueSgpKSkuZGVmYXVsdChbXSksXG5cdFx0XHRcdFx0c3RlcHM6IHN0ZXBzU2NoZW1hc1tFeGVjdXRpb25WZXJzaW9uLlYxXSxcblx0XHRcdFx0XHRjdHg6IHoub2JqZWN0KHtcblx0XHRcdFx0XHRcdHJ1bl9pZDogei5zdHJpbmcoKSxcblx0XHRcdFx0XHRcdGF0dGVtcHQ6IHoubnVtYmVyKCkuZGVmYXVsdCgwKSxcblx0XHRcdFx0XHRcdG1heF9hdHRlbXB0czogei5udW1iZXIoKS5vcHRpb25hbCgpLFxuXHRcdFx0XHRcdFx0ZGlzYWJsZV9pbW1lZGlhdGVfZXhlY3V0aW9uOiB6LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcblx0XHRcdFx0XHRcdHVzZV9hcGk6IHouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuXHRcdFx0XHRcdFx0c3RhY2s6IHoub2JqZWN0KHtcblx0XHRcdFx0XHRcdFx0c3RhY2s6IHouYXJyYXkoei5zdHJpbmcoKSkubnVsbGFibGUoKS50cmFuc2Zvcm0oKHYpID0+IEFycmF5LmlzQXJyYXkodikgPyB2IDogW10pLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50OiB6Lm51bWJlcigpXG5cdFx0XHRcdFx0XHR9KS5wYXNzdGhyb3VnaCgpLm9wdGlvbmFsKCkubnVsbGFibGUoKVxuXHRcdFx0XHRcdH0pLm9wdGlvbmFsKCkubnVsbGFibGUoKVxuXHRcdFx0XHR9KS5wYXJzZShkYXRhKVxuXHRcdFx0fSksXG5cdFx0XHRbRXhlY3V0aW9uVmVyc2lvbi5WMl06ICgpID0+ICh7XG5cdFx0XHRcdHZlcnNpb246IEV4ZWN1dGlvblZlcnNpb24uVjIsXG5cdFx0XHRcdC4uLnoub2JqZWN0KHtcblx0XHRcdFx0XHRldmVudDogei5yZWNvcmQoei5hbnkoKSksXG5cdFx0XHRcdFx0ZXZlbnRzOiB6LmFycmF5KHoucmVjb3JkKHouYW55KCkpKS5kZWZhdWx0KFtdKSxcblx0XHRcdFx0XHRzdGVwczogc3RlcHNTY2hlbWFzW0V4ZWN1dGlvblZlcnNpb24uVjJdLFxuXHRcdFx0XHRcdGN0eDogei5vYmplY3Qoe1xuXHRcdFx0XHRcdFx0cnVuX2lkOiB6LnN0cmluZygpLFxuXHRcdFx0XHRcdFx0YXR0ZW1wdDogei5udW1iZXIoKS5kZWZhdWx0KDApLFxuXHRcdFx0XHRcdFx0bWF4X2F0dGVtcHRzOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG5cdFx0XHRcdFx0XHRkaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb246IHouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuXHRcdFx0XHRcdFx0dXNlX2FwaTogei5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG5cdFx0XHRcdFx0XHRzdGFjazogei5vYmplY3Qoe1xuXHRcdFx0XHRcdFx0XHRzdGFjazogei5hcnJheSh6LnN0cmluZygpKS5udWxsYWJsZSgpLnRyYW5zZm9ybSgodikgPT4gQXJyYXkuaXNBcnJheSh2KSA/IHYgOiBbXSksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQ6IHoubnVtYmVyKClcblx0XHRcdFx0XHRcdH0pLnBhc3N0aHJvdWdoKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpXG5cdFx0XHRcdFx0fSkub3B0aW9uYWwoKS5udWxsYWJsZSgpXG5cdFx0XHRcdH0pLnBhcnNlKGRhdGEpXG5cdFx0XHR9KVxuXHRcdH1bdmVyc2lvbl0oKTtcblx0fSBjYXRjaCAoZXJyJDEpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IocGFyc2VGYWlsdXJlRXJyKGVyciQxKSk7XG5cdH1cbn07XG5jb25zdCBmZXRjaEFsbEZuRGF0YSA9IGFzeW5jICh7IGRhdGEsIGFwaSwgdmVyc2lvbiB9KSA9PiB7XG5cdGNvbnN0IHJlc3VsdCA9IHsgLi4uZGF0YSB9O1xuXHR0cnkge1xuXHRcdGlmIChyZXN1bHQudmVyc2lvbiA9PT0gRXhlY3V0aW9uVmVyc2lvbi5WMCAmJiByZXN1bHQudXNlX2FwaSB8fCByZXN1bHQudmVyc2lvbiA9PT0gRXhlY3V0aW9uVmVyc2lvbi5WMSAmJiByZXN1bHQuY3R4Py51c2VfYXBpKSB7XG5cdFx0XHRpZiAoIXJlc3VsdC5jdHg/LnJ1bl9pZCkgcmV0dXJuIGVycihwcmV0dHlFcnJvcih7XG5cdFx0XHRcdHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gYXR0ZW1wdCByZXRyaWV2aW5nIGRhdGEgZnJvbSBBUElcIixcblx0XHRcdFx0Y29uc2VxdWVuY2VzOiBcImZ1bmN0aW9uIGV4ZWN1dGlvbiBjYW4ndCBjb250aW51ZVwiLFxuXHRcdFx0XHR3aHk6IFwicnVuX2lkIGlzIG1pc3NpbmcgZnJvbSBjb250ZXh0XCIsXG5cdFx0XHRcdHN0YWNrOiB0cnVlXG5cdFx0XHR9KSk7XG5cdFx0XHRjb25zdCBbZXZ0UmVzcCwgc3RlcFJlc3BdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2FwaS5nZXRSdW5CYXRjaChyZXN1bHQuY3R4LnJ1bl9pZCksIGFwaS5nZXRSdW5TdGVwcyhyZXN1bHQuY3R4LnJ1bl9pZCwgdmVyc2lvbildKTtcblx0XHRcdGlmIChldnRSZXNwLm9rKSByZXN1bHQuZXZlbnRzID0gZXZ0UmVzcC52YWx1ZTtcblx0XHRcdGVsc2UgcmV0dXJuIGVycihwcmV0dHlFcnJvcih7XG5cdFx0XHRcdHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gcmV0cmlldmUgbGlzdCBvZiBldmVudHNcIixcblx0XHRcdFx0Y29uc2VxdWVuY2VzOiBcImZ1bmN0aW9uIGV4ZWN1dGlvbiBjYW4ndCBjb250aW51ZVwiLFxuXHRcdFx0XHR3aHk6IGV2dFJlc3AuZXJyb3I/LmVycm9yLFxuXHRcdFx0XHRzdGFjazogdHJ1ZVxuXHRcdFx0fSkpO1xuXHRcdFx0aWYgKHN0ZXBSZXNwLm9rKSByZXN1bHQuc3RlcHMgPSBzdGVwUmVzcC52YWx1ZTtcblx0XHRcdGVsc2UgcmV0dXJuIGVycihwcmV0dHlFcnJvcih7XG5cdFx0XHRcdHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gcmV0cmlldmUgc3RlcHMgZm9yIGZ1bmN0aW9uIHJ1blwiLFxuXHRcdFx0XHRjb25zZXF1ZW5jZXM6IFwiZnVuY3Rpb24gZXhlY3V0aW9uIGNhbid0IGNvbnRpbnVlXCIsXG5cdFx0XHRcdHdoeTogc3RlcFJlc3AuZXJyb3I/LmVycm9yLFxuXHRcdFx0XHRzdGFjazogdHJ1ZVxuXHRcdFx0fSkpO1xuXHRcdH1cblx0XHRjb25zdCBzdGVwSWRzID0gT2JqZWN0LmtleXMocmVzdWx0LnN0ZXBzIHx8IHt9KTtcblx0XHRpZiAoc3RlcElkcy5sZW5ndGggJiYgIXJlc3VsdC5jdHg/LnN0YWNrPy5sZW5ndGgpIHJlc3VsdC5jdHggPSB7XG5cdFx0XHQuLi5yZXN1bHQuY3R4LFxuXHRcdFx0c3RhY2s6IHtcblx0XHRcdFx0c3RhY2s6IHN0ZXBJZHMsXG5cdFx0XHRcdGN1cnJlbnQ6IHN0ZXBJZHMubGVuZ3RoIC0gMVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIG9rKHJlc3VsdCk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdFx0cmV0dXJuIGVycihwYXJzZUZhaWx1cmVFcnIoZXJyb3IpKTtcblx0fVxufTtcbmNvbnN0IHBhcnNlRmFpbHVyZUVyciA9IChlcnIkMSkgPT4ge1xuXHRsZXQgd2h5O1xuXHRpZiAoZXJyJDEgaW5zdGFuY2VvZiBab2RFcnJvcikgd2h5ID0gZXJyJDEudG9TdHJpbmcoKTtcblx0cmV0dXJuIHByZXR0eUVycm9yKHtcblx0XHR3aGF0SGFwcGVuZWQ6IFwiRmFpbGVkIHRvIHBhcnNlIGRhdGEgZnJvbSBleGVjdXRvci5cIixcblx0XHRjb25zZXF1ZW5jZXM6IFwiRnVuY3Rpb24gZXhlY3V0aW9uIGNhbid0IGNvbnRpbnVlLlwiLFxuXHRcdHRvRml4Tm93OiBcIk1ha2Ugc3VyZSB0aGF0IHlvdXIgQVBJIGlzIHNldCB1cCB0byBwYXJzZSBpbmNvbWluZyByZXF1ZXN0IGJvZGllcyBhcyBKU09OLCBsaWtlIGJvZHktcGFyc2VyIGZvciBFeHByZXNzIChodHRwczovL2V4cHJlc3Nqcy5jb20vZW4vcmVzb3VyY2VzL21pZGRsZXdhcmUvYm9keS1wYXJzZXIuaHRtbCkuXCIsXG5cdFx0c3RhY2s6IHRydWUsXG5cdFx0d2h5XG5cdH0pO1xufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBjYWNoZUZuLCBmZXRjaEFsbEZuRGF0YSwgcGFyc2VGbkRhdGEsIHVuZGVmaW5lZFRvTnVsbCwgd2F0ZXJmYWxsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbIkV4ZWN1dGlvblZlcnNpb24iLCJlcnIiLCJvayIsInN0ZXBzU2NoZW1hcyIsIlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTiIsInByZXR0eUVycm9yIiwiWm9kRXJyb3IiLCJ6IiwiY2FjaGVGbiIsImZuIiwia2V5IiwiY2FjaGUiLCJNYXAiLCJhcmdzIiwiaGFzIiwic2V0IiwiZ2V0Iiwid2F0ZXJmYWxsIiwiZm5zIiwidHJhbnNmb3JtIiwicmVkdWNlIiwiYWNjIiwicHJldiIsIm91dHB1dCIsIlByb21pc2UiLCJyZXNvbHZlIiwidW5kZWZpbmVkVG9OdWxsIiwidiIsImZuRGF0YVZlcnNpb25TY2hlbWEiLCJvYmplY3QiLCJ2ZXJzaW9uIiwibGl0ZXJhbCIsIm9yIiwib3B0aW9uYWwiLCJjb25zb2xlIiwiZGVidWciLCJwYXJzZUZuRGF0YSIsImRhdGEiLCJwYXJzZSIsIlYwIiwiZXZlbnQiLCJyZWNvcmQiLCJhbnkiLCJldmVudHMiLCJhcnJheSIsImRlZmF1bHQiLCJzdGVwcyIsImN0eCIsInJ1bl9pZCIsInN0cmluZyIsImF0dGVtcHQiLCJudW1iZXIiLCJzdGFjayIsIm51bGxhYmxlIiwiQXJyYXkiLCJpc0FycmF5IiwiY3VycmVudCIsInBhc3N0aHJvdWdoIiwidXNlX2FwaSIsImJvb2xlYW4iLCJWMSIsIm1heF9hdHRlbXB0cyIsImRpc2FibGVfaW1tZWRpYXRlX2V4ZWN1dGlvbiIsIlYyIiwiZXJyJDEiLCJFcnJvciIsInBhcnNlRmFpbHVyZUVyciIsImZldGNoQWxsRm5EYXRhIiwiYXBpIiwicmVzdWx0Iiwid2hhdEhhcHBlbmVkIiwiY29uc2VxdWVuY2VzIiwid2h5IiwiZXZ0UmVzcCIsInN0ZXBSZXNwIiwiYWxsIiwiZ2V0UnVuQmF0Y2giLCJnZXRSdW5TdGVwcyIsInZhbHVlIiwiZXJyb3IiLCJzdGVwSWRzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInRvU3RyaW5nIiwidG9GaXhOb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/functions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/net.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/net.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchWithAuthFallback: () => (/* binding */ fetchWithAuthFallback),\n/* harmony export */   signDataWithKey: () => (/* binding */ signDataWithKey)\n/* harmony export */ });\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var canonicalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\");\n\n\n//#region src/helpers/net.ts\nconst { hmac, sha256 } = hash_js__WEBPACK_IMPORTED_MODULE_0__;\n/**\n* Send an HTTP request with the given signing key. If the response is a 401 or\n* 403, then try again with the fallback signing key\n*/ async function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url }) {\n    let res = await fetch(url, {\n        ...options,\n        headers: {\n            ...options?.headers,\n            Authorization: `Bearer ${authToken}`\n        }\n    });\n    if ([\n        401,\n        403\n    ].includes(res.status) && authTokenFallback) res = await fetch(url, {\n        ...options,\n        headers: {\n            ...options?.headers,\n            Authorization: `Bearer ${authTokenFallback}`\n        }\n    });\n    return res;\n}\nfunction signDataWithKey(data, signingKey, ts) {\n    const encoded = typeof data === \"string\" ? data : canonicalize__WEBPACK_IMPORTED_MODULE_1__(data);\n    return hmac(sha256, signingKey.replace(/signkey-\\w+-/, \"\")).update(encoded).update(ts).digest(\"hex\");\n}\n//#endregion\n //# sourceMappingURL=net.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL25ldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZCO0FBQ1c7QUFFeEMsNEJBQTRCO0FBQzVCLE1BQU0sRUFBRUUsSUFBSSxFQUFFQyxNQUFNLEVBQUUsR0FBR0gsb0NBQU1BO0FBQy9COzs7QUFHQSxHQUNBLGVBQWVJLHNCQUFzQixFQUFFQyxTQUFTLEVBQUVDLGlCQUFpQixFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsR0FBRyxFQUFFO0lBQ3pGLElBQUlDLE1BQU0sTUFBTUgsTUFBTUUsS0FBSztRQUMxQixHQUFHRCxPQUFPO1FBQ1ZHLFNBQVM7WUFDUixHQUFHSCxTQUFTRyxPQUFPO1lBQ25CQyxlQUFlLENBQUMsT0FBTyxFQUFFUCxVQUFVLENBQUM7UUFDckM7SUFDRDtJQUNBLElBQUk7UUFBQztRQUFLO0tBQUksQ0FBQ1EsUUFBUSxDQUFDSCxJQUFJSSxNQUFNLEtBQUtSLG1CQUFtQkksTUFBTSxNQUFNSCxNQUFNRSxLQUFLO1FBQ2hGLEdBQUdELE9BQU87UUFDVkcsU0FBUztZQUNSLEdBQUdILFNBQVNHLE9BQU87WUFDbkJDLGVBQWUsQ0FBQyxPQUFPLEVBQUVOLGtCQUFrQixDQUFDO1FBQzdDO0lBQ0Q7SUFDQSxPQUFPSTtBQUNSO0FBQ0EsU0FBU0ssZ0JBQWdCQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsRUFBRTtJQUM1QyxNQUFNQyxVQUFVLE9BQU9ILFNBQVMsV0FBV0EsT0FBT2YseUNBQVlBLENBQUNlO0lBQy9ELE9BQU9kLEtBQUtDLFFBQVFjLFdBQVdHLE9BQU8sQ0FBQyxnQkFBZ0IsS0FBS0MsTUFBTSxDQUFDRixTQUFTRSxNQUFNLENBQUNILElBQUlJLE1BQU0sQ0FBQztBQUMvRjtBQUVBLFlBQVk7QUFDc0MsQ0FDbEQsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvbmV0LmpzPzg4NDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGhhc2hqcyBmcm9tIFwiaGFzaC5qc1wiO1xuaW1wb3J0IGNhbm9uaWNhbGl6ZSBmcm9tIFwiY2Fub25pY2FsaXplXCI7XG5cbi8vI3JlZ2lvbiBzcmMvaGVscGVycy9uZXQudHNcbmNvbnN0IHsgaG1hYywgc2hhMjU2IH0gPSBoYXNoanM7XG4vKipcbiogU2VuZCBhbiBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gc2lnbmluZyBrZXkuIElmIHRoZSByZXNwb25zZSBpcyBhIDQwMSBvclxuKiA0MDMsIHRoZW4gdHJ5IGFnYWluIHdpdGggdGhlIGZhbGxiYWNrIHNpZ25pbmcga2V5XG4qL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKHsgYXV0aFRva2VuLCBhdXRoVG9rZW5GYWxsYmFjaywgZmV0Y2gsIG9wdGlvbnMsIHVybCB9KSB7XG5cdGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIHtcblx0XHQuLi5vcHRpb25zLFxuXHRcdGhlYWRlcnM6IHtcblx0XHRcdC4uLm9wdGlvbnM/LmhlYWRlcnMsXG5cdFx0XHRBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aFRva2VufWBcblx0XHR9XG5cdH0pO1xuXHRpZiAoWzQwMSwgNDAzXS5pbmNsdWRlcyhyZXMuc3RhdHVzKSAmJiBhdXRoVG9rZW5GYWxsYmFjaykgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XG5cdFx0Li4ub3B0aW9ucyxcblx0XHRoZWFkZXJzOiB7XG5cdFx0XHQuLi5vcHRpb25zPy5oZWFkZXJzLFxuXHRcdFx0QXV0aG9yaXphdGlvbjogYEJlYXJlciAke2F1dGhUb2tlbkZhbGxiYWNrfWBcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc2lnbkRhdGFXaXRoS2V5KGRhdGEsIHNpZ25pbmdLZXksIHRzKSB7XG5cdGNvbnN0IGVuY29kZWQgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBjYW5vbmljYWxpemUoZGF0YSk7XG5cdHJldHVybiBobWFjKHNoYTI1Niwgc2lnbmluZ0tleS5yZXBsYWNlKC9zaWdua2V5LVxcdystLywgXCJcIikpLnVwZGF0ZShlbmNvZGVkKS51cGRhdGUodHMpLmRpZ2VzdChcImhleFwiKTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBmZXRjaFdpdGhBdXRoRmFsbGJhY2ssIHNpZ25EYXRhV2l0aEtleSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0LmpzLm1hcCJdLCJuYW1lcyI6WyJoYXNoanMiLCJjYW5vbmljYWxpemUiLCJobWFjIiwic2hhMjU2IiwiZmV0Y2hXaXRoQXV0aEZhbGxiYWNrIiwiYXV0aFRva2VuIiwiYXV0aFRva2VuRmFsbGJhY2siLCJmZXRjaCIsIm9wdGlvbnMiLCJ1cmwiLCJyZXMiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImluY2x1ZGVzIiwic3RhdHVzIiwic2lnbkRhdGFXaXRoS2V5IiwiZGF0YSIsInNpZ25pbmdLZXkiLCJ0cyIsImVuY29kZWQiLCJyZXBsYWNlIiwidXBkYXRlIiwiZGlnZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/net.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/promises.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/promises.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeferredPromise: () => (/* binding */ createDeferredPromise),\n/* harmony export */   createDeferredPromiseWithStack: () => (/* binding */ createDeferredPromiseWithStack),\n/* harmony export */   createTimeoutPromise: () => (/* binding */ createTimeoutPromise),\n/* harmony export */   resolveAfterPending: () => (/* binding */ resolveAfterPending),\n/* harmony export */   resolveNextTick: () => (/* binding */ resolveNextTick),\n/* harmony export */   retryWithBackoff: () => (/* binding */ retryWithBackoff),\n/* harmony export */   runAsPromise: () => (/* binding */ runAsPromise)\n/* harmony export */ });\n//#region src/helpers/promises.ts\n/**\n* Some environments don't allow access to the global queueMicrotask(). While we\n* had assumed this was only true for those powered by earlier versions of Node\n* (<14) that we don't officially support, Vercel's Edge Functions also obscure\n* the function in dev, even though the platform it's based on (Cloudflare\n* Workers) appropriately exposes it. Even worse, production Vercel Edge\n* Functions can see the function, but it immediately blows up the function when\n* used.\n*\n* Therefore, we can fall back to a reasonable alternative of\n* `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern\n* environments, but at least we can still work in these environments.\n*/ const shimQueueMicrotask = (callback)=>{\n    Promise.resolve().then(callback);\n};\n/**\n* Returns a Promise that resolves after the current event loop's microtasks\n* have finished, but before the next event loop tick.\n*/ const resolveAfterPending = (count = 100)=>{\n    /**\n\t* This uses a brute force implementation that will continue to enqueue\n\t* microtasks 10 times before resolving. This is to ensure that the microtask\n\t* queue is drained, even if the microtask queue is being manipulated by other\n\t* code.\n\t*\n\t* While this still doesn't guarantee that the microtask queue is drained,\n\t* it's our best bet for giving other non-controlled promises a chance to\n\t* resolve before we continue without resorting to falling in to the next\n\t* tick.\n\t*/ return new Promise((resolve)=>{\n        let i = 0;\n        const iterate = ()=>{\n            shimQueueMicrotask(()=>{\n                if (i++ > count) return resolve();\n                iterate();\n            });\n        };\n        iterate();\n    });\n};\n/**\n* Creates and returns Promise that can be resolved or rejected with the\n* returned `resolve` and `reject` functions.\n*\n* Resolving or rejecting the function will return a new set of Promise control\n* functions. These can be ignored if the original Promise is all that's needed.\n*/ const createDeferredPromise = ()=>{\n    let resolve;\n    let reject;\n    return {\n        promise: new Promise((_resolve, _reject)=>{\n            resolve = (value)=>{\n                _resolve(value);\n                return createDeferredPromise();\n            };\n            reject = (reason)=>{\n                _reject(reason);\n                return createDeferredPromise();\n            };\n        }),\n        resolve,\n        reject\n    };\n};\n/**\n* Creates and returns a deferred Promise that can be resolved or rejected with\n* the returned `resolve` and `reject` functions.\n*\n* For each Promise resolved or rejected this way, this will also keep a stack\n* of all unhandled Promises, resolved or rejected.\n*\n* Once a Promise is read, it is removed from the stack.\n*/ const createDeferredPromiseWithStack = ()=>{\n    const settledPromises = [];\n    let rotateQueue = ()=>{};\n    const results = async function*() {\n        while(true){\n            const next = settledPromises.shift();\n            if (next) yield next;\n            else await new Promise((resolve)=>{\n                rotateQueue = resolve;\n            });\n        }\n    }();\n    const shimDeferredPromise = (deferred)=>{\n        const originalResolve = deferred.resolve;\n        const originalReject = deferred.reject;\n        deferred.resolve = (value)=>{\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalResolve(value));\n        };\n        deferred.reject = (reason)=>{\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalReject(reason));\n        };\n        return deferred;\n    };\n    return {\n        deferred: shimDeferredPromise(createDeferredPromise()),\n        results\n    };\n};\n/**\n* Creates a Promise that will resolve after the given duration, along with\n* methods to start, clear, and reset the timeout.\n*/ const createTimeoutPromise = (duration)=>{\n    const { promise, resolve } = createDeferredPromise();\n    let timeout;\n    let ret;\n    const start = ()=>{\n        if (timeout) return ret;\n        timeout = setTimeout(()=>{\n            resolve();\n        }, duration);\n        return ret;\n    };\n    const clear = ()=>{\n        clearTimeout(timeout);\n        timeout = void 0;\n    };\n    const reset = ()=>{\n        clear();\n        return start();\n    };\n    ret = Object.assign(promise, {\n        start,\n        clear,\n        reset\n    });\n    return ret;\n};\n/**\n* Take any function and safely promisify such that both synchronous and\n* asynchronous errors are caught and returned as a rejected Promise.\n*\n* The passed `fn` can be undefined to support functions that may conditionally\n* be defined.\n*/ const runAsPromise = (fn)=>{\n    return Promise.resolve().then(fn);\n};\n/**\n* Returns a Promise that resolve after the current event loop tick.\n*/ const resolveNextTick = ()=>{\n    return new Promise((resolve)=>setTimeout(resolve));\n};\nconst retryWithBackoff = async (fn, opts)=>{\n    const maxAttempts = opts?.maxAttempts || 5;\n    const baseDelay = opts?.baseDelay ?? 100;\n    for(let attempt = 1; attempt <= maxAttempts; attempt++)try {\n        return await fn();\n    } catch (err) {\n        if (attempt >= maxAttempts) throw err;\n        const jitter = Math.random() * baseDelay;\n        const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;\n        await new Promise((resolve)=>setTimeout(resolve, delay));\n    }\n    throw new Error(\"Max retries reached; this should be unreachable.\");\n};\n//#endregion\n //# sourceMappingURL=promises.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3Byb21pc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBaUM7QUFDakM7Ozs7Ozs7Ozs7OztBQVlBLEdBQ0EsTUFBTUEscUJBQXFCLENBQUNDO0lBQzNCQyxRQUFRQyxPQUFPLEdBQUdDLElBQUksQ0FBQ0g7QUFDeEI7QUFDQTs7O0FBR0EsR0FDQSxNQUFNSSxzQkFBc0IsQ0FBQ0MsUUFBUSxHQUFHO0lBQ3ZDOzs7Ozs7Ozs7O0NBVUEsR0FDQSxPQUFPLElBQUlKLFFBQVEsQ0FBQ0M7UUFDbkIsSUFBSUksSUFBSTtRQUNSLE1BQU1DLFVBQVU7WUFDZlIsbUJBQW1CO2dCQUNsQixJQUFJTyxNQUFNRCxPQUFPLE9BQU9IO2dCQUN4Qks7WUFDRDtRQUNEO1FBQ0FBO0lBQ0Q7QUFDRDtBQUNBOzs7Ozs7QUFNQSxHQUNBLE1BQU1DLHdCQUF3QjtJQUM3QixJQUFJTjtJQUNKLElBQUlPO0lBQ0osT0FBTztRQUNOQyxTQUFTLElBQUlULFFBQVEsQ0FBQ1UsVUFBVUM7WUFDL0JWLFVBQVUsQ0FBQ1c7Z0JBQ1ZGLFNBQVNFO2dCQUNULE9BQU9MO1lBQ1I7WUFDQUMsU0FBUyxDQUFDSztnQkFDVEYsUUFBUUU7Z0JBQ1IsT0FBT047WUFDUjtRQUNEO1FBQ0FOO1FBQ0FPO0lBQ0Q7QUFDRDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTU0saUNBQWlDO0lBQ3RDLE1BQU1DLGtCQUFrQixFQUFFO0lBQzFCLElBQUlDLGNBQWMsS0FBTztJQUN6QixNQUFNQyxVQUFVO1FBQ2YsTUFBTyxLQUFNO1lBQ1osTUFBTUMsT0FBT0gsZ0JBQWdCSSxLQUFLO1lBQ2xDLElBQUlELE1BQU0sTUFBTUE7aUJBQ1gsTUFBTSxJQUFJbEIsUUFBUSxDQUFDQztnQkFDdkJlLGNBQWNmO1lBQ2Y7UUFDRDtJQUNEO0lBQ0EsTUFBTW1CLHNCQUFzQixDQUFDQztRQUM1QixNQUFNQyxrQkFBa0JELFNBQVNwQixPQUFPO1FBQ3hDLE1BQU1zQixpQkFBaUJGLFNBQVNiLE1BQU07UUFDdENhLFNBQVNwQixPQUFPLEdBQUcsQ0FBQ1c7WUFDbkJHLGdCQUFnQlMsSUFBSSxDQUFDSCxTQUFTWixPQUFPO1lBQ3JDTztZQUNBLE9BQU9JLG9CQUFvQkUsZ0JBQWdCVjtRQUM1QztRQUNBUyxTQUFTYixNQUFNLEdBQUcsQ0FBQ0s7WUFDbEJFLGdCQUFnQlMsSUFBSSxDQUFDSCxTQUFTWixPQUFPO1lBQ3JDTztZQUNBLE9BQU9JLG9CQUFvQkcsZUFBZVY7UUFDM0M7UUFDQSxPQUFPUTtJQUNSO0lBQ0EsT0FBTztRQUNOQSxVQUFVRCxvQkFBb0JiO1FBQzlCVTtJQUNEO0FBQ0Q7QUFDQTs7O0FBR0EsR0FDQSxNQUFNUSx1QkFBdUIsQ0FBQ0M7SUFDN0IsTUFBTSxFQUFFakIsT0FBTyxFQUFFUixPQUFPLEVBQUUsR0FBR007SUFDN0IsSUFBSW9CO0lBQ0osSUFBSUM7SUFDSixNQUFNQyxRQUFRO1FBQ2IsSUFBSUYsU0FBUyxPQUFPQztRQUNwQkQsVUFBVUcsV0FBVztZQUNwQjdCO1FBQ0QsR0FBR3lCO1FBQ0gsT0FBT0U7SUFDUjtJQUNBLE1BQU1HLFFBQVE7UUFDYkMsYUFBYUw7UUFDYkEsVUFBVSxLQUFLO0lBQ2hCO0lBQ0EsTUFBTU0sUUFBUTtRQUNiRjtRQUNBLE9BQU9GO0lBQ1I7SUFDQUQsTUFBTU0sT0FBT0MsTUFBTSxDQUFDMUIsU0FBUztRQUM1Qm9CO1FBQ0FFO1FBQ0FFO0lBQ0Q7SUFDQSxPQUFPTDtBQUNSO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTVEsZUFBZSxDQUFDQztJQUNyQixPQUFPckMsUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUNtQztBQUMvQjtBQUNBOztBQUVBLEdBQ0EsTUFBTUMsa0JBQWtCO0lBQ3ZCLE9BQU8sSUFBSXRDLFFBQVEsQ0FBQ0MsVUFBWTZCLFdBQVc3QjtBQUM1QztBQUNBLE1BQU1zQyxtQkFBbUIsT0FBT0YsSUFBSUc7SUFDbkMsTUFBTUMsY0FBY0QsTUFBTUMsZUFBZTtJQUN6QyxNQUFNQyxZQUFZRixNQUFNRSxhQUFhO0lBQ3JDLElBQUssSUFBSUMsVUFBVSxHQUFHQSxXQUFXRixhQUFhRSxVQUFXLElBQUk7UUFDNUQsT0FBTyxNQUFNTjtJQUNkLEVBQUUsT0FBT08sS0FBSztRQUNiLElBQUlELFdBQVdGLGFBQWEsTUFBTUc7UUFDbEMsTUFBTUMsU0FBU0MsS0FBS0MsTUFBTSxLQUFLTDtRQUMvQixNQUFNTSxRQUFRTixZQUFZSSxLQUFLRyxHQUFHLENBQUMsR0FBR04sVUFBVSxLQUFLRTtRQUNyRCxNQUFNLElBQUk3QyxRQUFRLENBQUNDLFVBQVk2QixXQUFXN0IsU0FBUytDO0lBQ3BEO0lBQ0EsTUFBTSxJQUFJRSxNQUFNO0FBQ2pCO0FBRUEsWUFBWTtBQUNpSixDQUM3SixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9wcm9taXNlcy5qcz8yY2U0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvaGVscGVycy9wcm9taXNlcy50c1xuLyoqXG4qIFNvbWUgZW52aXJvbm1lbnRzIGRvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZ2xvYmFsIHF1ZXVlTWljcm90YXNrKCkuIFdoaWxlIHdlXG4qIGhhZCBhc3N1bWVkIHRoaXMgd2FzIG9ubHkgdHJ1ZSBmb3IgdGhvc2UgcG93ZXJlZCBieSBlYXJsaWVyIHZlcnNpb25zIG9mIE5vZGVcbiogKDwxNCkgdGhhdCB3ZSBkb24ndCBvZmZpY2lhbGx5IHN1cHBvcnQsIFZlcmNlbCdzIEVkZ2UgRnVuY3Rpb25zIGFsc28gb2JzY3VyZVxuKiB0aGUgZnVuY3Rpb24gaW4gZGV2LCBldmVuIHRob3VnaCB0aGUgcGxhdGZvcm0gaXQncyBiYXNlZCBvbiAoQ2xvdWRmbGFyZVxuKiBXb3JrZXJzKSBhcHByb3ByaWF0ZWx5IGV4cG9zZXMgaXQuIEV2ZW4gd29yc2UsIHByb2R1Y3Rpb24gVmVyY2VsIEVkZ2VcbiogRnVuY3Rpb25zIGNhbiBzZWUgdGhlIGZ1bmN0aW9uLCBidXQgaXQgaW1tZWRpYXRlbHkgYmxvd3MgdXAgdGhlIGZ1bmN0aW9uIHdoZW5cbiogdXNlZC5cbipcbiogVGhlcmVmb3JlLCB3ZSBjYW4gZmFsbCBiYWNrIHRvIGEgcmVhc29uYWJsZSBhbHRlcm5hdGl2ZSBvZlxuKiBgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbilgIGluc3RlYWQuIFRoaXMgX21heV8gYmUgc2xpZ2h0bHkgc2xvd2VyIGluIG1vZGVyblxuKiBlbnZpcm9ubWVudHMsIGJ1dCBhdCBsZWFzdCB3ZSBjYW4gc3RpbGwgd29yayBpbiB0aGVzZSBlbnZpcm9ubWVudHMuXG4qL1xuY29uc3Qgc2hpbVF1ZXVlTWljcm90YXNrID0gKGNhbGxiYWNrKSA9PiB7XG5cdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oY2FsbGJhY2spO1xufTtcbi8qKlxuKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AncyBtaWNyb3Rhc2tzXG4qIGhhdmUgZmluaXNoZWQsIGJ1dCBiZWZvcmUgdGhlIG5leHQgZXZlbnQgbG9vcCB0aWNrLlxuKi9cbmNvbnN0IHJlc29sdmVBZnRlclBlbmRpbmcgPSAoY291bnQgPSAxMDApID0+IHtcblx0LyoqXG5cdCogVGhpcyB1c2VzIGEgYnJ1dGUgZm9yY2UgaW1wbGVtZW50YXRpb24gdGhhdCB3aWxsIGNvbnRpbnVlIHRvIGVucXVldWVcblx0KiBtaWNyb3Rhc2tzIDEwIHRpbWVzIGJlZm9yZSByZXNvbHZpbmcuIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIG1pY3JvdGFza1xuXHQqIHF1ZXVlIGlzIGRyYWluZWQsIGV2ZW4gaWYgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBiZWluZyBtYW5pcHVsYXRlZCBieSBvdGhlclxuXHQqIGNvZGUuXG5cdCpcblx0KiBXaGlsZSB0aGlzIHN0aWxsIGRvZXNuJ3QgZ3VhcmFudGVlIHRoYXQgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBkcmFpbmVkLFxuXHQqIGl0J3Mgb3VyIGJlc3QgYmV0IGZvciBnaXZpbmcgb3RoZXIgbm9uLWNvbnRyb2xsZWQgcHJvbWlzZXMgYSBjaGFuY2UgdG9cblx0KiByZXNvbHZlIGJlZm9yZSB3ZSBjb250aW51ZSB3aXRob3V0IHJlc29ydGluZyB0byBmYWxsaW5nIGluIHRvIHRoZSBuZXh0XG5cdCogdGljay5cblx0Ki9cblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGl0ZXJhdGUgPSAoKSA9PiB7XG5cdFx0XHRzaGltUXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRpZiAoaSsrID4gY291bnQpIHJldHVybiByZXNvbHZlKCk7XG5cdFx0XHRcdGl0ZXJhdGUoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0aXRlcmF0ZSgpO1xuXHR9KTtcbn07XG4vKipcbiogQ3JlYXRlcyBhbmQgcmV0dXJucyBQcm9taXNlIHRoYXQgY2FuIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIHdpdGggdGhlXG4qIHJldHVybmVkIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zLlxuKlxuKiBSZXNvbHZpbmcgb3IgcmVqZWN0aW5nIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIG5ldyBzZXQgb2YgUHJvbWlzZSBjb250cm9sXG4qIGZ1bmN0aW9ucy4gVGhlc2UgY2FuIGJlIGlnbm9yZWQgaWYgdGhlIG9yaWdpbmFsIFByb21pc2UgaXMgYWxsIHRoYXQncyBuZWVkZWQuXG4qL1xuY29uc3QgY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gKCkgPT4ge1xuXHRsZXQgcmVzb2x2ZTtcblx0bGV0IHJlamVjdDtcblx0cmV0dXJuIHtcblx0XHRwcm9taXNlOiBuZXcgUHJvbWlzZSgoX3Jlc29sdmUsIF9yZWplY3QpID0+IHtcblx0XHRcdHJlc29sdmUgPSAodmFsdWUpID0+IHtcblx0XHRcdFx0X3Jlc29sdmUodmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlRGVmZXJyZWRQcm9taXNlKCk7XG5cdFx0XHR9O1xuXHRcdFx0cmVqZWN0ID0gKHJlYXNvbikgPT4ge1xuXHRcdFx0XHRfcmVqZWN0KHJlYXNvbik7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVEZWZlcnJlZFByb21pc2UoKTtcblx0XHRcdH07XG5cdFx0fSksXG5cdFx0cmVzb2x2ZSxcblx0XHRyZWplY3Rcblx0fTtcbn07XG4vKipcbiogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGRlZmVycmVkIFByb21pc2UgdGhhdCBjYW4gYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgd2l0aFxuKiB0aGUgcmV0dXJuZWQgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMuXG4qXG4qIEZvciBlYWNoIFByb21pc2UgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgdGhpcyB3YXksIHRoaXMgd2lsbCBhbHNvIGtlZXAgYSBzdGFja1xuKiBvZiBhbGwgdW5oYW5kbGVkIFByb21pc2VzLCByZXNvbHZlZCBvciByZWplY3RlZC5cbipcbiogT25jZSBhIFByb21pc2UgaXMgcmVhZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjay5cbiovXG5jb25zdCBjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2sgPSAoKSA9PiB7XG5cdGNvbnN0IHNldHRsZWRQcm9taXNlcyA9IFtdO1xuXHRsZXQgcm90YXRlUXVldWUgPSAoKSA9PiB7fTtcblx0Y29uc3QgcmVzdWx0cyA9IChhc3luYyBmdW5jdGlvbiogKCkge1xuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb25zdCBuZXh0ID0gc2V0dGxlZFByb21pc2VzLnNoaWZ0KCk7XG5cdFx0XHRpZiAobmV4dCkgeWllbGQgbmV4dDtcblx0XHRcdGVsc2UgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdFx0cm90YXRlUXVldWUgPSByZXNvbHZlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KSgpO1xuXHRjb25zdCBzaGltRGVmZXJyZWRQcm9taXNlID0gKGRlZmVycmVkKSA9PiB7XG5cdFx0Y29uc3Qgb3JpZ2luYWxSZXNvbHZlID0gZGVmZXJyZWQucmVzb2x2ZTtcblx0XHRjb25zdCBvcmlnaW5hbFJlamVjdCA9IGRlZmVycmVkLnJlamVjdDtcblx0XHRkZWZlcnJlZC5yZXNvbHZlID0gKHZhbHVlKSA9PiB7XG5cdFx0XHRzZXR0bGVkUHJvbWlzZXMucHVzaChkZWZlcnJlZC5wcm9taXNlKTtcblx0XHRcdHJvdGF0ZVF1ZXVlKCk7XG5cdFx0XHRyZXR1cm4gc2hpbURlZmVycmVkUHJvbWlzZShvcmlnaW5hbFJlc29sdmUodmFsdWUpKTtcblx0XHR9O1xuXHRcdGRlZmVycmVkLnJlamVjdCA9IChyZWFzb24pID0+IHtcblx0XHRcdHNldHRsZWRQcm9taXNlcy5wdXNoKGRlZmVycmVkLnByb21pc2UpO1xuXHRcdFx0cm90YXRlUXVldWUoKTtcblx0XHRcdHJldHVybiBzaGltRGVmZXJyZWRQcm9taXNlKG9yaWdpbmFsUmVqZWN0KHJlYXNvbikpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9O1xuXHRyZXR1cm4ge1xuXHRcdGRlZmVycmVkOiBzaGltRGVmZXJyZWRQcm9taXNlKGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpKSxcblx0XHRyZXN1bHRzXG5cdH07XG59O1xuLyoqXG4qIENyZWF0ZXMgYSBQcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFmdGVyIHRoZSBnaXZlbiBkdXJhdGlvbiwgYWxvbmcgd2l0aFxuKiBtZXRob2RzIHRvIHN0YXJ0LCBjbGVhciwgYW5kIHJlc2V0IHRoZSB0aW1lb3V0LlxuKi9cbmNvbnN0IGNyZWF0ZVRpbWVvdXRQcm9taXNlID0gKGR1cmF0aW9uKSA9PiB7XG5cdGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKCk7XG5cdGxldCB0aW1lb3V0O1xuXHRsZXQgcmV0O1xuXHRjb25zdCBzdGFydCA9ICgpID0+IHtcblx0XHRpZiAodGltZW91dCkgcmV0dXJuIHJldDtcblx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0fSwgZHVyYXRpb24pO1xuXHRcdHJldHVybiByZXQ7XG5cdH07XG5cdGNvbnN0IGNsZWFyID0gKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHR0aW1lb3V0ID0gdm9pZCAwO1xuXHR9O1xuXHRjb25zdCByZXNldCA9ICgpID0+IHtcblx0XHRjbGVhcigpO1xuXHRcdHJldHVybiBzdGFydCgpO1xuXHR9O1xuXHRyZXQgPSBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcblx0XHRzdGFydCxcblx0XHRjbGVhcixcblx0XHRyZXNldFxuXHR9KTtcblx0cmV0dXJuIHJldDtcbn07XG4vKipcbiogVGFrZSBhbnkgZnVuY3Rpb24gYW5kIHNhZmVseSBwcm9taXNpZnkgc3VjaCB0aGF0IGJvdGggc3luY2hyb25vdXMgYW5kXG4qIGFzeW5jaHJvbm91cyBlcnJvcnMgYXJlIGNhdWdodCBhbmQgcmV0dXJuZWQgYXMgYSByZWplY3RlZCBQcm9taXNlLlxuKlxuKiBUaGUgcGFzc2VkIGBmbmAgY2FuIGJlIHVuZGVmaW5lZCB0byBzdXBwb3J0IGZ1bmN0aW9ucyB0aGF0IG1heSBjb25kaXRpb25hbGx5XG4qIGJlIGRlZmluZWQuXG4qL1xuY29uc3QgcnVuQXNQcm9taXNlID0gKGZuKSA9PiB7XG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbn07XG4vKipcbiogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AgdGljay5cbiovXG5jb25zdCByZXNvbHZlTmV4dFRpY2sgPSAoKSA9PiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlKSk7XG59O1xuY29uc3QgcmV0cnlXaXRoQmFja29mZiA9IGFzeW5jIChmbiwgb3B0cykgPT4ge1xuXHRjb25zdCBtYXhBdHRlbXB0cyA9IG9wdHM/Lm1heEF0dGVtcHRzIHx8IDU7XG5cdGNvbnN0IGJhc2VEZWxheSA9IG9wdHM/LmJhc2VEZWxheSA/PyAxMDA7XG5cdGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHRyeSB7XG5cdFx0cmV0dXJuIGF3YWl0IGZuKCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGlmIChhdHRlbXB0ID49IG1heEF0dGVtcHRzKSB0aHJvdyBlcnI7XG5cdFx0Y29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAqIGJhc2VEZWxheTtcblx0XHRjb25zdCBkZWxheSA9IGJhc2VEZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKSArIGppdHRlcjtcblx0XHRhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuXHR9XG5cdHRocm93IG5ldyBFcnJvcihcIk1heCByZXRyaWVzIHJlYWNoZWQ7IHRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlLlwiKTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgY3JlYXRlRGVmZXJyZWRQcm9taXNlLCBjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2ssIGNyZWF0ZVRpbWVvdXRQcm9taXNlLCByZXNvbHZlQWZ0ZXJQZW5kaW5nLCByZXNvbHZlTmV4dFRpY2ssIHJldHJ5V2l0aEJhY2tvZmYsIHJ1bkFzUHJvbWlzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZXMuanMubWFwIl0sIm5hbWVzIjpbInNoaW1RdWV1ZU1pY3JvdGFzayIsImNhbGxiYWNrIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicmVzb2x2ZUFmdGVyUGVuZGluZyIsImNvdW50IiwiaSIsIml0ZXJhdGUiLCJjcmVhdGVEZWZlcnJlZFByb21pc2UiLCJyZWplY3QiLCJwcm9taXNlIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwidmFsdWUiLCJyZWFzb24iLCJjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2siLCJzZXR0bGVkUHJvbWlzZXMiLCJyb3RhdGVRdWV1ZSIsInJlc3VsdHMiLCJuZXh0Iiwic2hpZnQiLCJzaGltRGVmZXJyZWRQcm9taXNlIiwiZGVmZXJyZWQiLCJvcmlnaW5hbFJlc29sdmUiLCJvcmlnaW5hbFJlamVjdCIsInB1c2giLCJjcmVhdGVUaW1lb3V0UHJvbWlzZSIsImR1cmF0aW9uIiwidGltZW91dCIsInJldCIsInN0YXJ0Iiwic2V0VGltZW91dCIsImNsZWFyIiwiY2xlYXJUaW1lb3V0IiwicmVzZXQiLCJPYmplY3QiLCJhc3NpZ24iLCJydW5Bc1Byb21pc2UiLCJmbiIsInJlc29sdmVOZXh0VGljayIsInJldHJ5V2l0aEJhY2tvZmYiLCJvcHRzIiwibWF4QXR0ZW1wdHMiLCJiYXNlRGVsYXkiLCJhdHRlbXB0IiwiZXJyIiwiaml0dGVyIiwiTWF0aCIsInJhbmRvbSIsImRlbGF5IiwicG93IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/promises.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/stream.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/stream.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStream: () => (/* binding */ createStream)\n/* harmony export */ });\n/* harmony import */ var _strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n\n//#region src/helpers/stream.ts\n/**\n* Creates a {@link ReadableStream} that sends a `value` every `interval`\n* milliseconds as a heartbeat, intended to keep a stream open.\n*\n* Returns the `stream` itself and a `finalize` function that can be used to\n* close the stream and send a final value.\n*/ const createStream = (opts)=>{\n    /**\n\t* We need to resolve this promise with both the stream and the `finalize`\n\t* function, but having them both instantiated synchronously is difficult, as\n\t* we need access to the stream's internals too.\n\t*\n\t* We create this cheeky deferred promise to grab the internal `finalize`\n\t* value. Be warned that simpler solutions may appear to compile, but fail at\n\t* runtime due to variables not being assigned; make sure to test your code!\n\t*/ let passFinalize;\n    const finalizeP = new Promise((resolve)=>{\n        passFinalize = resolve;\n    });\n    const interval = opts?.interval ?? 3e3;\n    const value = opts?.value ?? \" \";\n    return new Promise(async (resolve, reject)=>{\n        try {\n            resolve({\n                stream: new ReadableStream({\n                    start (controller) {\n                        const encoder = new TextEncoder();\n                        const heartbeat = setInterval(()=>{\n                            controller.enqueue(encoder.encode(value));\n                        }, interval);\n                        const finalize = (data)=>{\n                            clearInterval(heartbeat);\n                            Promise.resolve(data).then((resolvedData)=>{\n                                controller.enqueue(encoder.encode((0,_strings_js__WEBPACK_IMPORTED_MODULE_0__.stringify)(resolvedData)));\n                                controller.close();\n                            });\n                        };\n                        passFinalize(finalize);\n                    }\n                }),\n                finalize: await finalizeP\n            });\n        } catch (err) {\n            reject(err);\n        }\n    });\n};\n//#endregion\n //# sourceMappingURL=stream.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUV6QywrQkFBK0I7QUFDL0I7Ozs7OztBQU1BLEdBQ0EsTUFBTUMsZUFBZSxDQUFDQztJQUNyQjs7Ozs7Ozs7Q0FRQSxHQUNBLElBQUlDO0lBQ0osTUFBTUMsWUFBWSxJQUFJQyxRQUFRLENBQUNDO1FBQzlCSCxlQUFlRztJQUNoQjtJQUNBLE1BQU1DLFdBQVdMLE1BQU1LLFlBQVk7SUFDbkMsTUFBTUMsUUFBUU4sTUFBTU0sU0FBUztJQUM3QixPQUFPLElBQUlILFFBQVEsT0FBT0MsU0FBU0c7UUFDbEMsSUFBSTtZQUNISCxRQUFRO2dCQUNQSSxRQUFRLElBQUlDLGVBQWU7b0JBQUVDLE9BQU1DLFVBQVU7d0JBQzVDLE1BQU1DLFVBQVUsSUFBSUM7d0JBQ3BCLE1BQU1DLFlBQVlDLFlBQVk7NEJBQzdCSixXQUFXSyxPQUFPLENBQUNKLFFBQVFLLE1BQU0sQ0FBQ1g7d0JBQ25DLEdBQUdEO3dCQUNILE1BQU1hLFdBQVcsQ0FBQ0M7NEJBQ2pCQyxjQUFjTjs0QkFDZFgsUUFBUUMsT0FBTyxDQUFDZSxNQUFNRSxJQUFJLENBQUMsQ0FBQ0M7Z0NBQzNCWCxXQUFXSyxPQUFPLENBQUNKLFFBQVFLLE1BQU0sQ0FBQ25CLHNEQUFTQSxDQUFDd0I7Z0NBQzVDWCxXQUFXWSxLQUFLOzRCQUNqQjt3QkFDRDt3QkFDQXRCLGFBQWFpQjtvQkFDZDtnQkFBRTtnQkFDRkEsVUFBVSxNQUFNaEI7WUFDakI7UUFDRCxFQUFFLE9BQU9zQixLQUFLO1lBQ2JqQixPQUFPaUI7UUFDUjtJQUNEO0FBQ0Q7QUFFQSxZQUFZO0FBQ1ksQ0FDeEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvc3RyZWFtLmpzP2JmMzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSBcIi4vc3RyaW5ncy5qc1wiO1xuXG4vLyNyZWdpb24gc3JjL2hlbHBlcnMvc3RyZWFtLnRzXG4vKipcbiogQ3JlYXRlcyBhIHtAbGluayBSZWFkYWJsZVN0cmVhbX0gdGhhdCBzZW5kcyBhIGB2YWx1ZWAgZXZlcnkgYGludGVydmFsYFxuKiBtaWxsaXNlY29uZHMgYXMgYSBoZWFydGJlYXQsIGludGVuZGVkIHRvIGtlZXAgYSBzdHJlYW0gb3Blbi5cbipcbiogUmV0dXJucyB0aGUgYHN0cmVhbWAgaXRzZWxmIGFuZCBhIGBmaW5hbGl6ZWAgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0b1xuKiBjbG9zZSB0aGUgc3RyZWFtIGFuZCBzZW5kIGEgZmluYWwgdmFsdWUuXG4qL1xuY29uc3QgY3JlYXRlU3RyZWFtID0gKG9wdHMpID0+IHtcblx0LyoqXG5cdCogV2UgbmVlZCB0byByZXNvbHZlIHRoaXMgcHJvbWlzZSB3aXRoIGJvdGggdGhlIHN0cmVhbSBhbmQgdGhlIGBmaW5hbGl6ZWBcblx0KiBmdW5jdGlvbiwgYnV0IGhhdmluZyB0aGVtIGJvdGggaW5zdGFudGlhdGVkIHN5bmNocm9ub3VzbHkgaXMgZGlmZmljdWx0LCBhc1xuXHQqIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBzdHJlYW0ncyBpbnRlcm5hbHMgdG9vLlxuXHQqXG5cdCogV2UgY3JlYXRlIHRoaXMgY2hlZWt5IGRlZmVycmVkIHByb21pc2UgdG8gZ3JhYiB0aGUgaW50ZXJuYWwgYGZpbmFsaXplYFxuXHQqIHZhbHVlLiBCZSB3YXJuZWQgdGhhdCBzaW1wbGVyIHNvbHV0aW9ucyBtYXkgYXBwZWFyIHRvIGNvbXBpbGUsIGJ1dCBmYWlsIGF0XG5cdCogcnVudGltZSBkdWUgdG8gdmFyaWFibGVzIG5vdCBiZWluZyBhc3NpZ25lZDsgbWFrZSBzdXJlIHRvIHRlc3QgeW91ciBjb2RlIVxuXHQqL1xuXHRsZXQgcGFzc0ZpbmFsaXplO1xuXHRjb25zdCBmaW5hbGl6ZVAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdHBhc3NGaW5hbGl6ZSA9IHJlc29sdmU7XG5cdH0pO1xuXHRjb25zdCBpbnRlcnZhbCA9IG9wdHM/LmludGVydmFsID8/IDNlMztcblx0Y29uc3QgdmFsdWUgPSBvcHRzPy52YWx1ZSA/PyBcIiBcIjtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0cmVzb2x2ZSh7XG5cdFx0XHRcdHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHsgc3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0XHRcdGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblx0XHRcdFx0XHRjb25zdCBoZWFydGJlYXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUodmFsdWUpKTtcblx0XHRcdFx0XHR9LCBpbnRlcnZhbCk7XG5cdFx0XHRcdFx0Y29uc3QgZmluYWxpemUgPSAoZGF0YSkgPT4ge1xuXHRcdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChoZWFydGJlYXQpO1xuXHRcdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKGRhdGEpLnRoZW4oKHJlc29sdmVkRGF0YSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoc3RyaW5naWZ5KHJlc29sdmVkRGF0YSkpKTtcblx0XHRcdFx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRwYXNzRmluYWxpemUoZmluYWxpemUpO1xuXHRcdFx0XHR9IH0pLFxuXHRcdFx0XHRmaW5hbGl6ZTogYXdhaXQgZmluYWxpemVQXG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdChlcnIpO1xuXHRcdH1cblx0fSk7XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGNyZWF0ZVN0cmVhbSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLmpzLm1hcCJdLCJuYW1lcyI6WyJzdHJpbmdpZnkiLCJjcmVhdGVTdHJlYW0iLCJvcHRzIiwicGFzc0ZpbmFsaXplIiwiZmluYWxpemVQIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbnRlcnZhbCIsInZhbHVlIiwicmVqZWN0Iiwic3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJoZWFydGJlYXQiLCJzZXRJbnRlcnZhbCIsImVucXVldWUiLCJlbmNvZGUiLCJmaW5hbGl6ZSIsImRhdGEiLCJjbGVhckludGVydmFsIiwidGhlbiIsInJlc29sdmVkRGF0YSIsImNsb3NlIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/strings.js":
/*!*************************************************!*\
  !*** ./node_modules/inngest/helpers/strings.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashEventKey: () => (/* binding */ hashEventKey),\n/* harmony export */   hashSigningKey: () => (/* binding */ hashSigningKey),\n/* harmony export */   slugify: () => (/* binding */ slugify),\n/* harmony export */   stringify: () => (/* binding */ stringify$1),\n/* harmony export */   stringifyUnknown: () => (/* binding */ stringifyUnknown),\n/* harmony export */   timeStr: () => (/* binding */ timeStr)\n/* harmony export */ });\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\");\n\n\n\n//#region src/helpers/strings.ts\nconst { sha256 } = hash_js__WEBPACK_IMPORTED_MODULE_1__;\n/**\n* Safely `JSON.stringify()` an `input`, handling circular refernences and\n* removing `BigInt` values.\n*/ const stringify$1 = (input)=>{\n    return json_stringify_safe__WEBPACK_IMPORTED_MODULE_0__(input, (_key, value)=>{\n        if (typeof value !== \"bigint\") return value;\n    });\n};\n/**\n* Returns a slugified string used to generate consistent IDs.\n*\n* This can be used to generate a consistent ID for a function when migrating\n* from v2 to v3 of the SDK.\n*\n* @public\n*/ const slugify = (str)=>{\n    const join = \"-\";\n    return str.toLowerCase().replace(/[^a-z0-9-]+/g, join).replace(/-+/g, join).split(join).filter(Boolean).join(join);\n};\nconst second = 1 * 1e3;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\n/**\n* A collection of periods in milliseconds and their suffixes used when creating\n* time strings.\n*/ const periods = [\n    [\n        \"w\",\n        day * 7\n    ],\n    [\n        \"d\",\n        day\n    ],\n    [\n        \"h\",\n        hour\n    ],\n    [\n        \"m\",\n        minute\n    ],\n    [\n        \"s\",\n        second\n    ]\n];\n/**\n* Convert a given `Date`, `number`, or `ms`-compatible `string` to a\n* Inngest sleep-compatible time string (e.g. `\"1d\"` or `\"2h3010s\"`).\n*\n* Can optionally provide a `now` date to use as the base for the calculation,\n* otherwise a new date will be created on invocation.\n*/ const timeStr = (input)=>{\n    if (input instanceof Date) return input.toISOString();\n    const milliseconds = typeof input === \"string\" ? ms__WEBPACK_IMPORTED_MODULE_2__(input) : input;\n    const [, timeStr$1] = periods.reduce(([num, str], [suffix, period])=>{\n        const numPeriods = Math.floor(num / period);\n        if (numPeriods > 0) return [\n            num % period,\n            `${str}${numPeriods}${suffix}`\n        ];\n        return [\n            num,\n            str\n        ];\n    }, [\n        milliseconds,\n        \"\"\n    ]);\n    return timeStr$1;\n};\n/**\n* Given an unknown input, stringify it if it's a boolean, a number, or a\n* string, else return `undefined`.\n*/ const stringifyUnknown = (input)=>{\n    if (typeof input === \"boolean\" || typeof input === \"number\" || typeof input === \"string\") return input.toString();\n};\nconst hashEventKey = (eventKey)=>{\n    return sha256().update(eventKey).digest(\"hex\");\n};\nconst hashSigningKey = (signingKey)=>{\n    if (!signingKey) return \"\";\n    const prefix = signingKey.match(/^signkey-[\\w]+-/)?.shift() || \"\";\n    const key = signingKey.replace(/^signkey-[\\w]+-/, \"\");\n    return `${prefix}${sha256().update(key, \"hex\").digest(\"hex\")}`;\n};\n//#endregion\n //# sourceMappingURL=strings.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ2Y7QUFDVDtBQUVwQixnQ0FBZ0M7QUFDaEMsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0Ysb0NBQU1BO0FBQ3pCOzs7QUFHQSxHQUNBLE1BQU1HLGNBQWMsQ0FBQ0M7SUFDcEIsT0FBT0wsZ0RBQVNBLENBQUNLLE9BQU8sQ0FBQ0MsTUFBTUM7UUFDOUIsSUFBSSxPQUFPQSxVQUFVLFVBQVUsT0FBT0E7SUFDdkM7QUFDRDtBQUNBOzs7Ozs7O0FBT0EsR0FDQSxNQUFNQyxVQUFVLENBQUNDO0lBQ2hCLE1BQU1DLE9BQU87SUFDYixPQUFPRCxJQUFJRSxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxnQkFBZ0JGLE1BQU1FLE9BQU8sQ0FBQyxPQUFPRixNQUFNRyxLQUFLLENBQUNILE1BQU1JLE1BQU0sQ0FBQ0MsU0FBU0wsSUFBSSxDQUFDQTtBQUM5RztBQUNBLE1BQU1NLFNBQVMsSUFBSTtBQUNuQixNQUFNQyxTQUFTRCxTQUFTO0FBQ3hCLE1BQU1FLE9BQU9ELFNBQVM7QUFDdEIsTUFBTUUsTUFBTUQsT0FBTztBQUNuQjs7O0FBR0EsR0FDQSxNQUFNRSxVQUFVO0lBQ2Y7UUFBQztRQUFLRCxNQUFNO0tBQUU7SUFDZDtRQUFDO1FBQUtBO0tBQUk7SUFDVjtRQUFDO1FBQUtEO0tBQUs7SUFDWDtRQUFDO1FBQUtEO0tBQU87SUFDYjtRQUFDO1FBQUtEO0tBQU87Q0FDYjtBQUNEOzs7Ozs7QUFNQSxHQUNBLE1BQU1LLFVBQVUsQ0FBQ2hCO0lBQ2hCLElBQUlBLGlCQUFpQmlCLE1BQU0sT0FBT2pCLE1BQU1rQixXQUFXO0lBQ25ELE1BQU1DLGVBQWUsT0FBT25CLFVBQVUsV0FBV0gsK0JBQUVBLENBQUNHLFNBQVNBO0lBQzdELE1BQU0sR0FBR29CLFVBQVUsR0FBR0wsUUFBUU0sTUFBTSxDQUFDLENBQUMsQ0FBQ0MsS0FBS2xCLElBQUksRUFBRSxDQUFDbUIsUUFBUUMsT0FBTztRQUNqRSxNQUFNQyxhQUFhQyxLQUFLQyxLQUFLLENBQUNMLE1BQU1FO1FBQ3BDLElBQUlDLGFBQWEsR0FBRyxPQUFPO1lBQUNILE1BQU1FO1lBQVEsQ0FBQyxFQUFFcEIsSUFBSSxFQUFFcUIsV0FBVyxFQUFFRixPQUFPLENBQUM7U0FBQztRQUN6RSxPQUFPO1lBQUNEO1lBQUtsQjtTQUFJO0lBQ2xCLEdBQUc7UUFBQ2U7UUFBYztLQUFHO0lBQ3JCLE9BQU9DO0FBQ1I7QUFDQTs7O0FBR0EsR0FDQSxNQUFNUSxtQkFBbUIsQ0FBQzVCO0lBQ3pCLElBQUksT0FBT0EsVUFBVSxhQUFhLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFVBQVUsT0FBT0EsTUFBTTZCLFFBQVE7QUFDaEg7QUFDQSxNQUFNQyxlQUFlLENBQUNDO0lBQ3JCLE9BQU9qQyxTQUFTa0MsTUFBTSxDQUFDRCxVQUFVRSxNQUFNLENBQUM7QUFDekM7QUFDQSxNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdkIsSUFBSSxDQUFDQSxZQUFZLE9BQU87SUFDeEIsTUFBTUMsU0FBU0QsV0FBV0UsS0FBSyxDQUFDLG9CQUFvQkMsV0FBVztJQUMvRCxNQUFNQyxNQUFNSixXQUFXNUIsT0FBTyxDQUFDLG1CQUFtQjtJQUNsRCxPQUFPLENBQUMsRUFBRTZCLE9BQU8sRUFBRXRDLFNBQVNrQyxNQUFNLENBQUNPLEtBQUssT0FBT04sTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUMvRDtBQUVBLFlBQVk7QUFDMEYsQ0FDdEcsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvc3RyaW5ncy5qcz82NmIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJpbmdpZnkgZnJvbSBcImpzb24tc3RyaW5naWZ5LXNhZmVcIjtcbmltcG9ydCBoYXNoanMgZnJvbSBcImhhc2guanNcIjtcbmltcG9ydCBtcyBmcm9tIFwibXNcIjtcblxuLy8jcmVnaW9uIHNyYy9oZWxwZXJzL3N0cmluZ3MudHNcbmNvbnN0IHsgc2hhMjU2IH0gPSBoYXNoanM7XG4vKipcbiogU2FmZWx5IGBKU09OLnN0cmluZ2lmeSgpYCBhbiBgaW5wdXRgLCBoYW5kbGluZyBjaXJjdWxhciByZWZlcm5lbmNlcyBhbmRcbiogcmVtb3ZpbmcgYEJpZ0ludGAgdmFsdWVzLlxuKi9cbmNvbnN0IHN0cmluZ2lmeSQxID0gKGlucHV0KSA9PiB7XG5cdHJldHVybiBzdHJpbmdpZnkoaW5wdXQsIChfa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYmlnaW50XCIpIHJldHVybiB2YWx1ZTtcblx0fSk7XG59O1xuLyoqXG4qIFJldHVybnMgYSBzbHVnaWZpZWQgc3RyaW5nIHVzZWQgdG8gZ2VuZXJhdGUgY29uc2lzdGVudCBJRHMuXG4qXG4qIFRoaXMgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYSBjb25zaXN0ZW50IElEIGZvciBhIGZ1bmN0aW9uIHdoZW4gbWlncmF0aW5nXG4qIGZyb20gdjIgdG8gdjMgb2YgdGhlIFNESy5cbipcbiogQHB1YmxpY1xuKi9cbmNvbnN0IHNsdWdpZnkgPSAoc3RyKSA9PiB7XG5cdGNvbnN0IGpvaW4gPSBcIi1cIjtcblx0cmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05LV0rL2csIGpvaW4pLnJlcGxhY2UoLy0rL2csIGpvaW4pLnNwbGl0KGpvaW4pLmZpbHRlcihCb29sZWFuKS5qb2luKGpvaW4pO1xufTtcbmNvbnN0IHNlY29uZCA9IDEgKiAxZTM7XG5jb25zdCBtaW51dGUgPSBzZWNvbmQgKiA2MDtcbmNvbnN0IGhvdXIgPSBtaW51dGUgKiA2MDtcbmNvbnN0IGRheSA9IGhvdXIgKiAyNDtcbi8qKlxuKiBBIGNvbGxlY3Rpb24gb2YgcGVyaW9kcyBpbiBtaWxsaXNlY29uZHMgYW5kIHRoZWlyIHN1ZmZpeGVzIHVzZWQgd2hlbiBjcmVhdGluZ1xuKiB0aW1lIHN0cmluZ3MuXG4qL1xuY29uc3QgcGVyaW9kcyA9IFtcblx0W1wid1wiLCBkYXkgKiA3XSxcblx0W1wiZFwiLCBkYXldLFxuXHRbXCJoXCIsIGhvdXJdLFxuXHRbXCJtXCIsIG1pbnV0ZV0sXG5cdFtcInNcIiwgc2Vjb25kXVxuXTtcbi8qKlxuKiBDb252ZXJ0IGEgZ2l2ZW4gYERhdGVgLCBgbnVtYmVyYCwgb3IgYG1zYC1jb21wYXRpYmxlIGBzdHJpbmdgIHRvIGFcbiogSW5uZ2VzdCBzbGVlcC1jb21wYXRpYmxlIHRpbWUgc3RyaW5nIChlLmcuIGBcIjFkXCJgIG9yIGBcIjJoMzAxMHNcImApLlxuKlxuKiBDYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgYG5vd2AgZGF0ZSB0byB1c2UgYXMgdGhlIGJhc2UgZm9yIHRoZSBjYWxjdWxhdGlvbixcbiogb3RoZXJ3aXNlIGEgbmV3IGRhdGUgd2lsbCBiZSBjcmVhdGVkIG9uIGludm9jYXRpb24uXG4qL1xuY29uc3QgdGltZVN0ciA9IChpbnB1dCkgPT4ge1xuXHRpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gaW5wdXQudG9JU09TdHJpbmcoKTtcblx0Y29uc3QgbWlsbGlzZWNvbmRzID0gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gbXMoaW5wdXQpIDogaW5wdXQ7XG5cdGNvbnN0IFssIHRpbWVTdHIkMV0gPSBwZXJpb2RzLnJlZHVjZSgoW251bSwgc3RyXSwgW3N1ZmZpeCwgcGVyaW9kXSkgPT4ge1xuXHRcdGNvbnN0IG51bVBlcmlvZHMgPSBNYXRoLmZsb29yKG51bSAvIHBlcmlvZCk7XG5cdFx0aWYgKG51bVBlcmlvZHMgPiAwKSByZXR1cm4gW251bSAlIHBlcmlvZCwgYCR7c3RyfSR7bnVtUGVyaW9kc30ke3N1ZmZpeH1gXTtcblx0XHRyZXR1cm4gW251bSwgc3RyXTtcblx0fSwgW21pbGxpc2Vjb25kcywgXCJcIl0pO1xuXHRyZXR1cm4gdGltZVN0ciQxO1xufTtcbi8qKlxuKiBHaXZlbiBhbiB1bmtub3duIGlucHV0LCBzdHJpbmdpZnkgaXQgaWYgaXQncyBhIGJvb2xlYW4sIGEgbnVtYmVyLCBvciBhXG4qIHN0cmluZywgZWxzZSByZXR1cm4gYHVuZGVmaW5lZGAuXG4qL1xuY29uc3Qgc3RyaW5naWZ5VW5rbm93biA9IChpbnB1dCkgPT4ge1xuXHRpZiAodHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSByZXR1cm4gaW5wdXQudG9TdHJpbmcoKTtcbn07XG5jb25zdCBoYXNoRXZlbnRLZXkgPSAoZXZlbnRLZXkpID0+IHtcblx0cmV0dXJuIHNoYTI1NigpLnVwZGF0ZShldmVudEtleSkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmNvbnN0IGhhc2hTaWduaW5nS2V5ID0gKHNpZ25pbmdLZXkpID0+IHtcblx0aWYgKCFzaWduaW5nS2V5KSByZXR1cm4gXCJcIjtcblx0Y29uc3QgcHJlZml4ID0gc2lnbmluZ0tleS5tYXRjaCgvXnNpZ25rZXktW1xcd10rLS8pPy5zaGlmdCgpIHx8IFwiXCI7XG5cdGNvbnN0IGtleSA9IHNpZ25pbmdLZXkucmVwbGFjZSgvXnNpZ25rZXktW1xcd10rLS8sIFwiXCIpO1xuXHRyZXR1cm4gYCR7cHJlZml4fSR7c2hhMjU2KCkudXBkYXRlKGtleSwgXCJoZXhcIikuZGlnZXN0KFwiaGV4XCIpfWA7XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IGhhc2hFdmVudEtleSwgaGFzaFNpZ25pbmdLZXksIHNsdWdpZnksIHN0cmluZ2lmeSQxIGFzIHN0cmluZ2lmeSwgc3RyaW5naWZ5VW5rbm93biwgdGltZVN0ciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5ncy5qcy5tYXAiXSwibmFtZXMiOlsic3RyaW5naWZ5IiwiaGFzaGpzIiwibXMiLCJzaGEyNTYiLCJzdHJpbmdpZnkkMSIsImlucHV0IiwiX2tleSIsInZhbHVlIiwic2x1Z2lmeSIsInN0ciIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsInJlcGxhY2UiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5IiwicGVyaW9kcyIsInRpbWVTdHIiLCJEYXRlIiwidG9JU09TdHJpbmciLCJtaWxsaXNlY29uZHMiLCJ0aW1lU3RyJDEiLCJyZWR1Y2UiLCJudW0iLCJzdWZmaXgiLCJwZXJpb2QiLCJudW1QZXJpb2RzIiwiTWF0aCIsImZsb29yIiwic3RyaW5naWZ5VW5rbm93biIsInRvU3RyaW5nIiwiaGFzaEV2ZW50S2V5IiwiZXZlbnRLZXkiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoU2lnbmluZ0tleSIsInNpZ25pbmdLZXkiLCJwcmVmaXgiLCJtYXRjaCIsInNoaWZ0Iiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/temporal.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/temporal.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getISOString: () => (/* binding */ getISOString),\n/* harmony export */   isTemporalDuration: () => (/* binding */ isTemporalDuration)\n/* harmony export */ });\n//#region src/helpers/temporal.ts\n/**\n* Asserts that the given `input` is a `Temporal.Duration` object.\n*/ const isTemporalDuration = (input)=>{\n    try {\n        return input[Symbol.toStringTag] === \"Temporal.Duration\";\n    } catch  {\n        return false;\n    }\n};\n/**\n* Asserts that the given `input` is a `Temporal.TimeZone` object.\n*/ const isTemporalInstant = (input)=>{\n    try {\n        return input[Symbol.toStringTag] === \"Temporal.Instant\";\n    } catch  {\n        return false;\n    }\n};\n/**\n* Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n*/ const isTemporalZonedDateTime = (input)=>{\n    try {\n        return input[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n    } catch  {\n        return false;\n    }\n};\n/**\n* Converts a given `Date`, `string`, `Temporal.Instant`, or\n* `Temporal.ZonedDateTime` to an ISO 8601 string.\n*/ const getISOString = (time)=>{\n    if (typeof time === \"string\") return new Date(time).toISOString();\n    if (time instanceof Date) return time.toISOString();\n    if (isTemporalZonedDateTime(time)) return time.toInstant().toString();\n    if (isTemporalInstant(time)) return time.toString();\n    throw new TypeError(\"Invalid date input\");\n};\n//#endregion\n //# sourceMappingURL=temporal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3RlbXBvcmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsaUNBQWlDO0FBQ2pDOztBQUVBLEdBQ0EsTUFBTUEscUJBQXFCLENBQUNDO0lBQzNCLElBQUk7UUFDSCxPQUFPQSxLQUFLLENBQUNDLE9BQU9DLFdBQVcsQ0FBQyxLQUFLO0lBQ3RDLEVBQUUsT0FBTTtRQUNQLE9BQU87SUFDUjtBQUNEO0FBQ0E7O0FBRUEsR0FDQSxNQUFNQyxvQkFBb0IsQ0FBQ0g7SUFDMUIsSUFBSTtRQUNILE9BQU9BLEtBQUssQ0FBQ0MsT0FBT0MsV0FBVyxDQUFDLEtBQUs7SUFDdEMsRUFBRSxPQUFNO1FBQ1AsT0FBTztJQUNSO0FBQ0Q7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLDBCQUEwQixDQUFDSjtJQUNoQyxJQUFJO1FBQ0gsT0FBT0EsS0FBSyxDQUFDQyxPQUFPQyxXQUFXLENBQUMsS0FBSztJQUN0QyxFQUFFLE9BQU07UUFDUCxPQUFPO0lBQ1I7QUFDRDtBQUNBOzs7QUFHQSxHQUNBLE1BQU1HLGVBQWUsQ0FBQ0M7SUFDckIsSUFBSSxPQUFPQSxTQUFTLFVBQVUsT0FBTyxJQUFJQyxLQUFLRCxNQUFNRSxXQUFXO0lBQy9ELElBQUlGLGdCQUFnQkMsTUFBTSxPQUFPRCxLQUFLRSxXQUFXO0lBQ2pELElBQUlKLHdCQUF3QkUsT0FBTyxPQUFPQSxLQUFLRyxTQUFTLEdBQUdDLFFBQVE7SUFDbkUsSUFBSVAsa0JBQWtCRyxPQUFPLE9BQU9BLEtBQUtJLFFBQVE7SUFDakQsTUFBTSxJQUFJQyxVQUFVO0FBQ3JCO0FBRUEsWUFBWTtBQUNnQyxDQUM1QyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy90ZW1wb3JhbC5qcz8xMWFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vI3JlZ2lvbiBzcmMvaGVscGVycy90ZW1wb3JhbC50c1xuLyoqXG4qIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYGlucHV0YCBpcyBhIGBUZW1wb3JhbC5EdXJhdGlvbmAgb2JqZWN0LlxuKi9cbmNvbnN0IGlzVGVtcG9yYWxEdXJhdGlvbiA9IChpbnB1dCkgPT4ge1xuXHR0cnkge1xuXHRcdHJldHVybiBpbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlRlbXBvcmFsLkR1cmF0aW9uXCI7XG5cdH0gY2F0Y2gge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbi8qKlxuKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGBpbnB1dGAgaXMgYSBgVGVtcG9yYWwuVGltZVpvbmVgIG9iamVjdC5cbiovXG5jb25zdCBpc1RlbXBvcmFsSW5zdGFudCA9IChpbnB1dCkgPT4ge1xuXHR0cnkge1xuXHRcdHJldHVybiBpbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlRlbXBvcmFsLkluc3RhbnRcIjtcblx0fSBjYXRjaCB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuLyoqXG4qIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYGlucHV0YCBpcyBhIGBUZW1wb3JhbC5ab25lZERhdGVUaW1lYCBvYmplY3QuXG4qL1xuY29uc3QgaXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUgPSAoaW5wdXQpID0+IHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gaW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJUZW1wb3JhbC5ab25lZERhdGVUaW1lXCI7XG5cdH0gY2F0Y2gge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbi8qKlxuKiBDb252ZXJ0cyBhIGdpdmVuIGBEYXRlYCwgYHN0cmluZ2AsIGBUZW1wb3JhbC5JbnN0YW50YCwgb3JcbiogYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVgIHRvIGFuIElTTyA4NjAxIHN0cmluZy5cbiovXG5jb25zdCBnZXRJU09TdHJpbmcgPSAodGltZSkgPT4ge1xuXHRpZiAodHlwZW9mIHRpbWUgPT09IFwic3RyaW5nXCIpIHJldHVybiBuZXcgRGF0ZSh0aW1lKS50b0lTT1N0cmluZygpO1xuXHRpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0aW1lLnRvSVNPU3RyaW5nKCk7XG5cdGlmIChpc1RlbXBvcmFsWm9uZWREYXRlVGltZSh0aW1lKSkgcmV0dXJuIHRpbWUudG9JbnN0YW50KCkudG9TdHJpbmcoKTtcblx0aWYgKGlzVGVtcG9yYWxJbnN0YW50KHRpbWUpKSByZXR1cm4gdGltZS50b1N0cmluZygpO1xuXHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBkYXRlIGlucHV0XCIpO1xufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBnZXRJU09TdHJpbmcsIGlzVGVtcG9yYWxEdXJhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcG9yYWwuanMubWFwIl0sIm5hbWVzIjpbImlzVGVtcG9yYWxEdXJhdGlvbiIsImlucHV0IiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpc1RlbXBvcmFsSW5zdGFudCIsImlzVGVtcG9yYWxab25lZERhdGVUaW1lIiwiZ2V0SVNPU3RyaW5nIiwidGltZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInRvSW5zdGFudCIsInRvU3RyaW5nIiwiVHlwZUVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/temporal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/logger.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/middleware/logger.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultLogger: () => (/* binding */ DefaultLogger),\n/* harmony export */   ProxyLogger: () => (/* binding */ ProxyLogger)\n/* harmony export */ });\n/* harmony import */ var _helpers_promises_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n\n//#region src/middleware/logger.ts\nvar DefaultLogger = class {\n    info(...args) {\n        console.info(...args);\n    }\n    warn(...args) {\n        console.warn(...args);\n    }\n    error(...args) {\n        console.error(...args);\n    }\n    debug(...args) {\n        console.debug(...args);\n    }\n};\n/**\n* ProxyLogger aims to provide a thin wrapper on user's provided logger.\n* It's expected to be turned on and off based on the function execution\n* context, so it doesn't result in duplicated logging.\n*\n* And also attempt to allow enough time for the logger to flush all logs.\n*\n* @public\n*/ var ProxyLogger = class {\n    constructor(logger){\n        this.enabled = false;\n        this.logger = logger;\n        return new Proxy(this, {\n            get (target, prop, receiver) {\n                if (prop in target) return Reflect.get(target, prop, receiver);\n                return Reflect.get(target.logger, prop, receiver);\n            }\n        });\n    }\n    info(...args) {\n        if (!this.enabled) return;\n        this.logger.info(...args);\n    }\n    warn(...args) {\n        if (!this.enabled) return;\n        this.logger.warn(...args);\n    }\n    error(...args) {\n        if (!this.enabled) return;\n        this.logger.error(...args);\n    }\n    debug(...args) {\n        if (!this.enabled || !(typeof this.logger.debug === \"function\")) return;\n        this.logger.debug(...args);\n    }\n    enable() {\n        this.enabled = true;\n    }\n    disable() {\n        this.enabled = false;\n    }\n    async flush() {\n        if (this.logger.constructor.name == DefaultLogger.name) return;\n        const logger = this.logger;\n        if (typeof logger.flush === \"function\") {\n            await logger.flush();\n            return;\n        }\n        await (0,_helpers_promises_js__WEBPACK_IMPORTED_MODULE_0__.resolveNextTick)();\n    }\n};\n//#endregion\n //# sourceMappingURL=logger.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUQ7QUFFekQsa0NBQWtDO0FBQ2xDLElBQUlDLGdCQUFnQjtJQUNuQkMsS0FBSyxHQUFHQyxJQUFJLEVBQUU7UUFDYkMsUUFBUUYsSUFBSSxJQUFJQztJQUNqQjtJQUNBRSxLQUFLLEdBQUdGLElBQUksRUFBRTtRQUNiQyxRQUFRQyxJQUFJLElBQUlGO0lBQ2pCO0lBQ0FHLE1BQU0sR0FBR0gsSUFBSSxFQUFFO1FBQ2RDLFFBQVFFLEtBQUssSUFBSUg7SUFDbEI7SUFDQUksTUFBTSxHQUFHSixJQUFJLEVBQUU7UUFDZEMsUUFBUUcsS0FBSyxJQUFJSjtJQUNsQjtBQUNEO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxJQUFJSyxjQUFjO0lBR2pCQyxZQUFZQyxNQUFNLENBQUU7YUFEcEJDLFVBQVU7UUFFVCxJQUFJLENBQUNELE1BQU0sR0FBR0E7UUFDZCxPQUFPLElBQUlFLE1BQU0sSUFBSSxFQUFFO1lBQUVDLEtBQUlDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxRQUFRO2dCQUNsRCxJQUFJRCxRQUFRRCxRQUFRLE9BQU9HLFFBQVFKLEdBQUcsQ0FBQ0MsUUFBUUMsTUFBTUM7Z0JBQ3JELE9BQU9DLFFBQVFKLEdBQUcsQ0FBQ0MsT0FBT0osTUFBTSxFQUFFSyxNQUFNQztZQUN6QztRQUFFO0lBQ0g7SUFDQWQsS0FBSyxHQUFHQyxJQUFJLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDUSxPQUFPLEVBQUU7UUFDbkIsSUFBSSxDQUFDRCxNQUFNLENBQUNSLElBQUksSUFBSUM7SUFDckI7SUFDQUUsS0FBSyxHQUFHRixJQUFJLEVBQUU7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDUSxPQUFPLEVBQUU7UUFDbkIsSUFBSSxDQUFDRCxNQUFNLENBQUNMLElBQUksSUFBSUY7SUFDckI7SUFDQUcsTUFBTSxHQUFHSCxJQUFJLEVBQUU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDUSxPQUFPLEVBQUU7UUFDbkIsSUFBSSxDQUFDRCxNQUFNLENBQUNKLEtBQUssSUFBSUg7SUFDdEI7SUFDQUksTUFBTSxHQUFHSixJQUFJLEVBQUU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDUSxPQUFPLElBQUksQ0FBRSxRQUFPLElBQUksQ0FBQ0QsTUFBTSxDQUFDSCxLQUFLLEtBQUssVUFBUyxHQUFJO1FBQ2pFLElBQUksQ0FBQ0csTUFBTSxDQUFDSCxLQUFLLElBQUlKO0lBQ3RCO0lBQ0FlLFNBQVM7UUFDUixJQUFJLENBQUNQLE9BQU8sR0FBRztJQUNoQjtJQUNBUSxVQUFVO1FBQ1QsSUFBSSxDQUFDUixPQUFPLEdBQUc7SUFDaEI7SUFDQSxNQUFNUyxRQUFRO1FBQ2IsSUFBSSxJQUFJLENBQUNWLE1BQU0sQ0FBQ0QsV0FBVyxDQUFDWSxJQUFJLElBQUlwQixjQUFjb0IsSUFBSSxFQUFFO1FBQ3hELE1BQU1YLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQzFCLElBQUksT0FBT0EsT0FBT1UsS0FBSyxLQUFLLFlBQVk7WUFDdkMsTUFBTVYsT0FBT1UsS0FBSztZQUNsQjtRQUNEO1FBQ0EsTUFBTXBCLHFFQUFlQTtJQUN0QjtBQUNEO0FBRUEsWUFBWTtBQUMwQixDQUN0QyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tYXBwLy4vbm9kZV9tb2R1bGVzL2lubmdlc3QvbWlkZGxld2FyZS9sb2dnZXIuanM/YzE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXNvbHZlTmV4dFRpY2sgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlcy5qc1wiO1xuXG4vLyNyZWdpb24gc3JjL21pZGRsZXdhcmUvbG9nZ2VyLnRzXG52YXIgRGVmYXVsdExvZ2dlciA9IGNsYXNzIHtcblx0aW5mbyguLi5hcmdzKSB7XG5cdFx0Y29uc29sZS5pbmZvKC4uLmFyZ3MpO1xuXHR9XG5cdHdhcm4oLi4uYXJncykge1xuXHRcdGNvbnNvbGUud2FybiguLi5hcmdzKTtcblx0fVxuXHRlcnJvciguLi5hcmdzKSB7XG5cdFx0Y29uc29sZS5lcnJvciguLi5hcmdzKTtcblx0fVxuXHRkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0Y29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcblx0fVxufTtcbi8qKlxuKiBQcm94eUxvZ2dlciBhaW1zIHRvIHByb3ZpZGUgYSB0aGluIHdyYXBwZXIgb24gdXNlcidzIHByb3ZpZGVkIGxvZ2dlci5cbiogSXQncyBleHBlY3RlZCB0byBiZSB0dXJuZWQgb24gYW5kIG9mZiBiYXNlZCBvbiB0aGUgZnVuY3Rpb24gZXhlY3V0aW9uXG4qIGNvbnRleHQsIHNvIGl0IGRvZXNuJ3QgcmVzdWx0IGluIGR1cGxpY2F0ZWQgbG9nZ2luZy5cbipcbiogQW5kIGFsc28gYXR0ZW1wdCB0byBhbGxvdyBlbm91Z2ggdGltZSBmb3IgdGhlIGxvZ2dlciB0byBmbHVzaCBhbGwgbG9ncy5cbipcbiogQHB1YmxpY1xuKi9cbnZhciBQcm94eUxvZ2dlciA9IGNsYXNzIHtcblx0bG9nZ2VyO1xuXHRlbmFibGVkID0gZmFsc2U7XG5cdGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuXHRcdHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuXHRcdHJldHVybiBuZXcgUHJveHkodGhpcywgeyBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuXHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0KSByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cdFx0XHRyZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LmxvZ2dlciwgcHJvcCwgcmVjZWl2ZXIpO1xuXHRcdH0gfSk7XG5cdH1cblx0aW5mbyguLi5hcmdzKSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblx0XHR0aGlzLmxvZ2dlci5pbmZvKC4uLmFyZ3MpO1xuXHR9XG5cdHdhcm4oLi4uYXJncykge1xuXHRcdGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG5cdFx0dGhpcy5sb2dnZXIud2FybiguLi5hcmdzKTtcblx0fVxuXHRlcnJvciguLi5hcmdzKSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblx0XHR0aGlzLmxvZ2dlci5lcnJvciguLi5hcmdzKTtcblx0fVxuXHRkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0aWYgKCF0aGlzLmVuYWJsZWQgfHwgISh0eXBlb2YgdGhpcy5sb2dnZXIuZGVidWcgPT09IFwiZnVuY3Rpb25cIikpIHJldHVybjtcblx0XHR0aGlzLmxvZ2dlci5kZWJ1ZyguLi5hcmdzKTtcblx0fVxuXHRlbmFibGUoKSB7XG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcblx0fVxuXHRkaXNhYmxlKCkge1xuXHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHR9XG5cdGFzeW5jIGZsdXNoKCkge1xuXHRcdGlmICh0aGlzLmxvZ2dlci5jb25zdHJ1Y3Rvci5uYW1lID09IERlZmF1bHRMb2dnZXIubmFtZSkgcmV0dXJuO1xuXHRcdGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2VyO1xuXHRcdGlmICh0eXBlb2YgbG9nZ2VyLmZsdXNoID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGF3YWl0IGxvZ2dlci5mbHVzaCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRhd2FpdCByZXNvbHZlTmV4dFRpY2soKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBEZWZhdWx0TG9nZ2VyLCBQcm94eUxvZ2dlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJyZXNvbHZlTmV4dFRpY2siLCJEZWZhdWx0TG9nZ2VyIiwiaW5mbyIsImFyZ3MiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwiZGVidWciLCJQcm94eUxvZ2dlciIsImNvbnN0cnVjdG9yIiwibG9nZ2VyIiwiZW5hYmxlZCIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImVuYWJsZSIsImRpc2FibGUiLCJmbHVzaCIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/next.js":
/*!**************************************!*\
  !*** ./node_modules/inngest/next.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   frameworkName: () => (/* binding */ frameworkName),\n/* harmony export */   serve: () => (/* binding */ serve)\n/* harmony export */ });\n/* harmony import */ var _helpers_env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/* harmony import */ var _components_InngestCommHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\n\n\n//#region src/next.ts\n/**\n* The name of the framework, used to identify the framework in Inngest\n* dashboards and during testing.\n*/ const frameworkName = \"nextjs\";\nconst isRecord = (val)=>{\n    return typeof val === \"object\" && val !== null;\n};\nconst isFunction = (val)=>{\n    return typeof val === \"function\";\n};\nconst isNext12ApiResponse = (val)=>{\n    return isRecord(val) && isFunction(val.setHeader) && isFunction(val.status) && isFunction(val.send);\n};\n/**\n* In Next.js, serve and register any declared functions with Inngest, making\n* them available to be triggered by events.\n*\n* Supports Next.js 12+, both serverless and edge.\n*\n* @example Next.js <=12 or the pages router can export the handler directly\n* ```ts\n* export default serve({ client: inngest, functions: [fn1, fn2] });\n* ```\n*\n* @example Next.js >=13 with the `app` dir must export individual methods\n* ```ts\n* export const { GET, POST, PUT } = serve({\n*            client: inngest,\n*            functions: [fn1, fn2],\n* });\n* ```\n*\n* @public\n*/ const serve = (options)=>{\n    /**\n\t* Next.js 13 uses\n\t* {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}\n\t* to declare API routes instead of a generic catch-all method that was\n\t* available using the `pages/api` directory.\n\t*\n\t* This means that users must now export a function for each method supported\n\t* by the endpoint. For us, this means requiring a user explicitly exports\n\t* `GET`, `POST`, and `PUT` functions.\n\t*\n\t* Because of this, we'll add circular references to those property names of\n\t* the returned handler, meaning we can write some succinct code to export\n\t* them. Thanks, @goodoldneon.\n\t*\n\t* @example\n\t* ```ts\n\t* export const { GET, POST, PUT } = serve(...);\n\t* ```\n\t*\n\t* See {@link https://beta.nextjs.org/docs/routing/route-handlers}\n\t*/ const baseFn = new _components_InngestCommHandler_js__WEBPACK_IMPORTED_MODULE_0__.InngestCommHandler({\n        frameworkName,\n        ...options,\n        handler: (reqMethod, ...args)=>{\n            const [expectedReq, res] = args;\n            const req = expectedReq;\n            const getHeader = (key)=>{\n                const header = typeof req.headers.get === \"function\" ? req.headers.get(key) : req.headers[key];\n                return Array.isArray(header) ? header[0] : header;\n            };\n            return {\n                body: ()=>typeof req.json === \"function\" ? req.json() : req.body,\n                headers: getHeader,\n                method: ()=>{\n                    return reqMethod || req.method || \"\";\n                },\n                isProduction: ()=>{\n                    /**\n\t\t\t\t\t* Vercel Edge Functions do not allow dynamic access to environment\n\t\t\t\t\t* variables, so we'll manage production checks directly here.\n\t\t\t\t\t*\n\t\t\t\t\t* We try/catch to avoid situations where Next.js is being used in\n\t\t\t\t\t* environments where `process.env` is not accessible or polyfilled.\n\t\t\t\t\t*/ try {\n                        return \"development\" === \"production\";\n                    } catch (_err) {}\n                },\n                queryString: (key, url)=>{\n                    const qs = req.query?.[key] || url.searchParams.get(key);\n                    return Array.isArray(qs) ? qs[0] : qs;\n                },\n                url: ()=>{\n                    let absoluteUrl;\n                    try {\n                        absoluteUrl = new URL(req.url);\n                    } catch  {}\n                    if (absoluteUrl) {\n                        /**\n\t\t\t\t\t\t* `req.url` here should may be the full URL, including query string.\n\t\t\t\t\t\t* There are some caveats, however, where Next.js will obfuscate\n\t\t\t\t\t\t* the host. For example, in the case of `host.docker.internal`,\n\t\t\t\t\t\t* Next.js will instead set the host here to `localhost`.\n\t\t\t\t\t\t*\n\t\t\t\t\t\t* To avoid this, we'll try to parse the URL from `req.url`, but\n\t\t\t\t\t\t* also use the `host` header if it's available.\n\t\t\t\t\t\t*/ const host$1 = options.serveHost || getHeader(\"host\");\n                        if (host$1) {\n                            const hostWithProtocol = new URL(host$1.includes(\"://\") ? host$1 : `${absoluteUrl.protocol}//${host$1}`);\n                            absoluteUrl.protocol = hostWithProtocol.protocol;\n                            absoluteUrl.host = hostWithProtocol.host;\n                            absoluteUrl.port = hostWithProtocol.port;\n                            absoluteUrl.username = hostWithProtocol.username;\n                            absoluteUrl.password = hostWithProtocol.password;\n                        }\n                        return absoluteUrl;\n                    }\n                    let scheme = \"https\";\n                    const host = options.serveHost || getHeader(\"host\") || \"\";\n                    try {\n                        if (true) scheme = \"http\";\n                    } catch (_err) {}\n                    return new URL(req.url, `${scheme}://${host}`);\n                },\n                transformResponse: ({ body, headers, status })=>{\n                    /**\n\t\t\t\t\t* Carefully attempt to set headers and data on the response object\n\t\t\t\t\t* for Next.js 12 support.\n\t\t\t\t\t*\n\t\t\t\t\t* This also assumes that we're not using Next.js 15, where the `res`\n\t\t\t\t\t* object is repopulated as a `RouteContext` object. We expect these\n\t\t\t\t\t* methods to NOT be defined in Next.js 15.\n\t\t\t\t\t*\n\t\t\t\t\t* We could likely use `instanceof ServerResponse` to better check the\n\t\t\t\t\t* type of this, though Next.js 12 had issues with this due to not\n\t\t\t\t\t* instantiating the response correctly.\n\t\t\t\t\t*/ if (isNext12ApiResponse(res)) {\n                        for (const [key, value] of Object.entries(headers))res.setHeader(key, value);\n                        res.status(status);\n                        res.send(body);\n                        /**\n\t\t\t\t\t\t* If we're here, we're in a serverless endpoint (not edge), so\n\t\t\t\t\t\t* we've correctly sent the response and can return `undefined`.\n\t\t\t\t\t\t*\n\t\t\t\t\t\t* Next.js 13 edge requires that the return value is typed as\n\t\t\t\t\t\t* `Response`, so we still enforce that as we cannot dynamically\n\t\t\t\t\t\t* adjust typing based on the environment.\n\t\t\t\t\t\t*/ return;\n                    }\n                    return new ((0,_helpers_env_js__WEBPACK_IMPORTED_MODULE_1__.getResponse)())(body, {\n                        status,\n                        headers\n                    });\n                },\n                transformStreamingResponse: ({ body, headers, status })=>{\n                    return new Response(body, {\n                        status,\n                        headers\n                    });\n                }\n            };\n        }\n    }).createHandler();\n    const fn = baseFn.bind(null, void 0);\n    /**\n\t* Ensure we have a non-variadic length to avoid issues with forced type\n\t* checking.\n\t*/ Object.defineProperty(fn, \"length\", {\n        value: 1\n    });\n    return Object.defineProperties(fn, {\n        GET: {\n            value: baseFn.bind(null, \"GET\")\n        },\n        POST: {\n            value: baseFn.bind(null, \"POST\")\n        },\n        PUT: {\n            value: baseFn.bind(null, \"PUT\")\n        }\n    });\n};\n//#endregion\n //# sourceMappingURL=next.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9uZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0M7QUFDeUI7QUFFeEUscUJBQXFCO0FBQ3JCOzs7QUFHQSxHQUNBLE1BQU1FLGdCQUFnQjtBQUN0QixNQUFNQyxXQUFXLENBQUNDO0lBQ2pCLE9BQU8sT0FBT0EsUUFBUSxZQUFZQSxRQUFRO0FBQzNDO0FBQ0EsTUFBTUMsYUFBYSxDQUFDRDtJQUNuQixPQUFPLE9BQU9BLFFBQVE7QUFDdkI7QUFDQSxNQUFNRSxzQkFBc0IsQ0FBQ0Y7SUFDNUIsT0FBT0QsU0FBU0MsUUFBUUMsV0FBV0QsSUFBSUcsU0FBUyxLQUFLRixXQUFXRCxJQUFJSSxNQUFNLEtBQUtILFdBQVdELElBQUlLLElBQUk7QUFDbkc7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsR0FDQSxNQUFNQyxRQUFRLENBQUNDO0lBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JBLEdBQ0EsTUFBTUMsU0FBUyxJQUFJWCxpRkFBa0JBLENBQUM7UUFDckNDO1FBQ0EsR0FBR1MsT0FBTztRQUNWRSxTQUFTLENBQUNDLFdBQVcsR0FBR0M7WUFDdkIsTUFBTSxDQUFDQyxhQUFhQyxJQUFJLEdBQUdGO1lBQzNCLE1BQU1HLE1BQU1GO1lBQ1osTUFBTUcsWUFBWSxDQUFDQztnQkFDbEIsTUFBTUMsU0FBUyxPQUFPSCxJQUFJSSxPQUFPLENBQUNDLEdBQUcsS0FBSyxhQUFhTCxJQUFJSSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0gsT0FBT0YsSUFBSUksT0FBTyxDQUFDRixJQUFJO2dCQUM5RixPQUFPSSxNQUFNQyxPQUFPLENBQUNKLFVBQVVBLE1BQU0sQ0FBQyxFQUFFLEdBQUdBO1lBQzVDO1lBQ0EsT0FBTztnQkFDTkssTUFBTSxJQUFNLE9BQU9SLElBQUlTLElBQUksS0FBSyxhQUFhVCxJQUFJUyxJQUFJLEtBQUtULElBQUlRLElBQUk7Z0JBQ2xFSixTQUFTSDtnQkFDVFMsUUFBUTtvQkFDUCxPQUFPZCxhQUFhSSxJQUFJVSxNQUFNLElBQUk7Z0JBQ25DO2dCQUNBQyxjQUFjO29CQUNiOzs7Ozs7S0FNQSxHQUNBLElBQUk7d0JBQ0gsT0FBT0Msa0JBQXlCO29CQUNqQyxFQUFFLE9BQU9DLE1BQU0sQ0FBQztnQkFDakI7Z0JBQ0FDLGFBQWEsQ0FBQ1osS0FBS2E7b0JBQ2xCLE1BQU1DLEtBQUtoQixJQUFJaUIsS0FBSyxFQUFFLENBQUNmLElBQUksSUFBSWEsSUFBSUcsWUFBWSxDQUFDYixHQUFHLENBQUNIO29CQUNwRCxPQUFPSSxNQUFNQyxPQUFPLENBQUNTLE1BQU1BLEVBQUUsQ0FBQyxFQUFFLEdBQUdBO2dCQUNwQztnQkFDQUQsS0FBSztvQkFDSixJQUFJSTtvQkFDSixJQUFJO3dCQUNIQSxjQUFjLElBQUlDLElBQUlwQixJQUFJZSxHQUFHO29CQUM5QixFQUFFLE9BQU0sQ0FBQztvQkFDVCxJQUFJSSxhQUFhO3dCQUNoQjs7Ozs7Ozs7TUFRQSxHQUNBLE1BQU1FLFNBQVM1QixRQUFRNkIsU0FBUyxJQUFJckIsVUFBVTt3QkFDOUMsSUFBSW9CLFFBQVE7NEJBQ1gsTUFBTUUsbUJBQW1CLElBQUlILElBQUlDLE9BQU9HLFFBQVEsQ0FBQyxTQUFTSCxTQUFTLENBQUMsRUFBRUYsWUFBWU0sUUFBUSxDQUFDLEVBQUUsRUFBRUosT0FBTyxDQUFDOzRCQUN2R0YsWUFBWU0sUUFBUSxHQUFHRixpQkFBaUJFLFFBQVE7NEJBQ2hETixZQUFZTyxJQUFJLEdBQUdILGlCQUFpQkcsSUFBSTs0QkFDeENQLFlBQVlRLElBQUksR0FBR0osaUJBQWlCSSxJQUFJOzRCQUN4Q1IsWUFBWVMsUUFBUSxHQUFHTCxpQkFBaUJLLFFBQVE7NEJBQ2hEVCxZQUFZVSxRQUFRLEdBQUdOLGlCQUFpQk0sUUFBUTt3QkFDakQ7d0JBQ0EsT0FBT1Y7b0JBQ1I7b0JBQ0EsSUFBSVcsU0FBUztvQkFDYixNQUFNSixPQUFPakMsUUFBUTZCLFNBQVMsSUFBSXJCLFVBQVUsV0FBVztvQkFDdkQsSUFBSTt3QkFDSCxJQUFJVyxJQUFzQyxFQUFFa0IsU0FBUztvQkFDdEQsRUFBRSxPQUFPakIsTUFBTSxDQUFDO29CQUNoQixPQUFPLElBQUlPLElBQUlwQixJQUFJZSxHQUFHLEVBQUUsQ0FBQyxFQUFFZSxPQUFPLEdBQUcsRUFBRUosS0FBSyxDQUFDO2dCQUM5QztnQkFDQUssbUJBQW1CLENBQUMsRUFBRXZCLElBQUksRUFBRUosT0FBTyxFQUFFZCxNQUFNLEVBQUU7b0JBQzVDOzs7Ozs7Ozs7OztLQVdBLEdBQ0EsSUFBSUYsb0JBQW9CVyxNQUFNO3dCQUM3QixLQUFLLE1BQU0sQ0FBQ0csS0FBSzhCLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDOUIsU0FBVUwsSUFBSVYsU0FBUyxDQUFDYSxLQUFLOEI7d0JBQ3ZFakMsSUFBSVQsTUFBTSxDQUFDQTt3QkFDWFMsSUFBSVIsSUFBSSxDQUFDaUI7d0JBQ1Q7Ozs7Ozs7TUFPQSxHQUNBO29CQUNEO29CQUNBLE9BQU8sSUFBSzFCLENBQUFBLDREQUFXQSxFQUFDLEVBQUcwQixNQUFNO3dCQUNoQ2xCO3dCQUNBYztvQkFDRDtnQkFDRDtnQkFDQStCLDRCQUE0QixDQUFDLEVBQUUzQixJQUFJLEVBQUVKLE9BQU8sRUFBRWQsTUFBTSxFQUFFO29CQUNyRCxPQUFPLElBQUk4QyxTQUFTNUIsTUFBTTt3QkFDekJsQjt3QkFDQWM7b0JBQ0Q7Z0JBQ0Q7WUFDRDtRQUNEO0lBQ0QsR0FBR2lDLGFBQWE7SUFDaEIsTUFBTUMsS0FBSzVDLE9BQU82QyxJQUFJLENBQUMsTUFBTSxLQUFLO0lBQ2xDOzs7Q0FHQSxHQUNBTixPQUFPTyxjQUFjLENBQUNGLElBQUksVUFBVTtRQUFFTixPQUFPO0lBQUU7SUFDL0MsT0FBT0MsT0FBT1EsZ0JBQWdCLENBQUNILElBQUk7UUFDbENJLEtBQUs7WUFBRVYsT0FBT3RDLE9BQU82QyxJQUFJLENBQUMsTUFBTTtRQUFPO1FBQ3ZDSSxNQUFNO1lBQUVYLE9BQU90QyxPQUFPNkMsSUFBSSxDQUFDLE1BQU07UUFBUTtRQUN6Q0ssS0FBSztZQUFFWixPQUFPdEMsT0FBTzZDLElBQUksQ0FBQyxNQUFNO1FBQU87SUFDeEM7QUFDRDtBQUVBLFlBQVk7QUFDb0IsQ0FDaEMsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L25leHQuanM/MjVmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRSZXNwb25zZSB9IGZyb20gXCIuL2hlbHBlcnMvZW52LmpzXCI7XG5pbXBvcnQgeyBJbm5nZXN0Q29tbUhhbmRsZXIgfSBmcm9tIFwiLi9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qc1wiO1xuXG4vLyNyZWdpb24gc3JjL25leHQudHNcbi8qKlxuKiBUaGUgbmFtZSBvZiB0aGUgZnJhbWV3b3JrLCB1c2VkIHRvIGlkZW50aWZ5IHRoZSBmcmFtZXdvcmsgaW4gSW5uZ2VzdFxuKiBkYXNoYm9hcmRzIGFuZCBkdXJpbmcgdGVzdGluZy5cbiovXG5jb25zdCBmcmFtZXdvcmtOYW1lID0gXCJuZXh0anNcIjtcbmNvbnN0IGlzUmVjb3JkID0gKHZhbCkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGw7XG59O1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIjtcbn07XG5jb25zdCBpc05leHQxMkFwaVJlc3BvbnNlID0gKHZhbCkgPT4ge1xuXHRyZXR1cm4gaXNSZWNvcmQodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5zZXRIZWFkZXIpICYmIGlzRnVuY3Rpb24odmFsLnN0YXR1cykgJiYgaXNGdW5jdGlvbih2YWwuc2VuZCk7XG59O1xuLyoqXG4qIEluIE5leHQuanMsIHNlcnZlIGFuZCByZWdpc3RlciBhbnkgZGVjbGFyZWQgZnVuY3Rpb25zIHdpdGggSW5uZ2VzdCwgbWFraW5nXG4qIHRoZW0gYXZhaWxhYmxlIHRvIGJlIHRyaWdnZXJlZCBieSBldmVudHMuXG4qXG4qIFN1cHBvcnRzIE5leHQuanMgMTIrLCBib3RoIHNlcnZlcmxlc3MgYW5kIGVkZ2UuXG4qXG4qIEBleGFtcGxlIE5leHQuanMgPD0xMiBvciB0aGUgcGFnZXMgcm91dGVyIGNhbiBleHBvcnQgdGhlIGhhbmRsZXIgZGlyZWN0bHlcbiogYGBgdHNcbiogZXhwb3J0IGRlZmF1bHQgc2VydmUoeyBjbGllbnQ6IGlubmdlc3QsIGZ1bmN0aW9uczogW2ZuMSwgZm4yXSB9KTtcbiogYGBgXG4qXG4qIEBleGFtcGxlIE5leHQuanMgPj0xMyB3aXRoIHRoZSBgYXBwYCBkaXIgbXVzdCBleHBvcnQgaW5kaXZpZHVhbCBtZXRob2RzXG4qIGBgYHRzXG4qIGV4cG9ydCBjb25zdCB7IEdFVCwgUE9TVCwgUFVUIH0gPSBzZXJ2ZSh7XG4qICAgICAgICAgICAgY2xpZW50OiBpbm5nZXN0LFxuKiAgICAgICAgICAgIGZ1bmN0aW9uczogW2ZuMSwgZm4yXSxcbiogfSk7XG4qIGBgYFxuKlxuKiBAcHVibGljXG4qL1xuY29uc3Qgc2VydmUgPSAob3B0aW9ucykgPT4ge1xuXHQvKipcblx0KiBOZXh0LmpzIDEzIHVzZXNcblx0KiB7QGxpbmsgaHR0cHM6Ly9iZXRhLm5leHRqcy5vcmcvZG9jcy9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzIFJvdXRlIEhhbmRsZXJzfVxuXHQqIHRvIGRlY2xhcmUgQVBJIHJvdXRlcyBpbnN0ZWFkIG9mIGEgZ2VuZXJpYyBjYXRjaC1hbGwgbWV0aG9kIHRoYXQgd2FzXG5cdCogYXZhaWxhYmxlIHVzaW5nIHRoZSBgcGFnZXMvYXBpYCBkaXJlY3RvcnkuXG5cdCpcblx0KiBUaGlzIG1lYW5zIHRoYXQgdXNlcnMgbXVzdCBub3cgZXhwb3J0IGEgZnVuY3Rpb24gZm9yIGVhY2ggbWV0aG9kIHN1cHBvcnRlZFxuXHQqIGJ5IHRoZSBlbmRwb2ludC4gRm9yIHVzLCB0aGlzIG1lYW5zIHJlcXVpcmluZyBhIHVzZXIgZXhwbGljaXRseSBleHBvcnRzXG5cdCogYEdFVGAsIGBQT1NUYCwgYW5kIGBQVVRgIGZ1bmN0aW9ucy5cblx0KlxuXHQqIEJlY2F1c2Ugb2YgdGhpcywgd2UnbGwgYWRkIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gdGhvc2UgcHJvcGVydHkgbmFtZXMgb2Zcblx0KiB0aGUgcmV0dXJuZWQgaGFuZGxlciwgbWVhbmluZyB3ZSBjYW4gd3JpdGUgc29tZSBzdWNjaW5jdCBjb2RlIHRvIGV4cG9ydFxuXHQqIHRoZW0uIFRoYW5rcywgQGdvb2RvbGRuZW9uLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGV4cG9ydCBjb25zdCB7IEdFVCwgUE9TVCwgUFVUIH0gPSBzZXJ2ZSguLi4pO1xuXHQqIGBgYFxuXHQqXG5cdCogU2VlIHtAbGluayBodHRwczovL2JldGEubmV4dGpzLm9yZy9kb2NzL3JvdXRpbmcvcm91dGUtaGFuZGxlcnN9XG5cdCovXG5cdGNvbnN0IGJhc2VGbiA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXIoe1xuXHRcdGZyYW1ld29ya05hbWUsXG5cdFx0Li4ub3B0aW9ucyxcblx0XHRoYW5kbGVyOiAocmVxTWV0aG9kLCAuLi5hcmdzKSA9PiB7XG5cdFx0XHRjb25zdCBbZXhwZWN0ZWRSZXEsIHJlc10gPSBhcmdzO1xuXHRcdFx0Y29uc3QgcmVxID0gZXhwZWN0ZWRSZXE7XG5cdFx0XHRjb25zdCBnZXRIZWFkZXIgPSAoa2V5KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGhlYWRlciA9IHR5cGVvZiByZXEuaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIiA/IHJlcS5oZWFkZXJzLmdldChrZXkpIDogcmVxLmhlYWRlcnNba2V5XTtcblx0XHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlclswXSA6IGhlYWRlcjtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRib2R5OiAoKSA9PiB0eXBlb2YgcmVxLmpzb24gPT09IFwiZnVuY3Rpb25cIiA/IHJlcS5qc29uKCkgOiByZXEuYm9keSxcblx0XHRcdFx0aGVhZGVyczogZ2V0SGVhZGVyLFxuXHRcdFx0XHRtZXRob2Q6ICgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gcmVxTWV0aG9kIHx8IHJlcS5tZXRob2QgfHwgXCJcIjtcblx0XHRcdFx0fSxcblx0XHRcdFx0aXNQcm9kdWN0aW9uOiAoKSA9PiB7XG5cdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0KiBWZXJjZWwgRWRnZSBGdW5jdGlvbnMgZG8gbm90IGFsbG93IGR5bmFtaWMgYWNjZXNzIHRvIGVudmlyb25tZW50XG5cdFx0XHRcdFx0KiB2YXJpYWJsZXMsIHNvIHdlJ2xsIG1hbmFnZSBwcm9kdWN0aW9uIGNoZWNrcyBkaXJlY3RseSBoZXJlLlxuXHRcdFx0XHRcdCpcblx0XHRcdFx0XHQqIFdlIHRyeS9jYXRjaCB0byBhdm9pZCBzaXR1YXRpb25zIHdoZXJlIE5leHQuanMgaXMgYmVpbmcgdXNlZCBpblxuXHRcdFx0XHRcdCogZW52aXJvbm1lbnRzIHdoZXJlIGBwcm9jZXNzLmVudmAgaXMgbm90IGFjY2Vzc2libGUgb3IgcG9seWZpbGxlZC5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKF9lcnIpIHt9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHF1ZXJ5U3RyaW5nOiAoa2V5LCB1cmwpID0+IHtcblx0XHRcdFx0XHRjb25zdCBxcyA9IHJlcS5xdWVyeT8uW2tleV0gfHwgdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcblx0XHRcdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShxcykgPyBxc1swXSA6IHFzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cmw6ICgpID0+IHtcblx0XHRcdFx0XHRsZXQgYWJzb2x1dGVVcmw7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGFic29sdXRlVXJsID0gbmV3IFVSTChyZXEudXJsKTtcblx0XHRcdFx0XHR9IGNhdGNoIHt9XG5cdFx0XHRcdFx0aWYgKGFic29sdXRlVXJsKSB7XG5cdFx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHRcdCogYHJlcS51cmxgIGhlcmUgc2hvdWxkIG1heSBiZSB0aGUgZnVsbCBVUkwsIGluY2x1ZGluZyBxdWVyeSBzdHJpbmcuXG5cdFx0XHRcdFx0XHQqIFRoZXJlIGFyZSBzb21lIGNhdmVhdHMsIGhvd2V2ZXIsIHdoZXJlIE5leHQuanMgd2lsbCBvYmZ1c2NhdGVcblx0XHRcdFx0XHRcdCogdGhlIGhvc3QuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZSBvZiBgaG9zdC5kb2NrZXIuaW50ZXJuYWxgLFxuXHRcdFx0XHRcdFx0KiBOZXh0LmpzIHdpbGwgaW5zdGVhZCBzZXQgdGhlIGhvc3QgaGVyZSB0byBgbG9jYWxob3N0YC5cblx0XHRcdFx0XHRcdCpcblx0XHRcdFx0XHRcdCogVG8gYXZvaWQgdGhpcywgd2UnbGwgdHJ5IHRvIHBhcnNlIHRoZSBVUkwgZnJvbSBgcmVxLnVybGAsIGJ1dFxuXHRcdFx0XHRcdFx0KiBhbHNvIHVzZSB0aGUgYGhvc3RgIGhlYWRlciBpZiBpdCdzIGF2YWlsYWJsZS5cblx0XHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0XHRjb25zdCBob3N0JDEgPSBvcHRpb25zLnNlcnZlSG9zdCB8fCBnZXRIZWFkZXIoXCJob3N0XCIpO1xuXHRcdFx0XHRcdFx0aWYgKGhvc3QkMSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBob3N0V2l0aFByb3RvY29sID0gbmV3IFVSTChob3N0JDEuaW5jbHVkZXMoXCI6Ly9cIikgPyBob3N0JDEgOiBgJHthYnNvbHV0ZVVybC5wcm90b2NvbH0vLyR7aG9zdCQxfWApO1xuXHRcdFx0XHRcdFx0XHRhYnNvbHV0ZVVybC5wcm90b2NvbCA9IGhvc3RXaXRoUHJvdG9jb2wucHJvdG9jb2w7XG5cdFx0XHRcdFx0XHRcdGFic29sdXRlVXJsLmhvc3QgPSBob3N0V2l0aFByb3RvY29sLmhvc3Q7XG5cdFx0XHRcdFx0XHRcdGFic29sdXRlVXJsLnBvcnQgPSBob3N0V2l0aFByb3RvY29sLnBvcnQ7XG5cdFx0XHRcdFx0XHRcdGFic29sdXRlVXJsLnVzZXJuYW1lID0gaG9zdFdpdGhQcm90b2NvbC51c2VybmFtZTtcblx0XHRcdFx0XHRcdFx0YWJzb2x1dGVVcmwucGFzc3dvcmQgPSBob3N0V2l0aFByb3RvY29sLnBhc3N3b3JkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGFic29sdXRlVXJsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgc2NoZW1lID0gXCJodHRwc1wiO1xuXHRcdFx0XHRcdGNvbnN0IGhvc3QgPSBvcHRpb25zLnNlcnZlSG9zdCB8fCBnZXRIZWFkZXIoXCJob3N0XCIpIHx8IFwiXCI7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSBzY2hlbWUgPSBcImh0dHBcIjtcblx0XHRcdFx0XHR9IGNhdGNoIChfZXJyKSB7fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgVVJMKHJlcS51cmwsIGAke3NjaGVtZX06Ly8ke2hvc3R9YCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRyYW5zZm9ybVJlc3BvbnNlOiAoeyBib2R5LCBoZWFkZXJzLCBzdGF0dXMgfSkgPT4ge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCogQ2FyZWZ1bGx5IGF0dGVtcHQgdG8gc2V0IGhlYWRlcnMgYW5kIGRhdGEgb24gdGhlIHJlc3BvbnNlIG9iamVjdFxuXHRcdFx0XHRcdCogZm9yIE5leHQuanMgMTIgc3VwcG9ydC5cblx0XHRcdFx0XHQqXG5cdFx0XHRcdFx0KiBUaGlzIGFsc28gYXNzdW1lcyB0aGF0IHdlJ3JlIG5vdCB1c2luZyBOZXh0LmpzIDE1LCB3aGVyZSB0aGUgYHJlc2Bcblx0XHRcdFx0XHQqIG9iamVjdCBpcyByZXBvcHVsYXRlZCBhcyBhIGBSb3V0ZUNvbnRleHRgIG9iamVjdC4gV2UgZXhwZWN0IHRoZXNlXG5cdFx0XHRcdFx0KiBtZXRob2RzIHRvIE5PVCBiZSBkZWZpbmVkIGluIE5leHQuanMgMTUuXG5cdFx0XHRcdFx0KlxuXHRcdFx0XHRcdCogV2UgY291bGQgbGlrZWx5IHVzZSBgaW5zdGFuY2VvZiBTZXJ2ZXJSZXNwb25zZWAgdG8gYmV0dGVyIGNoZWNrIHRoZVxuXHRcdFx0XHRcdCogdHlwZSBvZiB0aGlzLCB0aG91Z2ggTmV4dC5qcyAxMiBoYWQgaXNzdWVzIHdpdGggdGhpcyBkdWUgdG8gbm90XG5cdFx0XHRcdFx0KiBpbnN0YW50aWF0aW5nIHRoZSByZXNwb25zZSBjb3JyZWN0bHkuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRpZiAoaXNOZXh0MTJBcGlSZXNwb25zZShyZXMpKSB7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkgcmVzLnNldEhlYWRlcihrZXksIHZhbHVlKTtcblx0XHRcdFx0XHRcdHJlcy5zdGF0dXMoc3RhdHVzKTtcblx0XHRcdFx0XHRcdHJlcy5zZW5kKGJvZHkpO1xuXHRcdFx0XHRcdFx0LyoqXG5cdFx0XHRcdFx0XHQqIElmIHdlJ3JlIGhlcmUsIHdlJ3JlIGluIGEgc2VydmVybGVzcyBlbmRwb2ludCAobm90IGVkZ2UpLCBzb1xuXHRcdFx0XHRcdFx0KiB3ZSd2ZSBjb3JyZWN0bHkgc2VudCB0aGUgcmVzcG9uc2UgYW5kIGNhbiByZXR1cm4gYHVuZGVmaW5lZGAuXG5cdFx0XHRcdFx0XHQqXG5cdFx0XHRcdFx0XHQqIE5leHQuanMgMTMgZWRnZSByZXF1aXJlcyB0aGF0IHRoZSByZXR1cm4gdmFsdWUgaXMgdHlwZWQgYXNcblx0XHRcdFx0XHRcdCogYFJlc3BvbnNlYCwgc28gd2Ugc3RpbGwgZW5mb3JjZSB0aGF0IGFzIHdlIGNhbm5vdCBkeW5hbWljYWxseVxuXHRcdFx0XHRcdFx0KiBhZGp1c3QgdHlwaW5nIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudC5cblx0XHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgKGdldFJlc3BvbnNlKCkpKGJvZHksIHtcblx0XHRcdFx0XHRcdHN0YXR1cyxcblx0XHRcdFx0XHRcdGhlYWRlcnNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dHJhbnNmb3JtU3RyZWFtaW5nUmVzcG9uc2U6ICh7IGJvZHksIGhlYWRlcnMsIHN0YXR1cyB9KSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCB7XG5cdFx0XHRcdFx0XHRzdGF0dXMsXG5cdFx0XHRcdFx0XHRoZWFkZXJzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9KS5jcmVhdGVIYW5kbGVyKCk7XG5cdGNvbnN0IGZuID0gYmFzZUZuLmJpbmQobnVsbCwgdm9pZCAwKTtcblx0LyoqXG5cdCogRW5zdXJlIHdlIGhhdmUgYSBub24tdmFyaWFkaWMgbGVuZ3RoIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGZvcmNlZCB0eXBlXG5cdCogY2hlY2tpbmcuXG5cdCovXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJsZW5ndGhcIiwgeyB2YWx1ZTogMSB9KTtcblx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGZuLCB7XG5cdFx0R0VUOiB7IHZhbHVlOiBiYXNlRm4uYmluZChudWxsLCBcIkdFVFwiKSB9LFxuXHRcdFBPU1Q6IHsgdmFsdWU6IGJhc2VGbi5iaW5kKG51bGwsIFwiUE9TVFwiKSB9LFxuXHRcdFBVVDogeyB2YWx1ZTogYmFzZUZuLmJpbmQobnVsbCwgXCJQVVRcIikgfVxuXHR9KTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgZnJhbWV3b3JrTmFtZSwgc2VydmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5leHQuanMubWFwIl0sIm5hbWVzIjpbImdldFJlc3BvbnNlIiwiSW5uZ2VzdENvbW1IYW5kbGVyIiwiZnJhbWV3b3JrTmFtZSIsImlzUmVjb3JkIiwidmFsIiwiaXNGdW5jdGlvbiIsImlzTmV4dDEyQXBpUmVzcG9uc2UiLCJzZXRIZWFkZXIiLCJzdGF0dXMiLCJzZW5kIiwic2VydmUiLCJvcHRpb25zIiwiYmFzZUZuIiwiaGFuZGxlciIsInJlcU1ldGhvZCIsImFyZ3MiLCJleHBlY3RlZFJlcSIsInJlcyIsInJlcSIsImdldEhlYWRlciIsImtleSIsImhlYWRlciIsImhlYWRlcnMiLCJnZXQiLCJBcnJheSIsImlzQXJyYXkiLCJib2R5IiwianNvbiIsIm1ldGhvZCIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJfZXJyIiwicXVlcnlTdHJpbmciLCJ1cmwiLCJxcyIsInF1ZXJ5Iiwic2VhcmNoUGFyYW1zIiwiYWJzb2x1dGVVcmwiLCJVUkwiLCJob3N0JDEiLCJzZXJ2ZUhvc3QiLCJob3N0V2l0aFByb3RvY29sIiwiaW5jbHVkZXMiLCJwcm90b2NvbCIsImhvc3QiLCJwb3J0IiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInNjaGVtZSIsInRyYW5zZm9ybVJlc3BvbnNlIiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidHJhbnNmb3JtU3RyZWFtaW5nUmVzcG9uc2UiLCJSZXNwb25zZSIsImNyZWF0ZUhhbmRsZXIiLCJmbiIsImJpbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImRlZmluZVByb3BlcnRpZXMiLCJHRVQiLCJQT1NUIiwiUFVUIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/next.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/types.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/types.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncResponseType: () => (/* binding */ AsyncResponseType),\n/* harmony export */   StepMode: () => (/* binding */ StepMode),\n/* harmony export */   StepOpCode: () => (/* binding */ StepOpCode),\n/* harmony export */   err: () => (/* binding */ err),\n/* harmony export */   functionConfigSchema: () => (/* binding */ functionConfigSchema),\n/* harmony export */   inBandSyncRequestBodySchema: () => (/* binding */ inBandSyncRequestBodySchema),\n/* harmony export */   incomingOpSchema: () => (/* binding */ incomingOpSchema),\n/* harmony export */   jsonErrorSchema: () => (/* binding */ jsonErrorSchema),\n/* harmony export */   logLevels: () => (/* binding */ logLevels),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   sendEventResponseSchema: () => (/* binding */ sendEventResponseSchema),\n/* harmony export */   types_exports: () => (/* binding */ types_exports)\n/* harmony export */ });\n/* harmony import */ var _virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_virtual/rolldown_runtime.js */ \"(rsc)/./node_modules/inngest/_virtual/rolldown_runtime.js\");\n/* harmony import */ var zod_v3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod/v3 */ \"(rsc)/./node_modules/zod/v3/types.js\");\n\n\n//#region src/types.ts\n/**\n* Internal types and schemas used throughout the Inngest SDK.\n*\n* Note that types intended to be imported and utilized in userland code will be\n* exported from the main entrypoint of the SDK, `inngest`; importing types\n* directly from this file may result in breaking changes in non-major bumps as\n* only those exported from `inngest` are considered stable.\n*\n* @module\n*/ var types_exports = /* @__PURE__ */ (0,_virtual_rolldown_runtime_js__WEBPACK_IMPORTED_MODULE_0__.__export)({\n    AsyncResponseType: ()=>AsyncResponseType,\n    StepMode: ()=>StepMode,\n    StepOpCode: ()=>StepOpCode,\n    err: ()=>err,\n    functionConfigSchema: ()=>functionConfigSchema,\n    inBandSyncRequestBodySchema: ()=>inBandSyncRequestBodySchema,\n    incomingOpSchema: ()=>incomingOpSchema,\n    jsonErrorSchema: ()=>jsonErrorSchema,\n    logLevels: ()=>logLevels,\n    ok: ()=>ok,\n    sendEventResponseSchema: ()=>sendEventResponseSchema\n});\nconst baseJsonErrorSchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.object({\n    name: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim().optional(),\n    error: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim().optional(),\n    message: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim().optional(),\n    stack: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim().optional()\n});\nconst maybeJsonErrorSchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.lazy(()=>zod_v3__WEBPACK_IMPORTED_MODULE_1__.object({\n        name: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim(),\n        message: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim(),\n        stack: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().trim().optional(),\n        cause: zod_v3__WEBPACK_IMPORTED_MODULE_1__.union([\n            maybeJsonErrorSchema,\n            zod_v3__WEBPACK_IMPORTED_MODULE_1__.unknown()\n        ]).optional()\n    }));\nconst jsonErrorSchema = baseJsonErrorSchema.extend({\n    cause: zod_v3__WEBPACK_IMPORTED_MODULE_1__.union([\n        maybeJsonErrorSchema,\n        zod_v3__WEBPACK_IMPORTED_MODULE_1__.unknown()\n    ]).optional()\n}).passthrough().catch({}).transform((val)=>{\n    return {\n        ...val,\n        name: val.name || \"Error\",\n        message: val.message || val.error || \"Unknown error\",\n        stack: val.stack\n    };\n});\n/**\n* Unique codes for the different types of operation that can be sent to Inngest\n* from SDK step functions.\n*/ let StepOpCode = /* @__PURE__ */ function(StepOpCode$1) {\n    StepOpCode$1[\"WaitForSignal\"] = \"WaitForSignal\";\n    StepOpCode$1[\"WaitForEvent\"] = \"WaitForEvent\";\n    /**\n\t* Legacy equivalent to `\"StepRun\"`. Has mixed data wrapping (e.g. `data` or\n\t* `data.data` depending on SDK version), so this is phased out in favour of\n\t* `\"StepRun\"`, which never wraps.\n\t*\n\t* Note that it is still used for v0 executions for backwards compatibility.\n\t*\n\t* @deprecated Only used for v0 executions; use `\"StepRun\"` instead.\n\t*/ StepOpCode$1[\"Step\"] = \"Step\";\n    StepOpCode$1[\"StepRun\"] = \"StepRun\";\n    StepOpCode$1[\"StepError\"] = \"StepError\";\n    StepOpCode$1[\"StepFailed\"] = \"StepFailed\";\n    StepOpCode$1[\"StepPlanned\"] = \"StepPlanned\";\n    StepOpCode$1[\"Sleep\"] = \"Sleep\";\n    /**\n\t* Used to signify that the executor has requested that a step run, but we\n\t* could not find that step.\n\t*\n\t* This is likely indicative that a step was renamed or removed from the\n\t* function.\n\t*/ StepOpCode$1[\"StepNotFound\"] = \"StepNotFound\";\n    StepOpCode$1[\"InvokeFunction\"] = \"InvokeFunction\";\n    StepOpCode$1[\"AiGateway\"] = \"AIGateway\";\n    StepOpCode$1[\"Gateway\"] = \"Gateway\";\n    StepOpCode$1[\"RunComplete\"] = \"RunComplete\";\n    return StepOpCode$1;\n}({});\n/**\n* StepModes are used to specify how the SDK should execute a function.\n*/ let StepMode = /* @__PURE__ */ function(StepMode$1) {\n    /**\n\t* A synchronous method of execution, where steps are executed immediately and\n\t* their results are \"checkpointed\" back to Inngest in real-time.\n\t*/ StepMode$1[\"Sync\"] = \"sync\";\n    /**\n\t* The traditional, background method of execution, where all steps are queued\n\t* and executed asynchronously and always triggered by Inngest.\n\t*/ StepMode$1[\"Async\"] = \"async\";\n    return StepMode$1;\n}({});\n/**\n* The type of response you wish to return to an API endpoint when using steps\n* within it and we must transition to {@link StepMode.Async}.\n*\n* In most cases, this defaults to {@link AsyncResponseType.Redirect}.\n*/ let AsyncResponseType = /* @__PURE__ */ function(AsyncResponseType$1) {\n    /**\n\t* When switching to {@link StepMode.Async}, respond with a 302 redirect which\n\t* will end the request once the run has completed asynchronously in the\n\t* background.\n\t*/ AsyncResponseType$1[\"Redirect\"] = \"redirect\";\n    /**\n\t* When switching to {@link StepMode.Async}, respond with a token and run ID\n\t* which can be used to poll for the status of the run.\n\t*/ AsyncResponseType$1[\"Token\"] = \"token\";\n    return AsyncResponseType$1;\n/**\n\t* TODO Comment\n\t*/ }({});\nconst incomingOpSchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.object({\n    id: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().min(1),\n    data: zod_v3__WEBPACK_IMPORTED_MODULE_1__.any().optional(),\n    error: zod_v3__WEBPACK_IMPORTED_MODULE_1__.any().optional(),\n    input: zod_v3__WEBPACK_IMPORTED_MODULE_1__.any().optional()\n});\nconst sendEventResponseSchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.object({\n    ids: zod_v3__WEBPACK_IMPORTED_MODULE_1__.array(zod_v3__WEBPACK_IMPORTED_MODULE_1__.string()).default([]),\n    status: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number().default(0),\n    error: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n});\n/**\n* A set of log levels that can be used to control the amount of logging output\n* from various parts of the Inngest library.\n*\n* @public\n*/ const logLevels = [\n    \"fatal\",\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"debug\",\n    \"silent\"\n];\n/**\n* This schema is used internally to share the shape of a concurrency option\n* when validating config. We cannot add comments to Zod fields, so we just use\n* an extra type check to ensure it matches our exported expectations.\n*/ const concurrencyOptionSchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n    limit: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number(),\n    key: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n    scope: zod_v3__WEBPACK_IMPORTED_MODULE_1__[\"enum\"]([\n        \"fn\",\n        \"env\",\n        \"account\"\n    ]).optional()\n});\n/**\n* The schema used to represent an individual function being synced with\n* Inngest.\n*\n* Note that this should only be used to validate the shape of a config object\n* and not used for feature compatibility, such as feature X being exclusive\n* with feature Y; these should be handled on the Inngest side.\n*/ const functionConfigSchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n    name: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n    id: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string(),\n    triggers: zod_v3__WEBPACK_IMPORTED_MODULE_1__.array(zod_v3__WEBPACK_IMPORTED_MODULE_1__.union([\n        zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n            event: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string(),\n            expression: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n        }),\n        zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n            cron: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string()\n        })\n    ])),\n    steps: zod_v3__WEBPACK_IMPORTED_MODULE_1__.record(zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        id: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string(),\n        name: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string(),\n        runtime: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n            type: zod_v3__WEBPACK_IMPORTED_MODULE_1__.union([\n                zod_v3__WEBPACK_IMPORTED_MODULE_1__.literal(\"http\"),\n                zod_v3__WEBPACK_IMPORTED_MODULE_1__.literal(\"ws\")\n            ]),\n            url: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string()\n        }),\n        retries: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n            attempts: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number().optional()\n        }).optional()\n    })),\n    idempotency: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n    batchEvents: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        maxSize: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number(),\n        timeout: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string(),\n        key: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n        if: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n    }).optional(),\n    rateLimit: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        key: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n        limit: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number(),\n        period: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().transform((x)=>x)\n    }).optional(),\n    throttle: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        key: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n        limit: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number(),\n        period: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().transform((x)=>x),\n        burst: zod_v3__WEBPACK_IMPORTED_MODULE_1__.number().optional()\n    }).optional(),\n    singleton: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        key: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n        mode: zod_v3__WEBPACK_IMPORTED_MODULE_1__[\"enum\"]([\n            \"skip\",\n            \"cancel\"\n        ])\n    }).optional(),\n    cancel: zod_v3__WEBPACK_IMPORTED_MODULE_1__.array(zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        event: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string(),\n        if: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n        timeout: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n    })).optional(),\n    debounce: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        key: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional(),\n        period: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().transform((x)=>x),\n        timeout: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().transform((x)=>x).optional()\n    }).optional(),\n    timeouts: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        start: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().transform((x)=>x).optional(),\n        finish: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().transform((x)=>x).optional()\n    }).optional(),\n    priority: zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n        run: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string().optional()\n    }).optional(),\n    concurrency: zod_v3__WEBPACK_IMPORTED_MODULE_1__.union([\n        zod_v3__WEBPACK_IMPORTED_MODULE_1__.number(),\n        concurrencyOptionSchema.transform((x)=>x),\n        zod_v3__WEBPACK_IMPORTED_MODULE_1__.array(concurrencyOptionSchema.transform((x)=>x)).min(1).max(2)\n    ]).optional()\n});\nconst ok = (data)=>{\n    return {\n        ok: true,\n        value: data\n    };\n};\nconst err = (error)=>{\n    return {\n        ok: false,\n        error\n    };\n};\nconst inBandSyncRequestBodySchema = zod_v3__WEBPACK_IMPORTED_MODULE_1__.strictObject({\n    url: zod_v3__WEBPACK_IMPORTED_MODULE_1__.string()\n});\n//#endregion\n //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNKUTtJQUNEO0FBQ0Q7QUFDQSxNQUFNWiw4QkFBOEJQLGdEQUFjLENBQUM7SUFBRTRELEtBQUs1RCwwQ0FBUTtBQUFHO0FBRXJFLFlBQVk7QUFDeUwsQ0FDck0saUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L3R5cGVzLmpzPzcyZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHBvcnQgfSBmcm9tIFwiLi9fdmlydHVhbC9yb2xsZG93bl9ydW50aW1lLmpzXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZC92M1wiO1xuXG4vLyNyZWdpb24gc3JjL3R5cGVzLnRzXG4vKipcbiogSW50ZXJuYWwgdHlwZXMgYW5kIHNjaGVtYXMgdXNlZCB0aHJvdWdob3V0IHRoZSBJbm5nZXN0IFNESy5cbipcbiogTm90ZSB0aGF0IHR5cGVzIGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGFuZCB1dGlsaXplZCBpbiB1c2VybGFuZCBjb2RlIHdpbGwgYmVcbiogZXhwb3J0ZWQgZnJvbSB0aGUgbWFpbiBlbnRyeXBvaW50IG9mIHRoZSBTREssIGBpbm5nZXN0YDsgaW1wb3J0aW5nIHR5cGVzXG4qIGRpcmVjdGx5IGZyb20gdGhpcyBmaWxlIG1heSByZXN1bHQgaW4gYnJlYWtpbmcgY2hhbmdlcyBpbiBub24tbWFqb3IgYnVtcHMgYXNcbiogb25seSB0aG9zZSBleHBvcnRlZCBmcm9tIGBpbm5nZXN0YCBhcmUgY29uc2lkZXJlZCBzdGFibGUuXG4qXG4qIEBtb2R1bGVcbiovXG52YXIgdHlwZXNfZXhwb3J0cyA9IC8qIEBfX1BVUkVfXyAqLyBfX2V4cG9ydCh7XG5cdEFzeW5jUmVzcG9uc2VUeXBlOiAoKSA9PiBBc3luY1Jlc3BvbnNlVHlwZSxcblx0U3RlcE1vZGU6ICgpID0+IFN0ZXBNb2RlLFxuXHRTdGVwT3BDb2RlOiAoKSA9PiBTdGVwT3BDb2RlLFxuXHRlcnI6ICgpID0+IGVycixcblx0ZnVuY3Rpb25Db25maWdTY2hlbWE6ICgpID0+IGZ1bmN0aW9uQ29uZmlnU2NoZW1hLFxuXHRpbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWE6ICgpID0+IGluQmFuZFN5bmNSZXF1ZXN0Qm9keVNjaGVtYSxcblx0aW5jb21pbmdPcFNjaGVtYTogKCkgPT4gaW5jb21pbmdPcFNjaGVtYSxcblx0anNvbkVycm9yU2NoZW1hOiAoKSA9PiBqc29uRXJyb3JTY2hlbWEsXG5cdGxvZ0xldmVsczogKCkgPT4gbG9nTGV2ZWxzLFxuXHRvazogKCkgPT4gb2ssXG5cdHNlbmRFdmVudFJlc3BvbnNlU2NoZW1hOiAoKSA9PiBzZW5kRXZlbnRSZXNwb25zZVNjaGVtYVxufSk7XG5jb25zdCBiYXNlSnNvbkVycm9yU2NoZW1hID0gei5vYmplY3Qoe1xuXHRuYW1lOiB6LnN0cmluZygpLnRyaW0oKS5vcHRpb25hbCgpLFxuXHRlcnJvcjogei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcblx0bWVzc2FnZTogei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcblx0c3RhY2s6IHouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3QgbWF5YmVKc29uRXJyb3JTY2hlbWEgPSB6LmxhenkoKCkgPT4gei5vYmplY3Qoe1xuXHRuYW1lOiB6LnN0cmluZygpLnRyaW0oKSxcblx0bWVzc2FnZTogei5zdHJpbmcoKS50cmltKCksXG5cdHN0YWNrOiB6LnN0cmluZygpLnRyaW0oKS5vcHRpb25hbCgpLFxuXHRjYXVzZTogei51bmlvbihbbWF5YmVKc29uRXJyb3JTY2hlbWEsIHoudW5rbm93bigpXSkub3B0aW9uYWwoKVxufSkpO1xuY29uc3QganNvbkVycm9yU2NoZW1hID0gYmFzZUpzb25FcnJvclNjaGVtYS5leHRlbmQoeyBjYXVzZTogei51bmlvbihbbWF5YmVKc29uRXJyb3JTY2hlbWEsIHoudW5rbm93bigpXSkub3B0aW9uYWwoKSB9KS5wYXNzdGhyb3VnaCgpLmNhdGNoKHt9KS50cmFuc2Zvcm0oKHZhbCkgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdC4uLnZhbCxcblx0XHRuYW1lOiB2YWwubmFtZSB8fCBcIkVycm9yXCIsXG5cdFx0bWVzc2FnZTogdmFsLm1lc3NhZ2UgfHwgdmFsLmVycm9yIHx8IFwiVW5rbm93biBlcnJvclwiLFxuXHRcdHN0YWNrOiB2YWwuc3RhY2tcblx0fTtcbn0pO1xuLyoqXG4qIFVuaXF1ZSBjb2RlcyBmb3IgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBvcGVyYXRpb24gdGhhdCBjYW4gYmUgc2VudCB0byBJbm5nZXN0XG4qIGZyb20gU0RLIHN0ZXAgZnVuY3Rpb25zLlxuKi9cbmxldCBTdGVwT3BDb2RlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFN0ZXBPcENvZGUkMSkge1xuXHRTdGVwT3BDb2RlJDFbXCJXYWl0Rm9yU2lnbmFsXCJdID0gXCJXYWl0Rm9yU2lnbmFsXCI7XG5cdFN0ZXBPcENvZGUkMVtcIldhaXRGb3JFdmVudFwiXSA9IFwiV2FpdEZvckV2ZW50XCI7XG5cdC8qKlxuXHQqIExlZ2FjeSBlcXVpdmFsZW50IHRvIGBcIlN0ZXBSdW5cImAuIEhhcyBtaXhlZCBkYXRhIHdyYXBwaW5nIChlLmcuIGBkYXRhYCBvclxuXHQqIGBkYXRhLmRhdGFgIGRlcGVuZGluZyBvbiBTREsgdmVyc2lvbiksIHNvIHRoaXMgaXMgcGhhc2VkIG91dCBpbiBmYXZvdXIgb2Zcblx0KiBgXCJTdGVwUnVuXCJgLCB3aGljaCBuZXZlciB3cmFwcy5cblx0KlxuXHQqIE5vdGUgdGhhdCBpdCBpcyBzdGlsbCB1c2VkIGZvciB2MCBleGVjdXRpb25zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0KlxuXHQqIEBkZXByZWNhdGVkIE9ubHkgdXNlZCBmb3IgdjAgZXhlY3V0aW9uczsgdXNlIGBcIlN0ZXBSdW5cImAgaW5zdGVhZC5cblx0Ki9cblx0U3RlcE9wQ29kZSQxW1wiU3RlcFwiXSA9IFwiU3RlcFwiO1xuXHRTdGVwT3BDb2RlJDFbXCJTdGVwUnVuXCJdID0gXCJTdGVwUnVuXCI7XG5cdFN0ZXBPcENvZGUkMVtcIlN0ZXBFcnJvclwiXSA9IFwiU3RlcEVycm9yXCI7XG5cdFN0ZXBPcENvZGUkMVtcIlN0ZXBGYWlsZWRcIl0gPSBcIlN0ZXBGYWlsZWRcIjtcblx0U3RlcE9wQ29kZSQxW1wiU3RlcFBsYW5uZWRcIl0gPSBcIlN0ZXBQbGFubmVkXCI7XG5cdFN0ZXBPcENvZGUkMVtcIlNsZWVwXCJdID0gXCJTbGVlcFwiO1xuXHQvKipcblx0KiBVc2VkIHRvIHNpZ25pZnkgdGhhdCB0aGUgZXhlY3V0b3IgaGFzIHJlcXVlc3RlZCB0aGF0IGEgc3RlcCBydW4sIGJ1dCB3ZVxuXHQqIGNvdWxkIG5vdCBmaW5kIHRoYXQgc3RlcC5cblx0KlxuXHQqIFRoaXMgaXMgbGlrZWx5IGluZGljYXRpdmUgdGhhdCBhIHN0ZXAgd2FzIHJlbmFtZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZVxuXHQqIGZ1bmN0aW9uLlxuXHQqL1xuXHRTdGVwT3BDb2RlJDFbXCJTdGVwTm90Rm91bmRcIl0gPSBcIlN0ZXBOb3RGb3VuZFwiO1xuXHRTdGVwT3BDb2RlJDFbXCJJbnZva2VGdW5jdGlvblwiXSA9IFwiSW52b2tlRnVuY3Rpb25cIjtcblx0U3RlcE9wQ29kZSQxW1wiQWlHYXRld2F5XCJdID0gXCJBSUdhdGV3YXlcIjtcblx0U3RlcE9wQ29kZSQxW1wiR2F0ZXdheVwiXSA9IFwiR2F0ZXdheVwiO1xuXHRTdGVwT3BDb2RlJDFbXCJSdW5Db21wbGV0ZVwiXSA9IFwiUnVuQ29tcGxldGVcIjtcblx0cmV0dXJuIFN0ZXBPcENvZGUkMTtcbn0oe30pO1xuLyoqXG4qIFN0ZXBNb2RlcyBhcmUgdXNlZCB0byBzcGVjaWZ5IGhvdyB0aGUgU0RLIHNob3VsZCBleGVjdXRlIGEgZnVuY3Rpb24uXG4qL1xubGV0IFN0ZXBNb2RlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFN0ZXBNb2RlJDEpIHtcblx0LyoqXG5cdCogQSBzeW5jaHJvbm91cyBtZXRob2Qgb2YgZXhlY3V0aW9uLCB3aGVyZSBzdGVwcyBhcmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgYW5kXG5cdCogdGhlaXIgcmVzdWx0cyBhcmUgXCJjaGVja3BvaW50ZWRcIiBiYWNrIHRvIElubmdlc3QgaW4gcmVhbC10aW1lLlxuXHQqL1xuXHRTdGVwTW9kZSQxW1wiU3luY1wiXSA9IFwic3luY1wiO1xuXHQvKipcblx0KiBUaGUgdHJhZGl0aW9uYWwsIGJhY2tncm91bmQgbWV0aG9kIG9mIGV4ZWN1dGlvbiwgd2hlcmUgYWxsIHN0ZXBzIGFyZSBxdWV1ZWRcblx0KiBhbmQgZXhlY3V0ZWQgYXN5bmNocm9ub3VzbHkgYW5kIGFsd2F5cyB0cmlnZ2VyZWQgYnkgSW5uZ2VzdC5cblx0Ki9cblx0U3RlcE1vZGUkMVtcIkFzeW5jXCJdID0gXCJhc3luY1wiO1xuXHRyZXR1cm4gU3RlcE1vZGUkMTtcbn0oe30pO1xuLyoqXG4qIFRoZSB0eXBlIG9mIHJlc3BvbnNlIHlvdSB3aXNoIHRvIHJldHVybiB0byBhbiBBUEkgZW5kcG9pbnQgd2hlbiB1c2luZyBzdGVwc1xuKiB3aXRoaW4gaXQgYW5kIHdlIG11c3QgdHJhbnNpdGlvbiB0byB7QGxpbmsgU3RlcE1vZGUuQXN5bmN9LlxuKlxuKiBJbiBtb3N0IGNhc2VzLCB0aGlzIGRlZmF1bHRzIHRvIHtAbGluayBBc3luY1Jlc3BvbnNlVHlwZS5SZWRpcmVjdH0uXG4qL1xubGV0IEFzeW5jUmVzcG9uc2VUeXBlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKEFzeW5jUmVzcG9uc2VUeXBlJDEpIHtcblx0LyoqXG5cdCogV2hlbiBzd2l0Y2hpbmcgdG8ge0BsaW5rIFN0ZXBNb2RlLkFzeW5jfSwgcmVzcG9uZCB3aXRoIGEgMzAyIHJlZGlyZWN0IHdoaWNoXG5cdCogd2lsbCBlbmQgdGhlIHJlcXVlc3Qgb25jZSB0aGUgcnVuIGhhcyBjb21wbGV0ZWQgYXN5bmNocm9ub3VzbHkgaW4gdGhlXG5cdCogYmFja2dyb3VuZC5cblx0Ki9cblx0QXN5bmNSZXNwb25zZVR5cGUkMVtcIlJlZGlyZWN0XCJdID0gXCJyZWRpcmVjdFwiO1xuXHQvKipcblx0KiBXaGVuIHN3aXRjaGluZyB0byB7QGxpbmsgU3RlcE1vZGUuQXN5bmN9LCByZXNwb25kIHdpdGggYSB0b2tlbiBhbmQgcnVuIElEXG5cdCogd2hpY2ggY2FuIGJlIHVzZWQgdG8gcG9sbCBmb3IgdGhlIHN0YXR1cyBvZiB0aGUgcnVuLlxuXHQqL1xuXHRBc3luY1Jlc3BvbnNlVHlwZSQxW1wiVG9rZW5cIl0gPSBcInRva2VuXCI7XG5cdHJldHVybiBBc3luY1Jlc3BvbnNlVHlwZSQxO1xuXHQvKipcblx0KiBUT0RPIENvbW1lbnRcblx0Ki9cbn0oe30pO1xuY29uc3QgaW5jb21pbmdPcFNjaGVtYSA9IHoub2JqZWN0KHtcblx0aWQ6IHouc3RyaW5nKCkubWluKDEpLFxuXHRkYXRhOiB6LmFueSgpLm9wdGlvbmFsKCksXG5cdGVycm9yOiB6LmFueSgpLm9wdGlvbmFsKCksXG5cdGlucHV0OiB6LmFueSgpLm9wdGlvbmFsKClcbn0pO1xuY29uc3Qgc2VuZEV2ZW50UmVzcG9uc2VTY2hlbWEgPSB6Lm9iamVjdCh7XG5cdGlkczogei5hcnJheSh6LnN0cmluZygpKS5kZWZhdWx0KFtdKSxcblx0c3RhdHVzOiB6Lm51bWJlcigpLmRlZmF1bHQoMCksXG5cdGVycm9yOiB6LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuLyoqXG4qIEEgc2V0IG9mIGxvZyBsZXZlbHMgdGhhdCBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBhbW91bnQgb2YgbG9nZ2luZyBvdXRwdXRcbiogZnJvbSB2YXJpb3VzIHBhcnRzIG9mIHRoZSBJbm5nZXN0IGxpYnJhcnkuXG4qXG4qIEBwdWJsaWNcbiovXG5jb25zdCBsb2dMZXZlbHMgPSBbXG5cdFwiZmF0YWxcIixcblx0XCJlcnJvclwiLFxuXHRcIndhcm5cIixcblx0XCJpbmZvXCIsXG5cdFwiZGVidWdcIixcblx0XCJzaWxlbnRcIlxuXTtcbi8qKlxuKiBUaGlzIHNjaGVtYSBpcyB1c2VkIGludGVybmFsbHkgdG8gc2hhcmUgdGhlIHNoYXBlIG9mIGEgY29uY3VycmVuY3kgb3B0aW9uXG4qIHdoZW4gdmFsaWRhdGluZyBjb25maWcuIFdlIGNhbm5vdCBhZGQgY29tbWVudHMgdG8gWm9kIGZpZWxkcywgc28gd2UganVzdCB1c2VcbiogYW4gZXh0cmEgdHlwZSBjaGVjayB0byBlbnN1cmUgaXQgbWF0Y2hlcyBvdXIgZXhwb3J0ZWQgZXhwZWN0YXRpb25zLlxuKi9cbmNvbnN0IGNvbmN1cnJlbmN5T3B0aW9uU2NoZW1hID0gei5zdHJpY3RPYmplY3Qoe1xuXHRsaW1pdDogei5udW1iZXIoKSxcblx0a2V5OiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG5cdHNjb3BlOiB6LmVudW0oW1xuXHRcdFwiZm5cIixcblx0XHRcImVudlwiLFxuXHRcdFwiYWNjb3VudFwiXG5cdF0pLm9wdGlvbmFsKClcbn0pO1xuLyoqXG4qIFRoZSBzY2hlbWEgdXNlZCB0byByZXByZXNlbnQgYW4gaW5kaXZpZHVhbCBmdW5jdGlvbiBiZWluZyBzeW5jZWQgd2l0aFxuKiBJbm5nZXN0LlxuKlxuKiBOb3RlIHRoYXQgdGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBzaGFwZSBvZiBhIGNvbmZpZyBvYmplY3RcbiogYW5kIG5vdCB1c2VkIGZvciBmZWF0dXJlIGNvbXBhdGliaWxpdHksIHN1Y2ggYXMgZmVhdHVyZSBYIGJlaW5nIGV4Y2x1c2l2ZVxuKiB3aXRoIGZlYXR1cmUgWTsgdGhlc2Ugc2hvdWxkIGJlIGhhbmRsZWQgb24gdGhlIElubmdlc3Qgc2lkZS5cbiovXG5jb25zdCBmdW5jdGlvbkNvbmZpZ1NjaGVtYSA9IHouc3RyaWN0T2JqZWN0KHtcblx0bmFtZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuXHRpZDogei5zdHJpbmcoKSxcblx0dHJpZ2dlcnM6IHouYXJyYXkoei51bmlvbihbei5zdHJpY3RPYmplY3Qoe1xuXHRcdGV2ZW50OiB6LnN0cmluZygpLFxuXHRcdGV4cHJlc3Npb246IHouc3RyaW5nKCkub3B0aW9uYWwoKVxuXHR9KSwgei5zdHJpY3RPYmplY3QoeyBjcm9uOiB6LnN0cmluZygpIH0pXSkpLFxuXHRzdGVwczogei5yZWNvcmQoei5zdHJpY3RPYmplY3Qoe1xuXHRcdGlkOiB6LnN0cmluZygpLFxuXHRcdG5hbWU6IHouc3RyaW5nKCksXG5cdFx0cnVudGltZTogei5zdHJpY3RPYmplY3Qoe1xuXHRcdFx0dHlwZTogei51bmlvbihbei5saXRlcmFsKFwiaHR0cFwiKSwgei5saXRlcmFsKFwid3NcIildKSxcblx0XHRcdHVybDogei5zdHJpbmcoKVxuXHRcdH0pLFxuXHRcdHJldHJpZXM6IHouc3RyaWN0T2JqZWN0KHsgYXR0ZW1wdHM6IHoubnVtYmVyKCkub3B0aW9uYWwoKSB9KS5vcHRpb25hbCgpXG5cdH0pKSxcblx0aWRlbXBvdGVuY3k6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcblx0YmF0Y2hFdmVudHM6IHouc3RyaWN0T2JqZWN0KHtcblx0XHRtYXhTaXplOiB6Lm51bWJlcigpLFxuXHRcdHRpbWVvdXQ6IHouc3RyaW5nKCksXG5cdFx0a2V5OiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG5cdFx0aWY6IHouc3RyaW5nKCkub3B0aW9uYWwoKVxuXHR9KS5vcHRpb25hbCgpLFxuXHRyYXRlTGltaXQ6IHouc3RyaWN0T2JqZWN0KHtcblx0XHRrZXk6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcblx0XHRsaW1pdDogei5udW1iZXIoKSxcblx0XHRwZXJpb2Q6IHouc3RyaW5nKCkudHJhbnNmb3JtKCh4KSA9PiB4KVxuXHR9KS5vcHRpb25hbCgpLFxuXHR0aHJvdHRsZTogei5zdHJpY3RPYmplY3Qoe1xuXHRcdGtleTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuXHRcdGxpbWl0OiB6Lm51bWJlcigpLFxuXHRcdHBlcmlvZDogei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuXHRcdGJ1cnN0OiB6Lm51bWJlcigpLm9wdGlvbmFsKClcblx0fSkub3B0aW9uYWwoKSxcblx0c2luZ2xldG9uOiB6LnN0cmljdE9iamVjdCh7XG5cdFx0a2V5OiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG5cdFx0bW9kZTogei5lbnVtKFtcInNraXBcIiwgXCJjYW5jZWxcIl0pXG5cdH0pLm9wdGlvbmFsKCksXG5cdGNhbmNlbDogei5hcnJheSh6LnN0cmljdE9iamVjdCh7XG5cdFx0ZXZlbnQ6IHouc3RyaW5nKCksXG5cdFx0aWY6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcblx0XHR0aW1lb3V0OiB6LnN0cmluZygpLm9wdGlvbmFsKClcblx0fSkpLm9wdGlvbmFsKCksXG5cdGRlYm91bmNlOiB6LnN0cmljdE9iamVjdCh7XG5cdFx0a2V5OiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG5cdFx0cGVyaW9kOiB6LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geCksXG5cdFx0dGltZW91dDogei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLm9wdGlvbmFsKClcblx0fSkub3B0aW9uYWwoKSxcblx0dGltZW91dHM6IHouc3RyaWN0T2JqZWN0KHtcblx0XHRzdGFydDogei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLm9wdGlvbmFsKCksXG5cdFx0ZmluaXNoOiB6LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geCkub3B0aW9uYWwoKVxuXHR9KS5vcHRpb25hbCgpLFxuXHRwcmlvcml0eTogei5zdHJpY3RPYmplY3QoeyBydW46IHouc3RyaW5nKCkub3B0aW9uYWwoKSB9KS5vcHRpb25hbCgpLFxuXHRjb25jdXJyZW5jeTogei51bmlvbihbXG5cdFx0ei5udW1iZXIoKSxcblx0XHRjb25jdXJyZW5jeU9wdGlvblNjaGVtYS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuXHRcdHouYXJyYXkoY29uY3VycmVuY3lPcHRpb25TY2hlbWEudHJhbnNmb3JtKCh4KSA9PiB4KSkubWluKDEpLm1heCgyKVxuXHRdKS5vcHRpb25hbCgpXG59KTtcbmNvbnN0IG9rID0gKGRhdGEpID0+IHtcblx0cmV0dXJuIHtcblx0XHRvazogdHJ1ZSxcblx0XHR2YWx1ZTogZGF0YVxuXHR9O1xufTtcbmNvbnN0IGVyciA9IChlcnJvcikgPT4ge1xuXHRyZXR1cm4ge1xuXHRcdG9rOiBmYWxzZSxcblx0XHRlcnJvclxuXHR9O1xufTtcbmNvbnN0IGluQmFuZFN5bmNSZXF1ZXN0Qm9keVNjaGVtYSA9IHouc3RyaWN0T2JqZWN0KHsgdXJsOiB6LnN0cmluZygpIH0pO1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IEFzeW5jUmVzcG9uc2VUeXBlLCBTdGVwTW9kZSwgU3RlcE9wQ29kZSwgZXJyLCBmdW5jdGlvbkNvbmZpZ1NjaGVtYSwgaW5CYW5kU3luY1JlcXVlc3RCb2R5U2NoZW1hLCBpbmNvbWluZ09wU2NoZW1hLCBqc29uRXJyb3JTY2hlbWEsIGxvZ0xldmVscywgb2ssIHNlbmRFdmVudFJlc3BvbnNlU2NoZW1hLCB0eXBlc19leHBvcnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiX19leHBvcnQiLCJ6IiwidHlwZXNfZXhwb3J0cyIsIkFzeW5jUmVzcG9uc2VUeXBlIiwiU3RlcE1vZGUiLCJTdGVwT3BDb2RlIiwiZXJyIiwiZnVuY3Rpb25Db25maWdTY2hlbWEiLCJpbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEiLCJpbmNvbWluZ09wU2NoZW1hIiwianNvbkVycm9yU2NoZW1hIiwibG9nTGV2ZWxzIiwib2siLCJzZW5kRXZlbnRSZXNwb25zZVNjaGVtYSIsImJhc2VKc29uRXJyb3JTY2hlbWEiLCJvYmplY3QiLCJuYW1lIiwic3RyaW5nIiwidHJpbSIsIm9wdGlvbmFsIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhY2siLCJtYXliZUpzb25FcnJvclNjaGVtYSIsImxhenkiLCJjYXVzZSIsInVuaW9uIiwidW5rbm93biIsImV4dGVuZCIsInBhc3N0aHJvdWdoIiwiY2F0Y2giLCJ0cmFuc2Zvcm0iLCJ2YWwiLCJTdGVwT3BDb2RlJDEiLCJTdGVwTW9kZSQxIiwiQXN5bmNSZXNwb25zZVR5cGUkMSIsImlkIiwibWluIiwiZGF0YSIsImFueSIsImlucHV0IiwiaWRzIiwiYXJyYXkiLCJkZWZhdWx0Iiwic3RhdHVzIiwibnVtYmVyIiwiY29uY3VycmVuY3lPcHRpb25TY2hlbWEiLCJzdHJpY3RPYmplY3QiLCJsaW1pdCIsImtleSIsInNjb3BlIiwiZW51bSIsInRyaWdnZXJzIiwiZXZlbnQiLCJleHByZXNzaW9uIiwiY3JvbiIsInN0ZXBzIiwicmVjb3JkIiwicnVudGltZSIsInR5cGUiLCJsaXRlcmFsIiwidXJsIiwicmV0cmllcyIsImF0dGVtcHRzIiwiaWRlbXBvdGVuY3kiLCJiYXRjaEV2ZW50cyIsIm1heFNpemUiLCJ0aW1lb3V0IiwiaWYiLCJyYXRlTGltaXQiLCJwZXJpb2QiLCJ4IiwidGhyb3R0bGUiLCJidXJzdCIsInNpbmdsZXRvbiIsIm1vZGUiLCJjYW5jZWwiLCJkZWJvdW5jZSIsInRpbWVvdXRzIiwic3RhcnQiLCJmaW5pc2giLCJwcmlvcml0eSIsInJ1biIsImNvbmN1cnJlbmN5IiwibWF4IiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/version.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/version.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n//#region src/version.ts\nconst version = \"3.45.1\";\n//#endregion\n //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx3QkFBd0I7QUFDeEIsTUFBTUEsVUFBVTtBQUVoQixZQUFZO0FBQ08sQ0FDbkIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLWFwcC8uL25vZGVfbW9kdWxlcy9pbm5nZXN0L3ZlcnNpb24uanM/MmQwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL3ZlcnNpb24udHNcbmNvbnN0IHZlcnNpb24gPSBcIjMuNDUuMVwiO1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IHZlcnNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/version.js\n");

/***/ })

};
;